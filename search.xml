<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>并发编程-并发模型对比</title>
      <link href="/2020/06/17/%E5%B9%B6%E5%8F%91%E7%AE%80%E7%95%A5-%E5%AF%B9%E6%AF%94%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/06/17/%E5%B9%B6%E5%8F%91%E7%AE%80%E7%95%A5-%E5%AF%B9%E6%AF%94%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一-并发模型总结"><a href="#一-并发模型总结" class="headerlink" title="一 并发模型总结"></a>一 并发模型总结</h2><ul><li>多进程：<ul><li>稳定性高：进程地址空间互相独立，一个进程出现问题，不会影响其他进程。Linux系统是个典型的多进程模型，稳定性极高，适合服务端开发</li><li>开销很大</li></ul></li><li>多线程：<ul><li>开销较小</li></ul></li><li>协程：<ul><li>程序执行效率高</li></ul></li><li>非阻塞I/O：<ul><li>无需痛苦的同步编程</li></ul></li></ul><p>交换数据方式：</p><ul><li>多进程交换数据方式复杂（管道、消息队列、信号量、共享内存）</li><li>多线程之间交换数据很简单，但会产生竞态条件，需要解决同步问题</li></ul><p>综合而言，多线程方式具备大量优势，但是在处理信号、同时运行多套不同程序以及包含多个需要超大内存支持的任务等，多进程方式更适合，而协程和非阻塞IO则更能充分的提升程序的运行效率。  </p><h2 id="二-线程不一定比进程轻量"><a href="#二-线程不一定比进程轻量" class="headerlink" title="二 线程不一定比进程轻量"></a>二 线程不一定比进程轻量</h2><p>理论上，线程之间共享内存，创建新线程的时候不需要创建真正的虚拟内存空间，也不需要 MMU（内存管理单元）上下文切换。此外，线程间通信比进程之间通信更加简单，主要是因为线程之间有共享内存，而进程通信往往需要利用各种模式的 IPC（进程间通信），如信号量，消息队列，管道等。  </p><p>但是在多处理器操作系统中，线程并不一定比进程更高效：例如 Linux 就是不区分线程和进程的，两者在 Linux 都被称作任务（task）。每个任务在 cloned 的时候都有一个介于最小到最大之间的共享级别。  </p><ul><li>调用 fork() 创建任务时，创建的是一个没有共享文件描述符，PID 和内存空间的新任务。而调用 pthread_create() 创建任务时，创建的任务将包含上述所有共享资源。  </li><li>线程之间保持共享内存与多核的L1缓存中的数据同步，与在隔离内存中运行不同的进程相比，需要付出更加大的代价。  </li></ul><h2 id="三-线程的改进方向"><a href="#三-线程的改进方向" class="headerlink" title="三 线程的改进方向"></a>三 线程的改进方向</h2><p>线程变慢的主要三个原因：</p><ul><li>线程自身有一个很大的堆（≥ 1MB）占用了大量内存，如果一下创建 1000 个线程意味着需要 1GB 的内存！！！！！</li><li>线程需要重复存储许多寄存器，其中一些包括 AVX（高级向量扩展），SSE（流式 SIMD 外设），浮点寄存器，程序计数器（PC），堆栈指针（SP），这会降低应用程序性能。</li><li>线程创建和消除需要调用操作系统以获取资源（例如内存），而这一操作相对是比较慢的。</li></ul><h2 id="四-goroutine"><a href="#四-goroutine" class="headerlink" title="四 goroutine"></a>四 goroutine</h2><p>Goroutines 是在 Golang 中执行并发任务的方式，不过要切记：  </p><blockquote><p>Goroutines仅存在于 Go 运行时而不存在于 OS 中，因此需要 Go调度器（GoRuntimeScheduler） 来管理它们的生命周期。</p></blockquote><p>Go运行时为此维护了三个C结构（<a href="https://golang.org/src/runtime/runtime2.go）：" target="_blank" rel="noopener">https://golang.org/src/runtime/runtime2.go）：</a></p><ul><li>G 结构：表示单个 Goroutine，包含跟踪其堆栈和当前状态所需的对象。还包含自己负责的代码的引用。</li><li>M 结构：表示 OS 线程。包含一些对象指针，例如全局可执行的 Goroutines 队列，当前运行的 Goroutine，它自己的缓存以及对 Go 调度器的引用。</li><li>P 结构：也做Sched结构，它是一个单一的全局对象，用于跟踪 Goroutine 和 M 的不同队列以及调度程序运行时需要的其他一些信息，例如单一全局互斥锁（Global Sched Lock）。  </li></ul><p>G 结构主要存在于两种队列之中，一个是 M （线程）可以找到任务的可执行队列，另外一个是一个空闲的 Goroutine 列表。调度程序维护的 M（执行线程）只能每次关联其中一个队列。为了维护这两种队列并进行切换，就必须维持单一全局互斥锁（Global Sched Lock）。  </p><p>因此，在启动时，go 运行空间会为 GC，调度程序和用户代码启动许多 Goroutine。并创建 OS 线程来处理这些 Goroutine。不过创建的线程数量最多可以等于 GOMAXPROCS（默认为 1，但为了获得最佳性能，通常设置为计算机上的处理器数量）。  </p><h2 id="五-协程对比线程的改进"><a href="#五-协程对比线程的改进" class="headerlink" title="五 协程对比线程的改进"></a>五 协程对比线程的改进</h2><p>为了使运行时的堆栈更小，go 在运行期间使用了大小可调整的有限堆栈，并且初始大小只有 2KB/goroutine。新的 Goroutine 通常会分配几 kb 的空间，这几乎总是足够的。如果不够的话，运行空间还能自动增长（或者缩小）内存来实现堆栈的管理，从而让大部分 Goroutine 存在于适量的内存中。每个函数调用的平均 CPU 开销大概是三个简单指令。因此在同一地址空间中创建数十万个 Goroutine 是切实可行的。但是如果 Goroutine 是线程的话，系统资源将很快被消耗完。 </p><h2 id="六-协程阻塞"><a href="#六-协程阻塞" class="headerlink" title="六 协程阻塞"></a>六 协程阻塞</h2><p>当 Goroutine 进行阻塞调用时，例如通过调用阻塞的系统调用，这时调用的线程必须阻塞，go 的运行空间会操作自动将同一操作系统线程上的其他 Goroutine，将它们移动到从调度程序（Sched Struct）的线程队列中取出的另一个可运行的线程上，所以这些 Goroutine 不会被阻塞。因此，运行空间应至少创建一个线程，以继续执行不在阻塞调用中的其他 Goroutine。 而且关键的是程序员是看不到这一点的。结论是，我们称之为 Goroutines 的事物，可以是很低廉的：它们在堆栈的内存之外几乎没有开销，而内存中也只有几千字节。</p><p>Go 协程也可以很好地扩展。  </p><p>但是，如果你使用只存在于 Go 的虚拟空间的 channels 进行通信（产生阻塞时），操作系统将不会阻塞该线程。 只是让该 Goroutine 进入等待状态，并安排另一个可运行的 Goroutine（来自 M 结构关联的可执行队列）它的位置。  </p><h2 id="七-Go-Runtime-Scheduler"><a href="#七-Go-Runtime-Scheduler" class="headerlink" title="七 Go Runtime Scheduler"></a>七 Go Runtime Scheduler</h2><p>Go Runtime Scheduler 跟踪记录每个 Goroutine，并安排它们依次地在进程的线程池中运行。  </p><p>Go Runtime Scheduler 执行协作调度，这意味着只有在当前 Goroutine 阻塞或完成时才会调度另一个 Goroutine，这通过代码可以轻松完成。这里有些例子：</p><ul><li>调用系统调用如文件或网络操作阻塞时</li><li>因为垃圾收集被停止后</li></ul><p>这样比定时阻塞并调度新线程的抢占式调度要好得多，因为当线程数量增加，或者当高优先级任务将被调度运行时，有低优先级的任务已经在运行了（此时低优先级队列将被阻塞），定时抢占调度可能导致某些任务完成花费的时间大大超过实际所需时间。  </p><p>另一个优点是，因为 Goroutine 在代码中隐式调用的，例如在睡眠或 channel 等待期间，编译只需要安全地恢复在这些时刻处存活的寄存器。在 Go 中，这意味着在上下文切换期间仅更新 3 个寄存器，即 PC，SP 和 DX（数据寄存器） 而不是所有寄存器（例如 AVX，浮点，MMX）。</p><h2 id="八-goroutine-与-coroutine"><a href="#八-goroutine-与-coroutine" class="headerlink" title="八 goroutine 与 coroutine"></a>八 goroutine 与 coroutine</h2><p>C#、 Lua、 Python语言都支持协程 coroutine（Java也有一些第三方库支持）。  </p><p>coroutine与 goroutine都可以将函数或者语句在独立的环境中运行，但是它们之间有两点不同：</p><ul><li>goroutine可能发生并行执行，coroutine始终顺序执行</li><li>goroutine 使用 channel 通信，coroutine 使用 yield 和 resume</li></ul><blockquote><p>coroutine 程序需要主动交出控制权，宿主才能获得控制权并将控制权交给其他 coroutine  </p></blockquote><p>coroutine 的运行机制属于协作式任务处理。在早期的操作系统中，应用程序在不需要使用 CPU 时，会主动交出 CPU 使用权。如果开发者故意让应用程序长时间占用 CPU，操作系统也无能为力。coroutine 始终发生在单线程。</p><blockquote><p>goroutine可能发生在多线程环境下， goroutine无法控制自己获取高优先度支持  </p></blockquote><p>goroutine 属于抢占式任务处理，和现有的多线程和多进程任务处理非常类似。应用程序对 CPU 的控制最终还需要由操作系统来管理，操作系统如果发现一个应用程序长时间大量地占用 CPU，那么用户有权终止这个任务。</p><h2 id="九-Go协程总结"><a href="#九-Go协程总结" class="headerlink" title="九 Go协程总结"></a>九 Go协程总结</h2><p>Go协程的特点：</p><ul><li>有独立的栈空间</li><li>共享程序堆空间</li><li>调度由用户控制</li></ul><p>注意：</p><ul><li>Go程序在启动时，就会为main函数创建一个默认的goroutine，也就是入口函数main本身也是一个协程</li><li>如果主线程退出了，则协程即使还没有执行完毕也退出 </li></ul><p>单纯的将函数并发执行是没有意义的，函数与函数之间必须能够交换数据才能体现并发执行函数的意义。为了实现数据的通信，有两种常见并发模型：</p><ul><li>共享数据：一般使用共享内存方式来共享数据，Go中的实现方式为互斥锁（sync包）。</li><li>消息：消息机制认为每个并发单元都是独立个体，拥有自己的变量。不同的并发单元之间不共享各自的变量，只通过消息来进行数据输入输出，Go中的实现方式为channle。</li></ul><p>在Go中对上述两种方式都进行了实现，但是Go不推荐共享数据方式，推荐channel的方式进行协程通信。因为多个 goroutine 为了争抢数据，容易发生竞态问题，会造成执行的低效率，使用队列的方式是最高效的， channel 就是一种队列一样的结构。  </p><p>如图所示：<br><img src="https://img2020.cnblogs.com/blog/1762180/202006/1762180-20200613152608611-1941942577.png" alt=""></p><p>channel特性：</p><ul><li>channel的本质是一个数据结构-队列，先进先出</li><li>channel是线程安全的，多goroutine访问时，不需要加锁，因为在任何时候，同时只能有一个goroutine访问通道。</li><li>channel拥有类型，一个string的channle只能存放string类型数据</li></ul><p>golang奉行通过通信来共享内存，而不是通过共享内存来通信。</p><p><img src="https://img2020.cnblogs.com/blog/1762180/202006/1762180-20200612111216567-1625246241.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程-协程</title>
      <link href="/2020/06/17/%E5%B9%B6%E5%8F%91%E7%AE%80%E7%95%A5-%E5%8D%8F%E7%A8%8B/"/>
      <url>/2020/06/17/%E5%B9%B6%E5%8F%91%E7%AE%80%E7%95%A5-%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一-理解协程"><a href="#一-理解协程" class="headerlink" title="一 理解协程"></a>一 理解协程</h2><blockquote><p>协程：也称为纤程（Coroutine）,  是一个特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处外继续运行。</p></blockquote><p>协程与进程、线程相比并不是一个维度的概念，协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。   </p><p>正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程（目前的协程框架一般都是设计成 1:N 模式）。</p><p>注意：</p><ul><li>多个进程或一个进程内的多个线程是可以并行运行的</li><li>一个线程内的多个协程却是串行的，无论CPU有多少个核，因为协程本质上还是一个函数，当一个协程运行时，其它协程必须挂起</li><li>但是协程的切换过程只有用户态，即没有陷入内核态，因此切换效率比进程和线程高很多 </li></ul><p>协程自己会主动适时的让出 CPU，也就是说每个协程池里面有一个调度器，这个调度器是被动调度的。意思就是他不会主动调度。而且当一个协程发现自己执行不下去了（比如异步等待网络的数据回来，但是当前还没有数据到)，这个时候就可以由这个协程通知调度器，这个时候执行到调度器的代码，调度器根据事先设计好的调度算法找到当前最需要 CPU 的协程。切换这个协程的 CPU 上下文把 CPU 的运行权交个这个协程，直到这个协程出现执行不下去需要等等的情况，或者它调用主动让出 CPU 的 API 之类，触发下一次调度。  </p><h2 id="二-协程的优缺点"><a href="#二-协程的优缺点" class="headerlink" title="二 协程的优缺点"></a>二 协程的优缺点</h2><p>优点：</p><ul><li>占用小：协程更加轻量，创建成本更小，降低了内存消耗，协程一般只占据极小的内存（2~5KB），而线城市1MB左右。虽然线程和协程都是独有栈，但是线程栈是固定的，比如在Java中，基本是2M，假如一个栈只有一个打印方法，还要为此开辟一个2M的栈，就太浪费了。而Go的的协程具备动态收缩功能，初始化为2KB，最大可达1GB</li><li>运行效率高：线程切换需要从用户态-&gt;内核态-&gt;用户态，而协程切换是在用户态上，即用户态-&gt;用户态-&gt;用户态，其切换过程由语言层面的调度器（coroutine）或者语言引擎（goroutine）实现。</li><li>减少了同步锁：协程最终还是运行在线程上，本质上还是单线程运行，没有临界区域的话自然不需要锁的机制。多协程自然没有竞争关系。但是，如果存在临界区域，依然需要使用锁，协程可以减少以往必须使用锁的场景</li><li>同步代码思维写出异步代码</li></ul><p>缺点：</p><ul><li>无法利用多核资源：协程运行在线程上，单线程应用无法很好的利用多核，只能以多进程方式启动。</li><li>协程不能有阻塞操作：线程是抢占式，线程在遇见IO操作时候，线程从运行态→阻塞态，释放cpu使用权。这是由操作系统调度。协程是非抢占式，如果遇见IO操作时候，协程是主动释放执行权限的，如果无法主动释放，程序将阻塞，无法往下执行，随之而来是整个线程被阻塞。</li><li>CPU密集型不是长处：假设这个线程中有一个协程是 CPU 密集型的他没有 IO 操作，也就是自己不会主动触发调度器调度的过程，那么就会出现其他协程得不到执行的情况，所以这种情况下需要程序员自己避免。</li></ul><p>应用场景：</p><ul><li>高性能计算，牺牲公平性换取吞吐。协程最早来自高性能计算领域的成功案例，协作式调度相比抢占式调度而言，可以在牺牲公平性时换取吞吐</li><li>IO Bound 的任务：虽然异步IO在数据到达的时候触发回调，减少了线程切换带来性能损失，但是该思想不符合人类的思维模式。异步回调在破坏点思维连贯性的同时也破坏掉了程序的连贯性，让你在阅读程序的时候花费更多的精力。但是协程可以很好解决这个问题。比如把一个 IO 操作 写成一个协程。当触发 IO 操作的时候就自动让出 CPU 给其他协程。要知道协程的切换很轻的。协程通过这种对异步 IO 的封装既保留了性能也保证了代码的容易编写和可读性。</li></ul><h2 id="三-协程的简单实现"><a href="#三-协程的简单实现" class="headerlink" title="三 协程的简单实现"></a>三 协程的简单实现</h2><p>ES6提供了一种新的方法名叫Generator。Generator的执行过程可以被暂停和恢复，所以它被认为是ES6中的协程，但严格地说，Generator只是半协程（semi-coroutine），因为虽然它可以主动放弃执行权，但是它并没有告知运行环境，下一步哪个协程会被调用。当一个Generator被调用时，它的代码并不会被执行，调用者得到的是它的观察者（Observer）。调用者通过调用这个观察者的方法，比如next方法，来执行Generator的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Q = [];</span><br><span class="line"><span class="keyword">const</span> Q_LEN = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">produce</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Q.length &lt; Q_LEN) &#123;</span><br><span class="line">        <span class="keyword">const</span> item = <span class="built_in">Date</span>.now();</span><br><span class="line">        Q.push(item);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Item <span class="subst">$&#123;item&#125;</span> is produced`</span>);</span><br><span class="line">        <span class="keyword">if</span> (Q.length === Q_LEN) &#123;</span><br><span class="line">            <span class="keyword">yield</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">consume</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Q.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> item = Q.pop();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Item <span class="subst">$&#123;item&#125;</span> is consumed`</span>);</span><br><span class="line">        <span class="keyword">if</span> (Q.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">yield</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> producer = produce();</span><br><span class="line">    <span class="keyword">const</span> consumer = consume();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        producer.next();</span><br><span class="line">        consumer.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure><p>在上面代码中，produce和consume是两个协程。bootstrap方法是这两个协程的调用者，它首先获取produce和consume协程的观察者，然后循环调用观察者的next方法，从而使得生产者和消费者的关系持续运行。在循环过程中，如果produce检测队列已满，它就主动放弃执行权从而被暂停，consume将获得执行权，如果consume检测队列已空，它就主动放弃执行权从而被暂停，produce将重新获得执行权。</p><p><img src="https://img2020.cnblogs.com/blog/1762180/202006/1762180-20200612111216567-1625246241.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程-非阻塞IO</title>
      <link href="/2020/06/17/%E5%B9%B6%E5%8F%91%E7%AE%80%E7%95%A5-%E9%9D%9E%E9%98%BB%E5%A1%9EIO/"/>
      <url>/2020/06/17/%E5%B9%B6%E5%8F%91%E7%AE%80%E7%95%A5-%E9%9D%9E%E9%98%BB%E5%A1%9EIO/</url>
      
        <content type="html"><![CDATA[<h2 id="一-深入理解进程阻塞"><a href="#一-深入理解进程阻塞" class="headerlink" title="一 深入理解进程阻塞"></a>一 深入理解进程阻塞</h2><p>进程间的通信时通过 send() 和 receive() 两种基本操作完成的。具体如何实现这两种基础操作，存在着不同的设计：  </p><blockquote><p>消息的传递有可能是<strong>阻塞的</strong>或<strong>非阻塞的</strong>，也被称为<strong>同步</strong>或<strong>异步</strong>的。—-《操作系统概论》</p></blockquote><ul><li>阻塞式发送：blocking send，发送方进程会被一直阻塞，直到消息被接受方进程收到</li><li>非阻塞式发送：nonblocking send），发送方进程调用 send() 后，立即就可以其他操作</li><li>阻塞式接收：blocking receive，接收方调用 receive() 后一直阻塞，直到消息到达可用</li><li>非阻塞式接受：nonblocking receive，接收方调用 receive() 函数后，要么得到一个有效的结果，要么得到一个空值，即不会被阻塞。</li></ul><p>上述不同类型的发送方式和不同类型的接收方式，可以自由组合，即从进程级通信的维度讨论时， 阻塞和同步（非阻塞和异步）就是一对同义词， 且需要针对发送方和接收方作区分对待。  </p><p>概念解释：</p><ul><li>中断（interrupt）：CPU 微处理器有一个中断信号位， 在每个CPU时钟周期的末尾, CPU会去检测那个中断信号位是否有中断信号到达， 如果有，则会根据中断优先级决定是否要暂停当前执行的指令， 转而去执行处理中断的指令。 （其实就是 CPU 层级的 while 轮询）</li><li>时钟中断( Clock Interrupt )：一个硬件时钟会每隔一段（很短）的时间就产生一个中断信号发送给 CPU，CPU 在响应这个中断时， 就会去执行操作系统内核的指令， 继而将 CPU 的控制权转移给了操作系统内核， 可以由操作系统内核决定下一个要被执行的指令。</li><li>系统调用（system call）：system call 是操作系统提供给应用程序的接口。 用户通过调用 systemcall 来完成那些需要操作系统内核进行的操作， 例如硬盘， 网络接口设备的读写等。</li></ul><p>进程在从用户空间切换到内核空间，需要以下步骤：</p><ul><li>1.当一个程序正在执行的过程中， 中断（interrupt） 或 系统调用（system call） 发生可以使得 CPU 的控制权会从当前进程转移到操作系统内核。</li><li>2.操作系统内核负责保存进程i在 CPU 中的上下文（程序计数器，寄存器）到 PCB$_i$（操作系统分配给进程的一个内存块）中 </li><li>3.从PCB$_j$取出进程 j 的CPU 上下文， 将 CPU 控制权转移给进程 j ， 开始执行进程 j 的指令。</li></ul><p>操作系统在进行进切换时，需要进行一系列的内存读写操作， 这带来了一定的开销：对于一个运行着 UNIX 系统的现代 PC 来说， 进程切换至少需要花费 300 us 的时间。我们所说的 “阻塞”是指进程在发起了一个系统调用（System Call） 后，由于该系统调用的操作不能立即完成，需要等待一段时间，于是内核将进程挂起为<strong>等待 （waiting）</strong>状态， 以确保它不会被调度执行， 占用 CPU 资源。  </p><p>综上所述，<strong>阻塞和非阻塞描述的是进程的一个操作是否会使得进程转变为“等待”的状态</strong>，又因为阻塞这个词是与系统调用 System Call 紧紧联系在一起的， 因为要让一个进程进入 等待（waiting） 的状态，要么是它主动调用 wait() 或 sleep() 等挂起自己的操作，要么是它调用 System Call， 而 System Call 因为涉及到了 I/O 操作，不能立即完成，于是内核就会先将该进程置为等待状态，调度其他进程的运行，等到它所请求的 I/O 操作完成了以后，再将其状态更改回 ready 。  </p><p>操作系统内核在执行 System Call 时， CPU 需要与 IO 设备完成一系列物理通信上的交互， 其实再一次会涉及到阻塞和非阻塞的问题， 例如， 操作系统发起了一个读硬盘的请求后， 其实是向硬盘设备通过总线发出了一个请求，它即可以阻塞式地等待IO 设备的返回结果，也可以非阻塞式的继续其他的操作。 在现代计算机中，这些物理通信操作基本都是异步完成的， 即发出请求后， 等待 I/O 设备的中断信号后， 再来读取相应的设备缓冲区。 但是，大部分操作系统默认为用户级应用程序提供的都是阻塞式的系统调用 （blocking systemcall）接口， 因为阻塞式的调用，使得应用级代码的编写更容易（代码的执!行顺序和编写顺序是一致的）。  </p><p>但同样，现在的大部分操作系统也会提供非阻塞I/O 系统调用接口（Nonblocking I/O system call）。 一个非阻塞调用不会挂起调用程序， 而是会立即返回一个值，表示有多少bytes 的数据被成功读取（或写入）。  </p><p>非阻塞I/O 系统调用( nonblocking system call )的另一个替代品是 异步I/O系统调用 （asychronous system call）。 与非阻塞 I/O 系统调用类似，asychronous system call 也是会立即返回， 不会等待 I/O 操作的完成， 应用程序可以继续执行其他的操作， 等到 I/O 操作完成了以后，操作系统会通知调用进程（设置一个用户空间特殊的变量值 或者 触发一个 signal 或者 产生一个软中断 或者 调用应用程序的回调函数）。</p><p>非阻塞I/O 系统调用( nonblocking system call ) 和 <strong>异步I/O系统调用 （asychronous system call）</strong>的区别是：</p><ul><li>一个非阻塞I/O 系统调用 read() 操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。</li><li>异步I/O系统调用 read（）结果必须是完整的，但是这个操作完成的通知可以延迟到将来的一个时间点。</li></ul><p>总结：</p><ul><li>阻塞/非阻塞， 同步/异步的概念要注意讨论的上下文<ul><li>在进程通信层面， 阻塞/非阻塞， 同步/异步基本是同义词， 但是需要注意区分讨论的对象是发送方还是接收方，发送方阻塞/非阻塞（同步/异步）和接收方的阻塞/非阻塞（同步/异步） 是互不影响的。</li><li>在 IO 系统调用层面（ IO system call ）层面， 非阻塞IO 系统调用 和 异步IO 系统调用存在着一定的差别， 它们都不会阻塞进程， 但是返回结果的方式和内容有所差别， 但是都属于非阻塞系统调用（ non-blocing system call ）</li></ul></li><li>阻塞系统调用（non-blocking I/O system call 与 asynchronous I/O system call） 的存在可以用来实现线程级别的 I/O 并发， 与通过多进程实现的 I/O 并发相比可以减少内存消耗以及进程切换的开销。</li></ul><h2 id="二-I-O模型总结"><a href="#二-I-O模型总结" class="headerlink" title="二 I/O模型总结"></a>二 I/O模型总结</h2><h3 id="2-0-I-O模型汇总"><a href="#2-0-I-O模型汇总" class="headerlink" title="2.0 I/O模型汇总"></a>2.0 I/O模型汇总</h3><p>Unix网络编程中，可以利用的IO模型有5种：</p><ul><li>阻塞IO</li><li>非阻塞IO</li><li>多路复用IO</li><li>信号驱动IO</li><li>异步IO</li></ul><h3 id="2-1-阻塞I-O模型"><a href="#2-1-阻塞I-O模型" class="headerlink" title="2.1 阻塞I/O模型"></a>2.1 阻塞I/O模型</h3><p>阻塞I/O是最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。  </p><p>典型的阻塞IO模型的例子为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = socket.<span class="built_in">read</span>();</span><br></pre></td></tr></table></figure><p>如果数据没有就绪，就会一直阻塞在read()方法。  </p><h3 id="2-2-非阻塞IO模型"><a href="#2-2-非阻塞IO模型" class="headerlink" title="2.2 非阻塞IO模型"></a>2.2 非阻塞IO模型</h3><p>当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。  </p><p>所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU，典型的非阻塞IO模型一般如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123; </span><br><span class="line">    data = socket.<span class="built_in">read</span>(); </span><br><span class="line">        <span class="keyword">if</span>(data!= error)&#123; </span><br><span class="line">            <span class="comment">// 处理数据 </span></span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。  </p><h3 id="2-3-多路复用IO模型"><a href="#2-3-多路复用IO模型" class="headerlink" title="2.3 多路复用IO模型"></a>2.3 多路复用IO模型</h3><p>多路复用IO模型是目前使用得比较多的模型，如Java的NIO。在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。  </p><p>在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。  </p><p>采用 多线程+ 阻塞IO 也能达到类似的效果，但是此时每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。而多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。  </p><p>另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态是通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。  </p><p>不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。  </p><h3 id="2-4-信号驱动I-O模型"><a href="#2-4-信号驱动I-O模型" class="headerlink" title="2.4 信号驱动I/O模型"></a>2.4 信号驱动I/O模型</h3><p>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。  </p><h3 id="2-5-异步IO模型"><a href="#2-5-异步IO模型" class="headerlink" title="2.5 异步IO模型"></a>2.5 异步IO模型</h3><p>异步IO模型是最理想的IO模型：当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它收到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，接着将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。在此过程中用户线程完全不需要知道实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。  </p><p>在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作。  </p><p>异步IO是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO。也只有异步IO才真正的异步IO，其他的IO模型都是同步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。  </p><h2 id="二-高性能I-O设计模式"><a href="#二-高性能I-O设计模式" class="headerlink" title="二 高性能I/O设计模式"></a>二 高性能I/O设计模式</h2><h3 id="2-1-多进程"><a href="#2-1-多进程" class="headerlink" title="2.1 多进程"></a>2.1 多进程</h3><p>每到达一个请求， 们为这个请求新创建一个进程来处理。这样，一个进程在等待 IO 时，其他的进程可以被调度执行，更加充分地利用 CPU 等资源。但是每新创建一个进程都会消耗一定的内存空间，且进程切换也会有时间消耗，高并发时，大量进程来回切换的时间开销会变得明显起来。  </p><h3 id="2-2-多线程模式"><a href="#2-2-多线程模式" class="headerlink" title="2.2 多线程模式"></a>2.2 多线程模式</h3><p>在传统的网络服务设计模式中，有两种比较经典的模式：一种是 多线程，一种是线程池。  </p><p>对于多线程模式，也就说来了client，服务器就会新建一个线程来处理该client的读写事件，如下图所示：  </p><p><img src="https://img2020.cnblogs.com/blog/1762180/202006/1762180-20200612110627565-1264652248.png" alt="">  </p><p>这种模式虽然处理起来简单方便，但是由于服务器为每个client的连接都采用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，再有用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。  </p><h3 id="2-3-线程池模式"><a href="#2-3-线程池模式" class="headerlink" title="2.3 线程池模式"></a>2.3 线程池模式</h3><p>为了解决这种一个线程对应一个客户端模式带来的问题，提出了采用线程池的方式，也就说创建一个固定大小的线程池，来一个客户端，就从线程池取一个空闲线程来处理，当客户端处理完读写操作之后，就交出对线程的占用。因此这样就避免为每一个客户端都要创建线程带来的资源浪费，使得线程可以重用。  </p><h3 id="2-4-Reactor模式"><a href="#2-4-Reactor模式" class="headerlink" title="2.4 Reactor模式"></a>2.4 Reactor模式</h3><p>在Reactor模式中，会先对每个client注册感兴趣的事件，然后有一个线程专门去轮询每个client是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理完之后，便再转去继续轮询，如下图所示：  </p><p><img src="https://img2020.cnblogs.com/blog/1762180/202006/1762180-20200612110644145-1145726434.png" alt="">  </p><p>从这里可以看出，上面的五种IO模型中的多路复用IO就是采用Reactor模式。注意，上面的图中展示的 是顺序处理每个事件，当然为了提高事件处理速度，可以通过多线程或者线程池的方式来处理事件。  </p><h3 id="2-5-Proactor模式"><a href="#2-5-Proactor模式" class="headerlink" title="2.5 Proactor模式"></a>2.5 Proactor模式</h3><p>在Proactor模式中，当检测到有事件发生时，会新起一个异步操作，然后交由内核线程去处理，当内核线程完成IO操作之后，发送一个通知告知操作已完成，可以得知，异步IO模型采用的就是Proactor模式。</p><h2 id="三-杰出代表Node-js"><a href="#三-杰出代表Node-js" class="headerlink" title="三 杰出代表Node.js"></a>三 杰出代表Node.js</h2><p>Node.js是在v8引擎基础上开发的javascript运行时，为javascript提供了模块化、文件IO、Socket编程等支持。其架构如图所示：  </p><p><img src="https://img2020.cnblogs.com/blog/1762180/202006/1762180-20200612110658878-432877448.png" alt="">  </p><p>他们分别是：</p><ul><li>Node.js 标准库，这部分是由 Javascript编写的，即我们使用过程中直接能调用的 API。在源码中的 lib 目录下可以看到。</li><li>Node bindings，这一层是 Javascript与底层 C/C++ 能够沟通的关键，前者通过 bindings 调用后者，相互交换数据。实现在 node.cc</li><li>这一层是支撑 Node.js 运行的关键，由 C/C++ 实现。<ul><li>V8：Google 推出的 Javascript VM，也是 Node.js 为什么使用的是 Javascript的关键，它为 Javascript提供了在非浏览器端运行的环境，它的高效是 Node.js 之所以高效的原因之一。</li><li>Libuv：它为 Node.js 提供了跨平台，线程池，事件池，异步 I/O 等能力，是 Node.js 如此强大的关键。</li><li>C-ares：提供了异步处理 DNS 相关的能力。</li><li>http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力。  </li></ul></li></ul><p>一个基础的node http web server：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHeader(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span> : <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  res.write(<span class="string">"Hello world!"</span>);</span><br><span class="line">  res.end();</span><br><span class="line">&#125;).listen(<span class="number">9000</span>);</span><br></pre></td></tr></table></figure><p>Node.js的http模型：<br><img src="https://img2020.cnblogs.com/blog/1762180/202006/1762180-20200612110711734-629037490.png" alt="">  </p><p>Node中的事件驱动：Event Loop is a programming construct that waits for and dispatches events or messages in a program</p><ul><li>1、每个Node.js进程只有一个主线程在执行程序代码，形成一个执行栈（execution context stack)。</li><li>2、主线程之外，还维护了一个”事件队列”（Event queue）。当用户的网络请求或者其它的异步操作到来时，node都会把它放到Event Queue之中，此时并不会立即执行它，代码也不会被阻塞，继续往下走，直到主线程代码执行完毕。</li><li>3、主线程代码执行完毕完成后，然后通过Event Loop，也就是事件循环机制，开始到Event Queue的开头取出第一个事件，从线程池中分配一个线程去执行这个事件，接下来继续取出第二个事件，再从线程池中分配一个线程去执行，然后第三个，第四个。主线程不断的检查事件队列中是否有未执行的事件，直到事件队列中所有事件都执行完了，此后每当有新的事件加入到事件队列中，都会通知主线程按顺序取出交EventLoop处理。当有事件执行完毕后，会通知主线程，主线程执行回调，线程归还给线程池。</li><li>4、主线程不断重复上面的第三步。</li></ul><p><img src="https://img2020.cnblogs.com/blog/1762180/202006/1762180-20200612111216567-1625246241.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程-多线程</title>
      <link href="/2020/06/17/%E5%B9%B6%E5%8F%91%E7%AE%80%E7%95%A5-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/06/17/%E5%B9%B6%E5%8F%91%E7%AE%80%E7%95%A5-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一-线程概述"><a href="#一-线程概述" class="headerlink" title="一 线程概述"></a>一 线程概述</h2><h3 id="1-1-进程与线程创建"><a href="#1-1-进程与线程创建" class="headerlink" title="1.1 进程与线程创建"></a>1.1 进程与线程创建</h3><p>操作系统会为每个进程分配一定的内存地址空间，如图所示：  </p><p><img src="https://img2020.cnblogs.com/blog/1762180/202006/1762180-20200612110316839-1230520130.png" alt=""></p><p>上图所示的是32位系统中虚拟内存的分配方式，不同系统分配的虚拟内存是不同的，但是其数据所占区域的比例是相同的：</p><ul><li>32位：最大内存地址为2<sup>32</sup>，这么多的字节数换算为G单位，即为4G。（换算为1G=1024MB=1024<em>1024KB=1024</em>1024*1024B）</li><li>64位：最大内存地址为2<sup>64</sup>，这么多的字节数换算为G单位，数值过大，不便图示</li></ul><p>在多进程编程的并发模型中，每次fork一个子进程，都代表新创建了一个完整的上述内存地址空间，如图所示：  </p><p><img src="https://img2020.cnblogs.com/blog/1762180/202006/1762180-20200612110332985-517287688.png" alt=""></p><p>线程就与进程不同了，一个进程内部可以创建多个线程，如图所示： </p><p><img src="https://img2020.cnblogs.com/blog/1762180/202006/1762180-20200612110341829-872565108.png" alt=""></p><h3 id="1-2-理解线程"><a href="#1-2-理解线程" class="headerlink" title="1.2 理解线程"></a>1.2 理解线程</h3><p>从创建线程的图示可以看出：线程可以视为某个进程内部的控制流。</p><blockquote><p>线程：操作系统基于进程开启的轻量级进程，<br>线程是操作系统最小的调度执行单位（即cpu分配时间轮片的对象）</p></blockquote><p>线程不能独立于进程而存在，其生命周期不可能逾越其所属的进程生命周期，与进程不同，线程不存在父子级别关系，同一进程中的任意2个线程之间的关系是平等的。<br>一个进程内部的线程包括：</p><ul><li>主线程：必定拥有，因为进程必须有一个控制流持续运行，该线程随着进程的启动而创建</li><li>其他线程：不一定拥有，由主线程或者其他线程创建（C语言调用pthread_create函数）  </li></ul><p>综上我们可以得出：</p><blockquote><p>线程与进程一样拥有独立的PCB，但是没有独立的地址空间，即线程之间共享了地址空间。这样也让线程之间无需IPC，直接就能通信！！</p></blockquote><p>进程的大多数资源会被其内部的线程所共享，如：代码段、数据段、堆、信号处理函数、当前进程持有的文件描述符等。所以，同一进程中的多个线程运行的一定是同一个程序，只不过具体的控制流和执行的函数可能不同。也正因如此，同一进程内的多线程共享数据变得很轻松，创建新线程也无需再复制资源了。</p><p>虽然线程带来了通信的便利，如果同一空间的中多个线程同时去使用同一个数据，就会造成资源竞争问题，这是计算机编程中最复杂的问题之一。  </p><h3 id="1-3-线程标识"><a href="#1-3-线程标识" class="headerlink" title="1.3 线程标识"></a>1.3 线程标识</h3><p>每个线程也有属于自己的ID，称为TID，只在其所属的进程范围内唯一。  </p><p>注意：Linux中的线程ID在系统范围内也是唯一的，且线程不存在后，该ID可被其他线程复用。  </p><h3 id="1-4-线程调度"><a href="#1-4-线程调度" class="headerlink" title="1.4 线程调度"></a>1.4 线程调度</h3><p>线程之间不存在类似进程的树形关系，任何线程都可以对同一进程的其他线程进行有限的管理。</p><p>调度器会把事件划分为极小的时间片，并把这些时间片分配给不同的线程，以使众多线程都有机会在CPU上运行，也造成了我们多线程被并行运行的幻觉。</p><h3 id="1-5-线程的应用"><a href="#1-5-线程的应用" class="headerlink" title="1.5 线程的应用"></a>1.5 线程的应用</h3><p>对于多线程并发模型的web服务器，如果需要同时处理多个请求，当请求到达时，web 服务器会创建一个线程，或者从线程池中获取一个线程，然后将请求来委派给线程来实现并发。</p><h2 id="二-线程同步"><a href="#二-线程同步" class="headerlink" title="二 线程同步"></a>二 线程同步</h2><h3 id="2-0-同步的概念"><a href="#2-0-同步的概念" class="headerlink" title="2.0 同步的概念"></a>2.0 同步的概念</h3><p>由于多进程、多线程、协程等都可以抢占共享资源，我们就必须保证他们访问时数据的一致性，这种保持数据内容一致的机制称为<strong>同步</strong>。    </p><p>多个控制流操作一个共享资源的情况，都需要同步！！  </p><p>一般情况下，只要让共享区域的操作串行化，就可以实现同步，这种实现了串行化的共享区域称为<strong>临界区</strong>。  </p><p>这里主要研究线程同步的方式，包括：</p><ul><li>互斥量</li><li>条件变量</li><li>原子操作</li></ul><h3 id="2-1-互斥量"><a href="#2-1-互斥量" class="headerlink" title="2.1 互斥量"></a>2.1 互斥量</h3><blockquote><p>互斥（mutex）：在同一时刻，只允许一个线程处于临界区内。  </p></blockquote><p>线程将对象锁定后，才能进入临界区，否则线程就会阻塞，这个对象我们称之为互斥对象或者互斥量。  </p><p>由此可知，互斥量有已锁定、未锁定两种状态，且一旦被锁，则不能再次锁定，只有解锁后才能再次锁定（即不允许别的线程二次加锁）。多个线程为了能够访问临界区，将会争夺锁的所有权。  </p><p>线程在离开临界区的时候，必须对互斥量进行解锁，此时其他想进入该临界区的线程将会被唤醒再次争夺锁。  </p><p>如果不同的临界区中包含了对同一个共享资源的同一种操作，此时会产生死锁。  </p><p>解决死锁的办法有两种：</p><ul><li>试锁定-回退：操作系统的线程库中提供了该功能。在执行一个代码块时，如果需要先后锁定多个互斥量，成功锁定其中一个互斥量后应该使用试锁定的方法来锁定后续互斥量，如果后续任一互斥量锁定失败，则解锁刚才被锁的互斥量，重新进行争夺锁尝试。<ul><li>注意：多个互斥量被成功加锁后，解锁顺序和加锁顺序相反，这样可以减少回退次数。</li></ul></li><li>固定顺序锁定：举例，线程A和线程B总是先锁定互斥量1，再锁定互斥量2，那么就不会产生死锁。</li></ul><p>第一种方案更加有效，但是程序变得复杂了，后一种方法简单实用，但是因为存在固定顺序，降低了程序的灵活性。</p><h3 id="2-2-条件变量"><a href="#2-2-条件变量" class="headerlink" title="2.2 条件变量"></a>2.2 条件变量</h3><p>互斥量有时候也不能完美解决问题，比如最常见的生产消费模型中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据队列：具备一定大小的空间，用于存储生产的数据</span><br><span class="line">生产者线程：向数据队列不断的添加数据</span><br><span class="line">消费者线程：向数据队列不断的取出数据</span><br></pre></td></tr></table></figure><p>由于生产者线程和消费者线程都会对数据队列进行并发访问，那么我们肯定会为数据队列进行加锁操作，以实现同步。  </p><p>此时如果生产者线程获得互斥量，发现数据队列已满，无法添加新数据，生产者线程就可能在临界区一直等待，直到有空闲区间。这种做法明显是错误的，因为该线程一直阻塞在临界区，直接影响了其他消费者线程的使用！生产者线程应该在发现没有空闲区间时直接解锁退出。  </p><p>同样的，消费者线程在获取锁后，如果发现数据队列为空，则也会一直等待，这都是不合理的，应该发现为空后直接解锁。  </p><p>引入条件变量，与互斥量配合使用，可以解决上述问题。  </p><blockquote><p>条件变量：条件变量一般与互斥量组合使用，在对应的共享数据状态发生变化时，通知其他被阻塞线程。    </p></blockquote><p>条件变量有三种操作：</p><ul><li>等待通知（wait）：如果当前数据状态不满足条件，则解锁与该条件变量绑定在一起的互斥量，然后阻塞当前线程，直到收到该条件变量发来的通知</li><li>单发通知（signal）：让条件变量向至少一个正在等待它通知的线程发送通知，以表示共享数据状态发生了改变 </li><li>广播通知（broadcast）：给等待通知的所有线程发送通知</li></ul><h3 id="2-3-原子操作"><a href="#2-3-原子操作" class="headerlink" title="2.3 原子操作"></a>2.3 原子操作</h3><p>原子操作的执行过程不能被中断，因为此时CPU不会去执行其他对该值进行的操作，这也能有效的解决一部分竞争问题。  </p><p><img src="https://img2020.cnblogs.com/blog/1762180/202006/1762180-20200612111216567-1625246241.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程-概述</title>
      <link href="/2020/06/17/%E5%B9%B6%E5%8F%91%E7%AE%80%E7%95%A5-%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/06/17/%E5%B9%B6%E5%8F%91%E7%AE%80%E7%95%A5-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一-并发编程历史"><a href="#一-并发编程历史" class="headerlink" title="一 并发编程历史"></a>一 并发编程历史</h2><p>在早期的操作系统中，各个任务的执行完全是串行的，只有在一个任务运行完成之后，另一个任务才会被执行，我们称之为<code>单道程序</code>。  </p><p>而现代操作系统引入了<code>多道程序</code>的并发概念：</p><blockquote><p>多道程序：当一个程序暂时不需要使用CPU的时候，系统会把该程序挂起或中断，此时其他程序可以使用CPU，多个任务在操作系统的控制中实现了宏观上的并发。<br>多道程序提升了计算机资源的利用率，但是也引起了多个任务对系统资源的抢夺，在开发上极为不便。  </p></blockquote><h2 id="二-计算机术语"><a href="#二-计算机术语" class="headerlink" title="二 计算机术语"></a>二 计算机术语</h2><h3 id="2-1-串行与并发"><a href="#2-1-串行与并发" class="headerlink" title="2.1 串行与并发"></a>2.1 串行与并发</h3><p>串行与并发是同一个维度的概念，区别是：</p><ul><li>串行：指令按照顺序执行</li><li>并发：指令并未按照顺序执行，而是在宏观上同时执行，即CPU不停的在各个任务之间来回切换，给人感觉所有任务同时执行了！比如电脑同时运行了QQ、浏览器，其实是CPU在这2个程序之间按照一定的调度算法在来回切换执行！</li></ul><p>并行与并发并不是同一个维度上的概念：</p><ul><li>并行（parallel）：在同一时刻（微秒级），多条指令在多个处理器上同时执行，并行一般要借助多核CPU实现！</li><li>并发（concurrency）：并未同时执行，只是由于CPU运行过快，给人产生同时运行的假象</li></ul><p>并发与并行概念的区别是是否同时执行，比如吃饭时，电话来了，需要停止吃饭去接电话，接完电话继续吃饭，这是并发执行，但是吃饭时电话来了，边吃边接是并行。  </p><h3 id="2-2-进程"><a href="#2-2-进程" class="headerlink" title="2.2 进程"></a>2.2 进程</h3><blockquote><p>进程：就是二进制可执行文件在计算机内存中的运行实例，可以简单理解为：一个.exe文件是个类，进程就是该类new出来的实例。<br>进程是操作系统资源分配的最小单位（如虚拟内存资源），所有代码都是在进程中执行的。 </p></blockquote><p>在Unix系统中，操作系统启动后将会运行进程号（PID）为1的一个进程 init 进程，该进程是所有其他进程的父进程。操作系统通过 fork() 函数能够创建多个子进程，从而能够提升计算机资源的利用率。  </p><p>进程在创建后会拥有自己的独立地址空间，操作系统会提供一个数据结构PCB来描述该进程（Process Control Block，进程控制块），PCB中保存了进程的管理、控制信息等数据。  </p><p>由于进程拥有互相独立的地址空间，所以进程之间无法直接通信，必须利用进程间通信(IPC,InterProcess Communication)方式来实现通信。  </p><h3 id="2-3-内核态与用户态"><a href="#2-3-内核态与用户态" class="headerlink" title="2.3 内核态与用户态"></a>2.3 内核态与用户态</h3><p>操作系统的内存会被划分为两大区域：</p><ul><li>内核区：提供了大量的系统调用函数，即最原生、最底层的操作函数，如 open()，write() </li><li>用户区：加载、运行应用程序的区域，比如使用C语言写的程序，同样的C语言也提供了本语言的对应操作函数 fopen()，fwrite()。这些由编程语言提供的函数称之为库函数。</li></ul><p>我们不难发现，库函数其实是在系统调用函数基础上再次进行了封装，方便开发者使用。当然开发者既可以使用库函数来操作文件，也可以直接使用底层的系统调用函数（但是这样需要做很多错误处理）。  </p><p>程序在运行时，CPU有两种状态：</p><ul><li>用户态：当一个进程在执行用户自己的代码时处于用户运行态（用户态）</li><li>内核态：当进程需要执行一些系统调用时，比如利用C的库函数fopen()时，fopen()虽然是库函数，但是执行时底层调用了系统的open()函数，此时程序进入内核态，调用结束后，程序会重新回到用户态！</li></ul><p>操作系统之所以要这样设计是出于内存的安全考虑，内核地址只有内核自己的函数（系统调用函数）才能使用！  </p><h3 id="2-4-线程"><a href="#2-4-线程" class="headerlink" title="2.4 线程"></a>2.4 线程</h3><blockquote><p>线程：操作系统基于进程开启的轻量级进程，是操作系统调度执行的最小单位（即cpu分配时间轮片的对象）</p></blockquote><p>一个进程内部可以创建多个线程，他们与进程一样拥有独立的PCB，但是没有独立的地址空间，即线程之间共享了地址空间。这样也让线程之间无需IPC，直接就能通信！！（因为他们在同一个地址空间内）。  </p><p>虽然线程带来了通信的便利，但是如果同一空间的中多个线程同时去修改同一个数据，就会造成资源竞争问题，这是计算机编程中最复杂的问题！  </p><h3 id="2-5-协程"><a href="#2-5-协程" class="headerlink" title="2.5 协程"></a>2.5 协程</h3><p>进程和线程都是操作系统级别的，协程与他们并不是一个维度的概念，所以类似《现代操作系统》的书籍并未提出协程的概念。  </p><p>贴士：千万不要将协程理解为轻量级线程！</p><blockquote><p>协程：程序在执行时，函数内部可以中断，适当时候返回接着执行，即协程运行在用户态 </p></blockquote><p>协程的优势在于其轻量级、执行效率高：</p><ul><li>轻量级：没有线程开销，可以轻松创建上百万个协程而不会造成系统资源衰竭</li><li>执行效率高：函数之间的切换不再是线程切换，由程序自身控制</li></ul><p>线程需要上下文不停切换，而协程不会主动交出使用权，除非代码中主动要求切换，或者发生I/O，此时会切换到别的协程，这样能更好的解决并发问题。  </p><h2 id="三-并发理论基础"><a href="#三-并发理论基础" class="headerlink" title="三 并发理论基础"></a>三 并发理论基础</h2><h3 id="3-1-并发解决方案"><a href="#3-1-并发解决方案" class="headerlink" title="3.1 并发解决方案"></a>3.1 并发解决方案</h3><ul><li>多进程:由系统内核管理并发，操作简单、进程互不影响。但是开销最大，占用资源较多，能开启的进程数极少，</li><li>多线程:多线程在大部分系统上仍然属于系统层面的并发，开销较大，且会存在死锁管理问题。</li><li>非阻塞I/O:基于回调的异步非阻塞I/O，尽可能少的运用线程</li><li>协程:本质上仍然是用户态线程，但不需要系统进行抢占式调度，且真正的实现寄存于线程中，开销极小。</li></ul><h3 id="3-2-并发程序数据交互方式一：同步"><a href="#3-2-并发程序数据交互方式一：同步" class="headerlink" title="3.2 并发程序数据交互方式一：同步"></a>3.2 并发程序数据交互方式一：同步</h3><blockquote><p>线程同步：线程在发出某一个功能调用时，如果没有得到结果，则该调用不返回。此时其他线程不能调用该功能（因为要保证数据一致性）。  </p></blockquote><p>线程同步是为了避免引起数据混乱。实际上，多个控制流共同操作一个共享资源，都需要同步，比如：进程、线程、信号之间都需要同步机制，常见的线程同步技术就是互斥锁。 </p><p>同步的作用是避免在并发访问共享资源时可能发生的冲突。  </p><p>同步的理念：</p><ul><li>程序如果想使用一个共享数据，就必须先获取对它的使用权，当程序不再使用该资源时，则应放弃对该资源的访问权(即：释放资源)。</li><li>资源的使用权被拿走后，其他访问该资源的程序不应该被中断，而是应该等到拥有使用权的程序释放资源之后再进行访问。<br>即：在同一时刻，某个资源应该只被一个程序占用。  </li></ul><h3 id="3-3-并发程序数据交互方式二：数据传递"><a href="#3-3-并发程序数据交互方式二：数据传递" class="headerlink" title="3.3 并发程序数据交互方式二：数据传递"></a>3.3 并发程序数据交互方式二：数据传递</h3><p>除了使用同步方式来实现并发程序数据的交互之外，还可以使用数据传递方式（也称为通信）。  </p><p>该方式可以使数据不加延迟的发送给数据接收方。即使数据接收方还没有为接收数据做好准备，也不会造成数据发送方的等待。数据会被临时存储在一个称谓通信缓存的数据结构中。通信缓存是一种特殊的数据结构，可以同时被多个程序使用，数据接收方可以在准备就绪之后按照数据存入通信缓存的顺序接收它们。  </p><h2 id="四-各个语言的并发理念"><a href="#四-各个语言的并发理念" class="headerlink" title="四 各个语言的并发理念"></a>四 各个语言的并发理念</h2><ul><li>Java：典型的多线程并发模式，利用同步机制（加锁）来实现并发访问控制</li><li>Node.js：典型的单线程非阻塞I/O实践者，不存在Java的资源竞争问题，I/O操作处理完毕后才会利用事件机制通知业务线程返回结果，没有资源竞争的难题。</li><li>Go：典型的协程并发理念实践者，在语言本身层面实现了协程，协程之间通过<strong>管道</strong>进行<strong>数据传递</strong></li></ul><p>目前流行的并发理念是：异步非阻塞I/O，协程。</p>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程-多进程</title>
      <link href="/2020/06/17/%E5%B9%B6%E5%8F%91%E7%AE%80%E7%95%A5-%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
      <url>/2020/06/17/%E5%B9%B6%E5%8F%91%E7%AE%80%E7%95%A5-%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一-进程概念"><a href="#一-进程概念" class="headerlink" title="一  进程概念"></a>一  进程概念</h2><blockquote><p>进程：就是二进制可执行文件在计算机内存中的运行实例，可以简单理解为：一个.exe文件是个类，进程就是该类new出来的实例。<br>进程是操作系统最小的资源分配单位（如虚拟内存资源），所有代码都是在进程中执行的。 </p></blockquote><p>为了方便管理进程，每个进程都有自己的描述符，是个复杂的数据结构，我们称之为<strong>进程控制块</strong>，即PCB(Process Control Block)。  </p><p>PCB中保存了进程的管理、控制信息等数据，主要包含字段有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">进程ID（PID）：进程的唯一标识符 ，是一个非负整数的顺序编号</span><br><span class="line">父进程ID（PPID）：当前进程的父进程ID</span><br><span class="line">文件描述符表：即很多指向file接否提的指针</span><br><span class="line">进程状态：就绪、运行、挂起、停止等状态</span><br><span class="line">虚拟地址范围</span><br><span class="line">访问权限 </span><br><span class="line">当前工作目录</span><br><span class="line">用户id和组id</span><br><span class="line">会话和进程组</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">贴士：进程ID是可以重用的，当进程ID达到最大限额值时，内核会从头开始查找闲置的进程ID并使用最先找到的那一个作为新进程的ID</span><br><span class="line"></span><br><span class="line">## 二 进程创建</span><br><span class="line"></span><br><span class="line">Unix系统在启动后，会首先运行一个名为 init 的进程，其PID 为 1。该进程是所有其他进程的父进程。  </span><br><span class="line"></span><br><span class="line">Unix操作系统通过 &#96;fork()&#96; 函数能够创建多个子进程，从而能够提升计算机资源的利用率。此时调用者称为父进程，被创造出来的进程称为子进程。  </span><br><span class="line">- 每个子进程都是源自它的父进程的一个副本，它会获得父进程的数据段、堆、栈的拷贝，并与父进程共享代码段。  </span><br><span class="line">- 子进程对自己副本的修改对其父进程和兄弟进程都是不可见的，反之亦然。  </span><br><span class="line"></span><br><span class="line">创建的子进程可以直接开始运行，但是也可以通过 &#96;exec()&#96; 函数来加载一个全新的程序，此时子进程会丢弃现存的程序文本段，为加载的新程序重新创建栈、数据段、堆，我们对这一个过程称为执行一个新程序。  </span><br><span class="line"></span><br><span class="line">贴士：exec并不是1个函数, 是一系列 exec 开头的函数，作用都是执行新程序。 </span><br><span class="line"></span><br><span class="line">C语言示例如下：</span><br><span class="line">&#96;&#96;&#96;c</span><br><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    pid_t pid;</span><br><span class="line">    int r;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建子进程</span><br><span class="line">    pid &#x3D; fork();                     </span><br><span class="line">    if (pid &#x3D;&#x3D; -1)&#123;                   &#x2F;&#x2F; 发生错误</span><br><span class="line">        perror(&quot;fork发生错误 &quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 返回值大于0时是父进程</span><br><span class="line">    if(pid &gt; 0)&#123;                        </span><br><span class="line">        printf(&quot;父进程: pid &#x3D; %d, ppid &#x3D; %d \n&quot;, getpid(),getppid());        &#x2F;&#x2F; 父进程执行动作</span><br><span class="line">        sleep(3);                       &#x2F;&#x2F; 父进程睡眠，防止子进程还没运行完毕，父进程却直接退出了</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 返回值为0的是子进程</span><br><span class="line">    if(pid &#x3D;&#x3D; 0)&#123;   </span><br><span class="line"></span><br><span class="line">        printf(&quot;子进程: pid &#x3D; %d , ppid &#x3D; %d \n&quot;, getpid(),getppid());     &#x2F;&#x2F; 子进程执行动作</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 子进程加载一个新程序：系统自带的 echo程序，输出 hello world!</span><br><span class="line">        char * execv_str[] &#x3D; &#123;&quot;echo&quot;, &quot;hello world!&quot;,NULL&#125;;</span><br><span class="line">        int r &#x3D; execv(&quot;&#x2F;bin&#x2F;echo&quot;, execv_str);    &#x2F;&#x2F; 笔者的是mac，linux上为： &quot;&#x2F;usr&#x2F;bin&#x2F;echo&quot;  </span><br><span class="line">if (r &lt;0 )&#123;</span><br><span class="line">perror(&quot;error on exec&quot;);</span><br><span class="line">exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Go 语言中，没有直接提供 fork 系统调用的封装，而是将 fork 和 execve 合二为一，具体信息可以参见Go的os包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"当前进程ID："</span>, os.Getpid())</span><br><span class="line"></span><br><span class="line">procAttr := &amp;os.ProcAttr&#123;</span><br><span class="line">Files: []*os.File&#123;os.Stdin, os.Stdout, os.Stderr&#125;,</span><br><span class="line">&#125;</span><br><span class="line">process, err := os.StartProcess(<span class="string">"/bin/echo"</span>, []<span class="keyword">string</span>&#123;<span class="string">""</span>, <span class="string">"hello,world!"</span>&#125;, procAttr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"进程启动失败:"</span>, err)</span><br><span class="line">os.Exit(<span class="number">2</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"子进程ID："</span>, process.Pid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据该方式，就可以很容运行计算机上的其他任何程序，包括自身的命令行、Java程序等等。 </p><h2 id="四-进程分类"><a href="#四-进程分类" class="headerlink" title="四 进程分类"></a>四 进程分类</h2><p>进程分类：</p><ul><li>用户进程：位于用户空间中，是程序执行的实例</li><li>内核进程：位于内核空间中，可以访问硬件</li></ul><p>由于用户进程无法访问内核空间，所以无法直接操作硬件。内核会暴露一些接口提供给用户进程使用，让用户进程简介操作硬件，这便是系统调用。  </p><p>内核为了保证系统的安全和稳定，为<strong>CPU</strong>特供了两个状态：</p><ul><li>用户态：大部分时间CPU处于该状态，此时只能访问用户空间</li><li>内核态：当用户进程发起系统调用时，内核会将CPU切换到内核态，然后执行相应接口函数。</li></ul><p>注意：这里的用户态和内核态是针对CPU的。</p><h2 id="五-进程调度"><a href="#五-进程调度" class="headerlink" title="五 进程调度"></a>五 进程调度</h2><p>同一时刻只能运行一个进程，但是CPU可以在多个进程间进行来回切换，我们称之为上下文切换。  </p><p>操作系统会按照调度算法为每个进程分配一定的CPU运行时间，称之为时间轮片，每个进程在运行时都会认为自己独占了CPU，如图所示：  </p><p><img src="https://img2020.cnblogs.com/blog/1762180/202006/1762180-20200617144935021-2033838115.png" alt=""></p><p>切换进程是有代价的，因为必须保存进程的运行时状态。</p><h2 id="六-进程状态转换"><a href="#六-进程状态转换" class="headerlink" title="六 进程状态转换"></a>六 进程状态转换</h2><p>进程在创建后，在执行过程中，其状态一直在变化。不同时代的操作系统有不同的进程模型：</p><ul><li>三态模型：运行态、就绪态、等待态</li><li>五态模型：初始态、就绪态、运行态、挂起态（阻塞）、终止态</li></ul><p>本笔记介绍五态模型。初始态是进程的准备节点，常与就绪状态结合来看，进程的状态转换图：<br><img src="https://img2020.cnblogs.com/blog/1762180/202006/1762180-20200617144955209-1819843388.png" alt=""></p><h2 id="七-进程运行的问题"><a href="#七-进程运行的问题" class="headerlink" title="七 进程运行的问题"></a>七 进程运行的问题</h2><h3 id="7-1-写时复制"><a href="#7-1-写时复制" class="headerlink" title="7.1 写时复制"></a>7.1 写时复制</h3><p>父进程无法预测子进程什么时候结束，只有进程完成工作后，父进程才会调用子进程的终止态。  </p><p>贴士：全盘复制父进程的数据相当低效，Linux使用写时复制（COW：Copy on Write）技术来提高进程的创建效率。  </p><h3 id="7-2-进程回收"><a href="#7-2-进程回收" class="headerlink" title="7.2 进程回收"></a>7.2 进程回收</h3><p>当一个进程退出之后，进程能够回收自己的用户区的资源，但是不能回收内核空间的PCB资源，必须由它的父进程调用wait或者waitpid函数完成对子进程的回收，避免造成系统资源的浪费。  </p><blockquote><p>孤儿进程：父进程先于子进程结束，则子进程成为孤儿进程，此时该进程会被系统的 init 进程领养 </p></blockquote><blockquote><p>僵尸进程：子进程终止，但父进程未回收，子进程残留资源（PCB）于内核中，变成僵尸进程。  </p></blockquote><p>注意：由于僵尸进程是一个已经死亡的进程，所以不能使用kill命令将其杀死，通过杀死其父进程的方法可以消除僵尸进程，杀死其父进程后，这个僵尸进程会被init进程领养，由init进程完成对僵尸进程的回收。</p><h2 id="八-进程间通信"><a href="#八-进程间通信" class="headerlink" title="八 进程间通信"></a>八 进程间通信</h2><h3 id="8-0-进程间通信方式概述"><a href="#8-0-进程间通信方式概述" class="headerlink" title="8.0 进程间通信方式概述"></a>8.0 进程间通信方式概述</h3><p>Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。   </p><p><img src="https://img2020.cnblogs.com/blog/1762180/202005/1762180-20200528202605009-1009624433.png" alt="">  </p><p>在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有：</p><ul><li>管道 (使用最简单)</li><li>共享映射区 (无血缘关系进程通信)</li><li>信号 (开销最小)</li><li>本地套接字 (最稳定)</li></ul><p>Go支持的IPC方法有：管道、信号、socket。  </p><h3 id="8-1-管道"><a href="#8-1-管道" class="headerlink" title="8.1 管道"></a>8.1 管道</h3><p>管道是一种最基本的IPC机制，也称匿名管道，应用于有血缘关系的进程之间，完成数据传递。调用C的pipe函数即可创建一个管道。  </p><p><img src="https://img2020.cnblogs.com/blog/1762180/202005/1762180-20200528202623807-2077795974.png" alt="">  </p><p>管道有如下特质：</p><ul><li>管道的本质是一块内核缓冲区 </li><li>由两个文件描述符引用，一个表示读端，一个表示写端。</li><li>规定数据从管道的写端流入管道，从读端流出。</li><li>当两个进程都终结的时候，管道也自动消失。</li><li>管道的读端和写端默认都是阻塞的。</li></ul><p>管道的实质是内核缓冲区，内部使用唤醒队列实现。  </p><p>管道的缺陷：</p><ul><li>管道中的数据一旦被读走，便不在管道中存在，不可反复读取。</li><li>数据只能在一个方向上流动，若要实现双向流动，必须使用两个管道</li><li>只能在有血缘关系的进程间使用管道。</li></ul><p>Go模拟管道的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cmd1 := exec.Command(<span class="string">"ps"</span>, <span class="string">"aux"</span>)</span><br><span class="line">cmd2 := exec.Command(<span class="string">"grep"</span>, <span class="string">"apipe"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> outputBuf1 bytes.Buffer</span><br><span class="line">cmd1.Stdout = &amp;outputBuf1</span><br><span class="line">cmd1.Start()</span><br><span class="line">cmd1.Wait()<span class="comment">// 开始阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> outputBuf2 bytes.Buffer</span><br><span class="line">cmd2.Stdout = &amp;outputBuf2</span><br><span class="line">cmd2.Start()</span><br><span class="line">cmd2.Wait()<span class="comment">// 开始阻塞</span></span><br><span class="line"></span><br><span class="line">fmt.Println(outputBuf2.Bytes())</span><br></pre></td></tr></table></figure><p>当然也有一种管道称为命名管道（FIFO），它支持无血缘关系的进程之间通信。FIFO是Linux基础文件类型中的一种（文件类型为p，可通过ls -l查看文件类型）。但FIFO文件在磁盘上没有数据块，文件大小为0，仅仅用来标识内核中一条通道。进程可以打开这个文件进行read/write，实际上是在读写内核缓冲区，这样就实现了进程间通信，如图所示：  </p><p><img src="https://img2020.cnblogs.com/blog/1762180/202005/1762180-20200528202638792-630623438.png" alt="">  </p><h3 id="8-2-内存映射区"><a href="#8-2-内存映射区" class="headerlink" title="8.2 内存映射区"></a>8.2 内存映射区</h3><p>存储映射I/O (Memory-mapped I/O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。从缓冲区中取数据，就相当于读文件中的相应字节；将数据写入缓冲区，则会将数据写入文件。这样，就可在不使用read和write函数的情况下，使用地址（指针）完成I/O操作。  </p><p>使用存储映射这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现。  </p><p><img src="https://img2020.cnblogs.com/blog/1762180/202005/1762180-20200528202652898-1438911582.png" alt="">  </p><h3 id="8-3-信号"><a href="#8-3-信号" class="headerlink" title="8.3 信号"></a>8.3 信号</h3><p>信号是IPC中唯一一种异步的通信方法，本质是用软件模拟硬件的中断机制，例如：在命令行终端按下某些快捷键，就会挂起或停止正在运行的程序。Go中的ginal包提供了相关操作。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sigRecv := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)                      <span class="comment">// 创建接收通道</span></span><br><span class="line">sigs := []os.Signal&#123;syscall.SIGINT, syscall.SIGQUIT&#125;    <span class="comment">// 创建信号类型</span></span><br><span class="line">signal.Notify(sigRecv, sigs...)</span><br><span class="line"><span class="keyword">for</span> sig := <span class="keyword">range</span> sigRecv &#123;                              <span class="comment">// 循环接收通道中的信号，通道关闭后，for会立即停止</span></span><br><span class="line">fmt.Println(sig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-socket"><a href="#8-4-socket" class="headerlink" title="8.4 socket"></a>8.4 socket</h3><p>socket即套接字，也是一种IPC方法，与其他IPC方法不同之处在于：可以通过网络连接让多个进程建立通信并相互传递数据，这使得通信不再依赖于在同一台计算机上。</p><h2 id="九-进程同步"><a href="#九-进程同步" class="headerlink" title="九 进程同步"></a>九 进程同步</h2><p>当多个子进程对同一资源进行访问时，就会产生竞态条件。比如：某一个数据，进程A对其进行执行<code>一系列</code>操作，但是在执行过程中，系统有可能会切换到另外一个进程B中，B也对该数据进行<code>一系列</code>操作，那么在两个进程中操作同一份数据时，这个数据的结果值到底按照谁的来运算呢？    </p><p>原子操作：如果执行过程中操作不能中断，那么就能解决上述问题，这样的操作称为原子操作（atomic operation）。这些只能被串行化访问或执行的资源或者某段代码被称为临界区（critical section）。Go中(sync/atomic包提供了原子操作函数)。  </p><p>注意：</p><ul><li>所有的系统调用都是原子操作，即不用担心它们的执行被中断！</li><li>原子操作不能被中断，临界区是否可以被中断没有强制规定，只是保证了只能同时被一个访问者访问。 </li></ul><p>问题：如果一个原子操作无法结束，现在也无法中断，如何处理？  </p><blockquote><p>答案：内核只提供了针对二进制位和整数的原子操作（即保证细粒度），不会有上述现象。  </p></blockquote><p>互斥锁：<br>在实际开发中，原子操作并不通用，我们可以保证只有一个进程/线程在临界区，该做法称为互斥锁（exclusion principle），比如信号量是实现互斥方法的方式之一，Golang的sync包也有对互斥的支持。  </p>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用规范</title>
      <link href="/2020/06/16/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84git%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
      <url>/2020/06/16/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84git%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>祖师爷 Linus 在创造了伟大的 Linux 之后，又创造了应用最广泛的代码管理工具 —— Git，极大地提高了程序员的生产力。 现如今大部分项目都在使用 Git 作为代码管理工具，不论是在代码管理、版本控制以及团队协作上，Git 相比其他版本控制软件都有着无可比拟的优势。</p><p>虽然 Git 是个优秀的工具，但是在项目中是否能够正确合理地使用，是否能够发挥其最大的优势，就我自己这几年的工作经历来看，对于大部分团队这个问题的答案是否定的。</p><p>大部分程序员对 Git 的使用基本上都停留在 git add、git commit、git push、git pull 这几个指令上，而且大部分团队也没有 Git 规范，提交信息充斥着大量的 “fix”、“update”，分支管理也很混乱，代码提交哪个分支上也没具体的规定，导致在团队协作过程中经常出现代码合并后谁的代码不见了，修过的 bug 在新版本又出现了……<br>0. 我们可能面临的问题</p><p>试想遇到以下这些问题，你会采取怎样的方式去解决：</p><pre><code>* 需要线上某个历史版本的源码，直接在 develop 分支根据提交记录和时间找对应的节点？* 线上版本出现严重 bug 需要紧急修复发版本，而你的项目就一个分支，上个版本发布之后已经有大量改动了，怎么办？* 某个提交改动了部分代码，涉及到 10 几个文件，现在这个改动不需要了，此时要一个个找出这些文件然后再改回去么？* 出现了一个 bug，之前好像处理过，但是现在忘了当初怎么处理的了，在一堆写着 “fix bug”、“update” 的提交记录中，如何找到当初那笔的提交？* 某个功能本来准备发布的，现在突然决定这个版本不上了，现在要一处处找到之前的代码，然后再改回去？* ……</code></pre><p>以上这些问题在我们的项目中都是会或多或少出现的，部分问题可能涉及到的是对 Git 的功能是否熟悉的问题，大部分问题则是涉及到一个项目的 Git 使用规范问题，如果有一个很好的规范，在项目中合理地使用 Git，很多问题压根就不是问题。</p><ol><li>Git 规范的必要性</li></ol><p>既然认同需要一份 Git 规范，那么这个规范需要规范哪些内容，解决哪些问题，又带来哪些好处呢？个人认为有以下几点：</p><ol><li><p>分支管理</p><p> 代码提交在应该提交的分支<br> 随时可以切换到线上稳定版本代码<br> 多个版本的开发工作同时进行</p></li><li><p>提交记录的可读性</p><p> 准确的提交描述，具备可检索性<br> 合理的提交范围，避免一个功能就一笔提交<br> 分支间的合并保有提交历史，且合并后结果清晰明了<br> 避免出现过多的分叉</p></li><li><p>团队协作</p><p> 明确每个分支的功用，做到对应的分支执行对应的操作<br> 合理的提交，每次提交有明确的改动范围和规范的提交信息<br> 使用 Git 管理版本迭代、紧急线上 bug fix、功能开发等任务</p></li></ol><p>以上就是一份 Git 规范的作用和使命。</p><p>接下来结合 Git-Flow 和个人实际的项目经验，总结了一份项目中使用 Git 的规范，其中大部分内容都是对 Git-Flow 进行一个解读和扩展，告诉大家为什么这么做以及怎么做。 这里也推荐一下 Git-Flow 相关的内容：</p><pre><code>A successful Git branching model » nvie.com</code></pre><p>这是一份 2010 年提出来的分支管理规范，距今已过去 8 年了，但是其工作流程至今还是适用的，也衍生出很多优秀的开发流程。</p><p>以下就是 Git-Flow 的经典流程图：<br><img src="https://jaeger.itscoder.com/img/postimg/git-flow.png" alt=""><br>如果你熟悉 Git-Flow，那么你对上图中的各种分支和线应该都能够理解，如果你之前没了解过相关的知识，那你可能会有点懵，不过在读完本文之后再看这张图，应该就能够理解了。<br>2. 分支管理规范<br>2.1 分支说明和操作</p><pre><code>master 分支    主分支，永远处于稳定状态，对应当前线上版本    以 tag 标记一个版本，因此在 master 分支上看到的每一个 tag 都应该对应一个线上版本    不允许在该分支直接提交代码develop 分支    开发分支，包含了项目最新的功能和代码，所有开发都依赖 develop 分支进行    小的改动可以直接在 develop 分支进行，改动较多时切出新的 feature 分支进行    注： 更好的做法是 develop 分支作为开发的主分支，也不允许直接提交代码。小改动也应该以 feature 分支提 merge request 合并，目的是保证每个改动都经过了强制代码 review，降低代码风险feature 分支    功能分支，开发新功能的分支    开发新的功能或者改动较大的调整，从 develop 分支切换出 feature 分支，分支名称为 feature/xxx    开发完成后合并回 develop 分支并且删除该 feature/xxx 分支release 分支    发布分支，新功能合并到 develop 分支，准备发布新版本时使用的分支    当 develop 分支完成功能合并和部分 bug fix，准备发布新版本时，切出一个 release 分支，来做发布前的准备，分支名约定为release/xxx    发布之前发现的 bug 就直接在这个分支上修复，确定准备发版本就合并到 master 分支，完成发布，同时合并到 develop 分支hotfix 分支    紧急修复线上 bug 分支    当线上版本出现 bug 时，从 master 分支切出一个 hotfix/xxx 分支，完成 bug 修复，然后将 hotfix/xxx 合并到 master 和 develop 分支(如果此时存在 release 分支，则应该合并到 release 分支)，合并完成后删除该 hotfix/xxx 分支</code></pre><p>以上就是在项目中应该出现的分支以及每个分支功能的说明。 其中稳定长期存在的分支只有 master 和 develop 分支，别的分支在完成对应的使命之后都会合并到这两个分支然后被删除。简单总结如下：</p><pre><code>master 分支: 线上稳定版本分支develop 分支: 开发分支，衍生出 feature 分支和 release 分支release 分支: 发布分支，准备待发布版本的分支，存在多个，版本发布之后删除feature 分支: 功能分支，完成特定功能开发的分支，存在多个，功能合并之后删除hotfix 分支: 紧急热修复分支，存在多个，紧急版本发布之后删除</code></pre><p>2.2 分支间操作注意事项</p><p>在团队开发过程中，避免不了和其他人一起协作， 同时也会遇到合并分支等一些操作，这里提交 2 个个人觉得比较好的分支操作规范。</p><pre><code>同一分支 git pull 使用 rebase首先看一张图：</code></pre><p><img src="https://jaeger.itscoder.com/img/postimg/git_pull_no_rebase.jpg" alt=""><br>    看到这样的  提交线图，想从中看出一条清晰的提交线几乎是不可能的，充满了 Merge remote-tracking branch ‘origin/xxx’ into xxx 这样的提交记录，同时也将提交线弄成了交错纵横的图，没有了可读性。</p><pre><code>这里最大的原因就是因为默认的 git pull 使用的是 merge 行为，当你更新代码时，如果本地存在未推送到远程的提交，就会产生一个这样的 merge 提交记录。因此在同一个分支上更新代码时推荐使用 git pull --rebase。下面这张图展示了默认的 git pull 和 git pull --rebase 的结果差异，使用 git pull --rebase 目的是修整提交线图，使其形成一条直线。</code></pre><p><img src="https://jaeger.itscoder.com/img/postimg/git_pull_rebase_diff.jpg" alt=""><br>    默认的 git pull 行为是 merge，可以进行如下设置修改默认的 git pull 行为：</p><pre><code># 为某个分支单独设置，这里是设置 dev 分支git config branch.dev.rebase true# 全局设置，所有的分支 git pull 均使用 --rebasegit config --global pull.rebase truegit config --global branch.autoSetupRebase always这里需要说明一下，在我看来使用 git pull --rebase 操作是比较好的，能够得到一条很清晰的提交直线图，方便查看提交记录和 code review，但是由于 rebase 会改变提交历史，也存在一些不好的影响。这里就不做过多的讨论了，有兴趣的话可以移步知乎上的讨论：在开发过程中使用 git rebase 还是 git merge，优缺点分别是什么？分支合并使用 --no-ff  # 例如当前在 develop 分支，需要合并 feature/xxx 分支  git merge --no-ff feature/xxx在解释这个命令之前，先解释下 Git 中的 fast-forward： 举例来说，开发一直在 develop 分支进行，此时有个新功能需要开发，新建一个 feature/a 分支，并在其上进行一系列开发和提交。当完成功能开发时，此时回到 develop 分支，此时 develop 分支在创建 feature/a 分支之后没有产生任何的 commit，那么此时的合并就叫做 fast-forward。fast-forward 合并的结果如下图所示，这种 merge 的结果就是一条直线了，无法明确看到切出一个新的 feature 分支，并完成了一个新的功能开发，因此此时比较推荐使用 git merge --no-ff，得到的结果就很明确知道，新的一系列提交是完成了一个新的功能，如果需要对这个功能进行 code review，那么只需要检视叉的那条线上的提交即可。</code></pre><p><img src="https://jaeger.itscoder.com/img/postimg/git_merge_diff.svg" alt=""><br>    关于以上两个分支间的操作建议，如果需要了解更多，可以阅读洁癖者用 Git：pull –rebase 和 merge –no-ff 这篇文章。</p><p>2.3 项目分支操作流程示例</p><p>这部分内容结合日常项目的开发流程，涉及到开发新功能、分支合并、发布新版本以及发布紧急修复版本等操作，展示常用的命令和操作。</p><pre><code>切到 develop 分支，更新 develop 最新代码git checkout developgit pull --rebase新建 feature 分支，开发新功能git checkout -b feature/xxx...git add &lt;files&gt;git commit -m &quot;feat(xxx): commit a&quot;git commit -m &quot;feat(xxx): commit b&quot;# 其他提交...如果此时 develop 分支有一笔提交，影响到你的 feature 开发，可以 rebase develop 分支，前提是 该 feature 分支只有你自己一个在开发，如果多人都在该分支，需要进行协调：# 切换到 develop 分支并更新 develop 分支代码git checkout developgit pull --rebase# 切回 feature 分支git checkout feature/xxxgit rebase develop# 如果需要提交到远端，且之前已经提交到远端，此时需要强推(强推需慎重！)git push --force上述场景也可以通过 git cherry-pick 来实现，有兴趣的可以去了解一下这个指令。完成 feature 分支，合并到 develop 分支# 切到 develop 分支，更新下代码git check developgit pull --rebase# 合并 feature 分支git merge feature/xxx --no-ff# 删除 feature 分支git branch -d feature/xxx# 推到远端git push origin develop当某个版本所有的 feature 分支均合并到 develop 分支，就可以切出 release 分支，准备发布新版本，提交测试并进行 bug fix# 当前在 develop 分支git checkout -b release/xxx# 在 release/xxx 分支进行 bug fixgit commit -m &quot;fix(xxx): xxxxx&quot;...所有 bug 修复完成，准备发布新版本# master 分支合并 release 分支并添加 taggit checkout mastergit merge --no-ff release/xxx --no-ff# 添加版本标记，这里可以使用版本发布日期或者具体的版本号git tag 1.0.0# develop 分支合并 release 分支git checkout developgit merge --no-ff release/xxx# 删除 release 分支git branch -d release/xxx至此，一个新版本发布完成。线上出现 bug，需要紧急发布修复版本# 当前在 master 分支git checkout master# 切出 hotfix 分支git checkout -b hotfix/xxx... 进行 bug fix 提交# master 分支合并 hotfix 分支并添加 tag(紧急版本)git checkout mastergit merge --no-ff hotfix/xxx --no-ff# 添加版本标记，这里可以使用版本发布日期或者具体的版本号git tag 1.0.1# develop 分支合并 hotfix 分支(如果此时存在 release 分支的话，应当合并到 release 分支)git checkout developgit merge --no-ff hotfix/xxx# 删除 hotfix 分支git branch -d hotfix/xxx至此，紧急版本发布完成。</code></pre><ol start="3"><li>提交信息规范</li></ol><p>提交信息规范部分参考 Angular.js commit messgae。</p><p>git commit 格式 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br></pre></td></tr></table></figure><p>各个部分的说明如下：</p><pre><code>type 类型，提交的类别    feat: 新功能    fix: 修复 bug    docs: 文档变动    style: 格式调整，对代码实际运行没有改动，例如添加空行、格式化等    refactor: bug 修复和添加新功能之外的代码改动    perf: 提升性能的改动    test: 添加或修正测试代码    chore: 构建过程或辅助工具和库（如文档生成）的更改scope 修改范围主要是这次修改涉及到的部分，简单概括，例如 login、train-ordersubject 修改的描述具体的修改描述信息范例feat(detail): 详情页修改样式fix(login): 登录页面错误处理test(list): 列表页添加测试代码</code></pre><p>这里对提交规范加几点说明：</p><pre><code>1. type + scope 能够控制每笔提交改动的文件尽可能少且集中，避免一次很多文件改动或者多个改动合成一笔。2. subject 对于大部分国内项目而已，如果团队整体英文不是较高水平，比较推荐使用中文，方便阅读和检索。3. 避免重复的提交信息，如果发现上一笔提交没改完整，可以使用 git commit --amend 指令追加改动，尽量避免重复的提交信息。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-面向对象三大特性</title>
      <link href="/2020/06/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-2-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
      <url>/2020/06/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-2-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="一-面向对象三大特性"><a href="#一-面向对象三大特性" class="headerlink" title="一 面向对象三大特性"></a>一 面向对象三大特性</h2><h4 id="1-1-封装"><a href="#1-1-封装" class="headerlink" title="1.1 封装"></a>1.1 封装</h4><p>封装：把抽象出的字段和对字段的操作封装在一起,数据被保护在内部,程序的其它包只有通过被授权的操作(方法),才能对字段进行修改，其作用有：</p><ul><li>隐藏实现细节</li><li>可以对数据进行验证，保证安全合理  </li></ul><p>Golang对面向对象做了极大简化，并不强调封装特性，下列示例进行模拟实现：</p><p>在<code>person</code>包下新建<code>person.go</code>文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> person</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span><span class="comment">//年龄是隐私，不允许其他包访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂函数（类似构造函数）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">person</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">Name: name,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">SetAge</span><span class="params">(age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> age &gt; <span class="number">0</span> &amp;&amp; age &lt; <span class="number">150</span> &#123;<span class="comment">//校验</span></span><br><span class="line">p.age = age</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"年龄不合法"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">GetAge</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> p.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.go</code>文件操作person：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"demo/person"</span><span class="comment">// demo是go mod模式下，整体项目名</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := person.NewPerson(<span class="string">"Tom"</span>)</span><br><span class="line">p.SetAge(<span class="number">18</span>)</span><br><span class="line">fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-继承"><a href="#1-2-继承" class="headerlink" title="1.2 继承"></a>1.2 继承</h4><p>在 Golang 中，如果一个 struct 嵌套了另一个匿名结构体，那么这个结构体可以直接访 问匿名结构体的字段和方法，从而实现了继承特性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Father <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Father)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f.Name + <span class="string">" like running..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Son <span class="keyword">struct</span> &#123;</span><br><span class="line">Father              <span class="comment">//嵌套匿名结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s Son</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.Father.Name = "Tom"</span></span><br><span class="line"><span class="comment">//s.Father.age = 10     //可以访问未导出属性</span></span><br><span class="line"><span class="comment">//s.Father.run()          //可以访问未导出方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上述可以简写为：</span></span><br><span class="line">s.Name = <span class="string">"Tom"</span></span><br><span class="line">s.age = <span class="number">10</span></span><br><span class="line">s.run()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>当结构体和匿名结构体有相同的字段或者方法时，编译器采用就近访问原则访问，如果希望访问匿名结构体的字段和方法，可以通过匿名结构体名来区分。</li><li>结构体嵌入多个匿名结构体，如果两个匿名结构体有相同的字段和方法(同时结构体本身没有同名的字段和方法)，访问时必须明确指定匿名结构体名字，否则编译报错。</li><li>如果一个 struct 嵌套了一个有名结构体，这种模式就是组合，如果是组合关系，那么在访问组合的结构体的字段或方法时，必须带上结构体的名字。  </li></ul><p>关于多重继承：如果一个 struct 嵌套了多个匿名结构体，那么该结构体可以直接访问嵌套的匿名结构体的字段和方法，从而实现多重继承。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Father1 <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Father1)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f.Name + <span class="string">" like running..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Father2 <span class="keyword">struct</span> &#123;</span><br><span class="line">Like <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Son1 <span class="keyword">struct</span> &#123;</span><br><span class="line">Father1</span><br><span class="line">Father2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Son2 <span class="keyword">struct</span> &#123;</span><br><span class="line">*Father1</span><br><span class="line">*Father2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s1 := &amp;Son1 &#123;</span><br><span class="line">Father1&#123;</span><br><span class="line">Name: <span class="string">"Tom"</span>,</span><br><span class="line">age: <span class="number">10</span>,</span><br><span class="line">&#125;,</span><br><span class="line">Father2&#123;</span><br><span class="line">Like: <span class="string">"伏特加"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(s1)</span><br><span class="line"></span><br><span class="line">s2 := &amp;Son2&#123;</span><br><span class="line">&amp;Father1&#123;</span><br><span class="line">Name: <span class="string">"Tom"</span>,</span><br><span class="line">age: <span class="number">10</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&amp;Father2&#123;</span><br><span class="line"> Like: <span class="string">"伏特加"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s2.Father1)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#123;&#123;Tom 10&#125; &#123;伏特加&#125;&#125;</span><br><span class="line">&amp;&#123;Tom 10&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-多态"><a href="#1-3-多态" class="headerlink" title="1.3 多态"></a>1.3 多态</h4><p>多态与接口（interface）有关联，参见接口章节</p>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-面向对象基础</title>
      <link href="/2020/06/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
      <url>/2020/06/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一-面向对象初识"><a href="#一-面向对象初识" class="headerlink" title="一 面向对象初识"></a>一 面向对象初识</h2><h4 id="1-1-模拟构造函数"><a href="#1-1-模拟构造函数" class="headerlink" title="1.1 模拟构造函数"></a>1.1 模拟构造函数</h4><p>Go和传统的面向对象语言如Java有着很大区别。结构体没有构造函数初始化功能，可以通过以下方式模拟：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPersonByName</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">Name: name,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPersonByAge</span><span class="params">(age <span class="keyword">int</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">Age: age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">p := NewPersonByName(<span class="string">"zs"</span>)</span><br><span class="line">fmt.Println(p)<span class="comment">// &#123;zs 0&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贴士：因为Go没有函数重载，为了避免函数名字冲突，使用了<code>NewPersonByName</code>和<code>NewPersonByAge</code>两个不同的函数表示不同的<code>Person</code>构造过程。</p><h4 id="1-2-父子关系结构体初始化"><a href="#1-2-父子关系结构体初始化" class="headerlink" title="1.2 父子关系结构体初始化"></a>1.2 父子关系结构体初始化</h4><p>Person可以看做父类，Student是子类，子类需要继承父类的成员：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Person</span><br><span class="line">ClassName <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造父类</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">Name: name,</span><br><span class="line">Age: age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造子类</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(classname <span class="keyword">string</span>)</span> *<span class="title">Student</span></span> &#123;</span><br><span class="line">p := &amp;Student&#123;&#125;</span><br><span class="line">p.ClassName = classname</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s := NewStudent(<span class="string">"一班"</span>)</span><br><span class="line">fmt.Println(s)<span class="comment">// &amp;&#123;&#123; 0&#125; 一班&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-Go中的面向对象初识"><a href="#1-3-Go中的面向对象初识" class="headerlink" title="1.3 Go中的面向对象初识"></a>1.3 Go中的面向对象初识</h4><p>在Go中，可以给任意类型（除了指针）添加相应方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interger <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Interger)</span> <span class="title">Less</span> <span class="params">(j Interger)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> i &lt; j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i Interger = <span class="number">1</span></span><br><span class="line">fmt.Print(i.Less(<span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-方法"><a href="#二-方法" class="headerlink" title="二 方法"></a>二 方法</h2><h4 id="2-1-方法"><a href="#2-1-方法" class="headerlink" title="2.1 方法"></a>2.1 方法</h4><p>Golang 中的方法是作用在指定的数据类型上的(即:和指定的数据类型绑定)，因此自定义类型，都可以有方法，而不仅仅是 struct。  </p><p>方法的声明和调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recevier <span class="keyword">type</span>)</span> <span class="title">methodName</span><span class="params">(参数列表)</span> <span class="params">(返回值列表)</span></span>&#123; </span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法与函数的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个run函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(p *Person, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">p.Name = name</span><br><span class="line">fmt.Println(<span class="string">"函数 run..."</span>, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个run方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span><span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"方法 run..."</span>, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个对象（结构体）</span></span><br><span class="line">p1 := &amp;Person&#123;</span><br><span class="line"><span class="string">"ruyue"</span>,</span><br><span class="line"><span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行一个普通方法</span></span><br><span class="line">run(p1, <span class="string">"张三"</span>)<span class="comment">// 输出 函数 run... 张三</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行方法</span></span><br><span class="line">p1.run()<span class="comment">// 输出 方法 run... 张三</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-Go方法本质"><a href="#2-2-Go方法本质" class="headerlink" title="2.2 Go方法本质"></a>2.2 Go方法本质</h4><p>Go的方法是一种作用于特定类型变量的函数，这种特定类型的变量叫做接收器（Receiver）。如果特定类型理解为结构体或者“类”时，接收器就类似于其他语言的this或者self。  </p><p>在Go中，接收器可以是任何类型，不仅仅是结构体，依此我们看出，Go中的方法和其他语言的方法类似，但是Go语言的接收器强调方法的作用对象是实例。</p><p>方法与函数的区别就是：函数没有作用对象。</p><p>上述Person案例中，接收器类型是<code>*Person</code>，属于指针类型，非常接近Java中的<code>this</code>，由于指针的特性，调用方法时，修改接收器指针的任意长远变量，在方法结束后，修改都是有效的。  </p><p>当方法作用于非指针接收器时，Go语言会在代码运行时将接收器的值复制一份，在非指针接收器的方法中可以获取接收器的成员值，但修改后无效，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个表示点的结构体</span></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="keyword">int</span></span><br><span class="line">Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非指针接收器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">Add</span><span class="params">(otherP Point)</span> <span class="title">Point</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Point&#123;</span><br><span class="line">p.X + otherP.X,</span><br><span class="line">p.Y + otherP.Y,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">p1 := Point&#123;<span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">p2 := Point&#123;<span class="number">2</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">result := p1.Add(p2)</span><br><span class="line"></span><br><span class="line">fmt.Println(result)<span class="comment">// &#123;3 3&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，小对象由于复制时速度较快，适合使用非指针接收器，大对象因为复制性能较低，适合使用指针接收器，此时再接收器和参数之间传递时不进行复制，只传递指针。</p>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-函数1</title>
      <link href="/2020/06/16/%E5%87%BD%E6%95%B0-1-%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/06/16/%E5%87%BD%E6%95%B0-1-%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一-函数"><a href="#一-函数" class="headerlink" title="一 函数"></a>一 函数</h2><h4 id="1-1-函数声明"><a href="#1-1-函数声明" class="headerlink" title="1.1 函数声明"></a>1.1 函数声明</h4><p>函数声明格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名字 <span class="params">(参数列表)</span> <span class="params">(返回值列表）&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">// 函数体</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">return</span> 返回值列表</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>函数名首字母小写为私有，大写为公有；</li><li>参数列表可以有0-多个，多参数使用逗号分隔，不支持默认参数；</li><li>返回值列表返回值类型可以不用写变量名</li><li>如果只有一个返回值且不声明类型，可以省略返回值列表与括号</li><li>如果有返回值，函数内必须有return</li></ul><p>Go中函数常见写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无返回值，默认返回0，所以也可以写为 func fn() int &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn</span><span class="params">()</span></span>&#123;&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Go推荐给函数返回值起一个变量名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn1</span><span class="params">()</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种返回值写法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn2</span><span class="params">()</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">result = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多返回值情</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn3</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Go返回值推荐多返回值写法：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn4</span><span class="params">()</span> <span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>, c <span class="keyword">int</span>)</span></span> &#123;多个参数类型如果相同，可以简写为： a,b <span class="keyword">int</span></span><br><span class="line">   a , b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">   <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-值传递和引用传递"><a href="#1-2-值传递和引用传递" class="headerlink" title="1.2 值传递和引用传递"></a>1.2 值传递和引用传递</h4><p>不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝决定拷贝的 数据大小，数据越大，效率越低。  </p><p>如果希望函数内的变量能修改函数外的变量，可以传入变量的地址&amp;，函数内以指针的方式操作变量。</p><h4 id="1-3-可变参数"><a href="#1-3-可变参数" class="headerlink" title="1.3 可变参数"></a>1.3 可变参数</h4><p>可变参数变量是一个包含所有参数的切片。如果要在多个可变参数中传递参数 ，可以在传递时在可变参数变量中默认添 加“ …”，将切片中的元素进行传递，而不是传递可变参数变量本身。</p><p>示例：对可变参数列表进行遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">joinStrings</span><span class="params">(slist ...<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> slist &#123;</span><br><span class="line">buf.WriteString(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(joinStrings(<span class="string">"pig"</span>, <span class="string">" and"</span>, <span class="string">" bird"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：参数传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际打印函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rawPrint</span><span class="params">(rawList ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> rawList &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装打印函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(slist ...<span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line"><span class="comment">// 将slist可变参数切片完整传递给下一个函数</span></span><br><span class="line">rawPrint(slist...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-匿名函数"><a href="#1-4-匿名函数" class="headerlink" title="1.4 匿名函数"></a>1.4 匿名函数</h4><p>匿名函数可以看做函数字面量，所有直接使用函数类型变量的地方都可以由匿名函数代替。匿名函数可以直接赋值给函数变量，可以当做实参，也可以作为返回值使用，还可以直接被调用。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">   a := <span class="number">3</span></span><br><span class="line">   f1 := <span class="function"><span class="keyword">func</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;    <span class="comment">// f1 即为匿名函数</span></span><br><span class="line">      fmt.Println(num) <span class="comment">// 匿名函数访问外部变量</span></span><br><span class="line">   &#125;</span><br><span class="line">   f1(a)</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;         <span class="comment">// 匿名函数自调</span></span><br><span class="line">      fmt.Println(a)</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名函数实战：取最大值,最小值</span></span><br><span class="line">x, y := <span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="params">(max,min <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> i &gt; j &#123;</span><br><span class="line">      max = i</span><br><span class="line">      min = j</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      max = j</span><br><span class="line">      min = i</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">fmt.Println(x + <span class="string">' '</span> + y)</span><br></pre></td></tr></table></figure><h4 id="1-5-函数类型"><a href="#1-5-函数类型" class="headerlink" title="1.5 函数类型"></a>1.5 函数类型</h4><p>函数去掉函数名、参数名和{}后的结果即是函数类型，可以使用%T打印该结果。  </p><p>两个函数类型相同的前提是：拥有相同的形参列表和返回值列表，且列表元素的次序、类型都相同，形参名可以不同。  </p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mathSum</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mathSub</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个函数类型</span></span><br><span class="line"><span class="keyword">type</span> MyMath <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义的函数类型作为参数使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(f MyMath, a , b <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> f(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常可以把函数类型当做一种引用类型，实际函数类型变量和函数名都可以当做指针变量，只想函数代码开始的位置，没有初始化的函数默认值是nil。</p><h2 id="二-Go函数特性总结"><a href="#二-Go函数特性总结" class="headerlink" title="二 Go函数特性总结"></a>二 Go函数特性总结</h2><ul><li>支持有名称的返回值；</li><li>不支持默认值参数；</li><li>不支持重载；</li><li>不支持命名函数嵌套，匿名函数可以嵌套；</li><li>Go函数从实参到形参的传递永远是值拷贝，有时函数调用后实参指向的值发生了变化，是因为参数传递的是指针的拷贝，实参是一个指针变量，传递给形参的是这个指针变量的副本，实质上仍然是值拷贝；</li><li>Go函数支持不定参数；</li></ul><h2 id="三-两个特殊函数"><a href="#三-两个特殊函数" class="headerlink" title="三 两个特殊函数"></a>三 两个特殊函数</h2><h4 id="3-1-init函数"><a href="#3-1-init函数" class="headerlink" title="3.1 init函数"></a>3.1 init函数</h4><p>Go语言中，除了可以在全局声明中初始化实体，也可以在init函数中初始化。init函数是一个特殊的函数，它会在包完成初始化后自动执行，执行优先级高于main函数，并且不能手动调用init函数，每一个文件有且仅有一个init函数，初始化过程会根据包的以来关系顺序单线程执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//在这里可以书写一些初始化操作</span></span><br><span class="line">fmt.Println(<span class="string">"init..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"main..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-new函数"><a href="#3-2-new函数" class="headerlink" title="3.2 new函数"></a>3.2 new函数</h4><p>new函数可以用来创建变量。表达式<code>new(T)</code>将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为<code>*T</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="keyword">int</span>)<span class="comment">// p 为 *int类型，只想匿名的int变量</span></span><br><span class="line">fmt.Println(*p)<span class="comment">// "0"</span></span><br><span class="line">*p = <span class="number">2</span><span class="comment">// 设置 int匿名变量值为2</span></span><br><span class="line">fmt.Println(*p)</span><br></pre></td></tr></table></figure><p>new函数还可以用来为结构体创建实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">f := <span class="built_in">new</span>(file)</span><br></pre></td></tr></table></figure><p>贴士：new函数其实是语法糖，不是新概念，如下所示的两个函数其实拥有相同的行为。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInt1</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInt2</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> dummy <span class="keyword">int</span></span><br><span class="line"><span class="keyword">return</span> &amp;dummy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>new</code>只是一个预定义函数，并不是一个关键字，所以<code>new</code>也有可能会被项目定义为别的类型。</p><h4 id="3-3-make函数"><a href="#3-3-make函数" class="headerlink" title="3.3 make函数"></a>3.3 make函数</h4><p>make函数经常用来创建切片、Map、管道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>上面展示了两种map的创建方式，其不同点是第一种创建方式无法预估长度，当长度超过了当前长度时，会引起内存的拷贝！！第二种创建方式直接限定了长度，这样能有效提升性能！</p>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-数值类型</title>
      <link href="/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-1-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-1-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一-数值类型"><a href="#一-数值类型" class="headerlink" title="一 数值类型"></a>一 数值类型</h2><p>数值类型指基本类型中的：整型、浮点型、复数。</p><h2 id="二-整数"><a href="#二-整数" class="headerlink" title="二 整数"></a>二 整数</h2><p>整数类型有无符号(如int)和带符号(如uint)两种，这两种类型的长度相同，但具体长度取决于不同编译器的实现。  </p><p>int8、int16、int32和int64四种有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，<br>同样uint8、uint16、uint32和uint64对应四种无符号整数类型。  </p><p>有符号类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int     32位系统占4字节（与int32范围一样），64位系统占8个节（与int64范围一样）     </span><br><span class="line">int8    占据1字节   范围 -128 ~ 127</span><br><span class="line">int16   占据2字节   范围 -2(15次方) ~ 2（15次方）-1</span><br><span class="line">int32   占据4字节   范围 -2(31次方) ~ 2（31次方）-1</span><br><span class="line">int64   占据8字节   范围 -2(63次方) ~ 2（63次方）-1</span><br><span class="line">runeint32的别称</span><br></pre></td></tr></table></figure><p>无符号类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint32位系统占4字节（与uint32范围一样），64位系统占8字节（与uint64范围一样）     </span><br><span class="line">uint8   占据1字节   范围 0 ~ 255</span><br><span class="line">uint16  占据2字节   范围 0 ~ 2（16次方）-1</span><br><span class="line">uint32  占据4字节   范围 0 ~ 2（32次方）-1</span><br><span class="line">uint64  占据8字节   范围 0 ~ 2（64次方）-1</span><br><span class="line">byteuint8的别称</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>上述类型的变量由于是不同类型，不允许互相赋值或操作</li><li>Go默认的整型类型是int</li><li>查看数据所占据的字节数方法：unsafe.Sizeof()</li></ul><h2 id="三-浮点类型"><a href="#三-浮点类型" class="headerlink" title="三 浮点类型"></a>三 浮点类型</h2><h4 id="3-1-浮点类型的分类"><a href="#3-1-浮点类型的分类" class="headerlink" title="3.1 浮点类型的分类"></a>3.1 浮点类型的分类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float32 单精度  占据4字节   范围 -3.403E38 ~ 3.403E38    (math.MaxFloat32)</span><br><span class="line">float64 双精度  占据8字节   范围 -1.798E208 ~ 1.798E308  (math.MaxFloat64)</span><br></pre></td></tr></table></figure><p>由上看出：</p><ul><li>浮点数是有符号的，浮点数在机器中存放形式是：浮点数=符号位+指数位+尾数位  </li><li>浮点型的范围是固定的，不受操作系统限制</li><li><code>.512</code> 这样数可以识别为 <code>0.512</code></li><li>科学计数法：<ul><li>5.12E2 = 5.12 * 10<sup>2</sup> </li><li>5.12E-2 = 5.12 / 10<sup>2</sup> </li></ul></li></ul><h4 id="3-2-精度损失"><a href="#3-2-精度损失" class="headerlink" title="3.2 精度损失"></a>3.2 精度损失</h4><p>float32可以提供大约6个十进制数的精度，float64大约可以提供15个十进制的精度（一般选择float64）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 <span class="keyword">float32</span> = <span class="number">-123.0000901</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="keyword">float64</span> = <span class="number">-123.0000901</span> </span><br><span class="line">fmt.Println(<span class="string">"num1="</span>,num1)<span class="comment">// -123.00009</span></span><br><span class="line">fmt.Println(<span class="string">"num2="</span>,num2)<span class="comment">// -123.0000901</span></span><br></pre></td></tr></table></figure><h4 id="3-3-浮点数判断相等"><a href="#3-3-浮点数判断相等" class="headerlink" title="3.3 浮点数判断相等"></a>3.3 浮点数判断相等</h4><p>使用 == 号判断浮点数，是不可行的，替代方案如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEqual</span><span class="params">(f1,f2,p <span class="keyword">float64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// p为用户自定义精度，如：0.00001</span></span><br><span class="line">   <span class="keyword">return</span> math.Abs(f1-f2) &lt; p           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-复数"><a href="#四-复数" class="headerlink" title="四 复数"></a>四 复数</h2><p>Go中复数默认类型是complex128（64位实数+64位虚数）。如果需要小一些的，也有complex64(32位实数+32位虚数)。  </p><p>复数的形式为<code>RE + IMi</code>，其中RE是实数部分，IM是虚数部分，而最后的i是虚数单位。</p><p>如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">complex128</span></span><br><span class="line">t = <span class="number">2.1</span> + <span class="number">3.14i</span></span><br><span class="line">t1 = <span class="built_in">complex</span>(<span class="number">2.1</span>,<span class="number">3.14</span>) <span class="comment">// 结果同上</span></span><br><span class="line">fmt.Println(<span class="built_in">real</span>(t))   <span class="comment">// 实部：2.1</span></span><br><span class="line">fmt.Println(<span class="built_in">imag</span>(t))   <span class="comment">// 虚部：3.14</span></span><br></pre></td></tr></table></figure><h2 id="五-NaN非数"><a href="#五-NaN非数" class="headerlink" title="五 NaN非数"></a>五 NaN非数</h2><p>go中的<code>NaN</code>非数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z <span class="keyword">float64</span></span><br><span class="line"><span class="comment">// 输出 "0 -0 +Inf -Inf NaN"</span></span><br><span class="line">fmt.Println(z, -z, <span class="number">1</span>/z, <span class="number">-1</span>/z, z/z)</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>函数<code>math.IsNaN</code>用于测试一个数是否是非数NaN，</li><li>函数<code>math.NaN</code>则返回非数对应的值。</li><li>虽然可以用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等的。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nan := math.NaN()</span><br><span class="line"><span class="comment">// "false false false"</span></span><br><span class="line">fmt.Println(nan == nan, nan &lt; nan, nan &gt; nan)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-集合map</title>
      <link href="/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-2-%E9%9B%86%E5%90%88/"/>
      <url>/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-2-%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="一-集合map"><a href="#一-集合map" class="headerlink" title="一 集合map"></a>一 集合map</h2><h4 id="1-1-map的创建"><a href="#1-1-map的创建" class="headerlink" title="1.1 map的创建"></a>1.1 map的创建</h4><p>Go内置了map类型，map是一个无序键值对集合（也有一些书籍翻译为字典）。  </p><p>普通创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个map类型，[]内的类型指任意可以进行比较的类型 int指值类型</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"a"</span>:<span class="number">1</span>,<span class="string">"b"</span>:<span class="number">2</span>&#125;</span><br><span class="line">fmt.Print(m[<span class="string">"a"</span>])</span><br></pre></td></tr></table></figure><p>make方式创建map：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">ID <span class="keyword">string</span></span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>] Person</span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>] Person)</span><br><span class="line">m[<span class="string">"123"</span>] = Person&#123;<span class="string">"123"</span>,<span class="string">"Tom"</span>&#125;</span><br><span class="line">p,isFind := m[<span class="string">"123"</span>]</span><br><span class="line">fmt.Println(isFind)<span class="comment">//true</span></span><br><span class="line">fmt.Println(p)<span class="comment">//&#123;123 Tom&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：golang中map的 key 通常 key 为 int 、string，但也可以是其他类型如：bool、数字、string、指针、channel，还可以是只包含前面几个类型的接口、结构体、数组。slice、map、function由于不能使用 == 来判断，不能作为map的key。  </p><h4 id="1-2-map的使用"><a href="#1-2-map的使用" class="headerlink" title="1.2 map的使用"></a>1.2 map的使用</h4><p>通过key操作元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">numbers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">numbers[<span class="string">"one"</span>] = <span class="number">1</span> <span class="comment">//赋值</span></span><br><span class="line">numbers[<span class="string">"ten"</span>] = <span class="number">10</span> <span class="comment">//赋值</span></span><br><span class="line">numbers[<span class="string">"three"</span>] = <span class="number">3</span></span><br><span class="line"><span class="built_in">delete</span>(numbers, <span class="string">"ten"</span>) <span class="comment">// 删除key为 ten 的元素</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"第三个数字是: "</span>, numbers[<span class="string">"three"</span>]) <span class="comment">// 读取数据</span></span><br></pre></td></tr></table></figure><p>map的遍历：同数组一样，使用for-range 的结构遍历  </p><p>注意：</p><ul><li>map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取；</li><li>map的长度是不固定的，也就是和slice一样，也是一种引用类型    </li><li>内置的len函数同样适用于map，返回map拥有的key的数量</li><li>go没有提供清空元素的方法，可以重新make一个新的map，不用担心垃圾回收的效率，因为go中并行垃圾回收效率比写一个清空函数高效很多</li><li>map和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制</li></ul><h4 id="1-3-并发安全的map"><a href="#1-3-并发安全的map" class="headerlink" title="1.3 并发安全的map"></a>1.3 并发安全的map</h4><p>演示并发读写map的问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;<span class="comment">//无限写入</span></span><br><span class="line">m[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;<span class="comment">//无限读取</span></span><br><span class="line">_ = m[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;&#125;<span class="comment">//无限循环，让并发程序在后台执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译会有错误提示：<code>fatal error: concurrent map read and map write</code>，即出现了并发读写，因为用两个并发程序不断的对map进行读和写，产生了竞态问题。map内部会对这种错误进行检查并提前发现。   </p><p>Go内置的map只有读是线程安全的，读写是线程不安全的。  </p><p>需要并发读写时，一般都是加锁，但是这样做性能不高，在go1.9版本中提供了更高效并发安全的sync.Map。  </p><p>sync.Map的特点：</p><ul><li>无须初始化，直接声明即可</li><li>sync.Map不能使用map的方式进行取值和设值操作，而是使用sync.Map的方法进行调用。Store表示存储，Load表示获取，Delete表示删除。 </li><li>使用Range配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，需要继续迭代时，返回true，终止迭代返回false。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scene sync.Map</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存键值对</span></span><br><span class="line">scene.Store(<span class="string">"id"</span>,<span class="number">1</span>)</span><br><span class="line">scene.Store(<span class="string">"name"</span>,<span class="string">"lisi"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据键取值</span></span><br><span class="line">fmt.Println(scene.Load(<span class="string">"name"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line">scene.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">fmt.Println(k,v)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：map没有提供获取map数量的方法，可以在遍历时手动计算。sync.Map为了并发安全。损失了一定的性能。</p>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-切片</title>
      <link href="/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-1-%E5%88%87%E7%89%87/"/>
      <url>/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-1-%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h2 id="一-切片创建"><a href="#一-切片创建" class="headerlink" title="一 切片创建"></a>一 切片创建</h2><p>切片(slice)解决了数组长度不能扩展，以及基本类型数组传递时产生副本的问题。</p><p>常用创建方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">int</span><span class="comment">// 和声明数组一样，只是没有长度，但是这样做没有意义，因为底层的数组指针为nil</span></span><br><span class="line">s2 := []<span class="keyword">byte</span> &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;</span><br><span class="line">fmt.Println(s1)<span class="comment">//输出 []</span></span><br><span class="line">fmt.Print(s2)<span class="comment">//输出 [97 98 99]</span></span><br></pre></td></tr></table></figure><p>使用make函数创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>)<span class="comment">// 创建长度为5，容量为5，初始值为0的切片</span></span><br><span class="line">slice2 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>,<span class="number">7</span>)<span class="comment">// 创建长度为5，容量为7，初始值为0的切片</span></span><br><span class="line">slice3 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;<span class="comment">// 创建长度为5，容量为5，并已经初始化的切片</span></span><br></pre></td></tr></table></figure><p>从数组创建：slice可以从一个数组再次声明。slice通过array[i:j]来获取，其中i是数组的开始位置，j是结束位置，但不包含array[j]，它的长度是j-i:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个含有10个元素元素类型为byte的数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>]<span class="keyword">byte</span> &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明两个含有byte的slice</span></span><br><span class="line">ar a, b []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a指向数组的第3个元素开始，并到第五个元素结束，现在a含有的元素: ar[2]、ar[3]和ar[4]</span></span><br><span class="line">a = arr[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">// b是数组arr的另一个slicre,b的元素是：ar[3]和ar[4]</span></span><br><span class="line">b = arr[<span class="number">3</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>注意：声明数组时，方括号内写明了数组的长度或使用…自动计算长度，而声明slice时，方括号内没有任何字符。  </p><p>从切片创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oldSlice := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">newSlice := oldSlice[:<span class="number">6</span>]<span class="comment">//基于切片前6个元素创建，没有的默认0</span></span><br></pre></td></tr></table></figure><p>注意：如果选择的旧切片长度超出了旧切片的cap()值（切片存储长度），则不合法。  </p><h2 id="二-切片常见操作"><a href="#二-切片常见操作" class="headerlink" title="二 切片常见操作"></a>二 切片常见操作</h2><h4 id="2-1-切片常见内置函数"><a href="#2-1-切片常见内置函数" class="headerlink" title="2.1 切片常见内置函数"></a>2.1 切片常见内置函数</h4><p>切片常用内置函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">len()返回切片长度</span><br><span class="line">cap()返回切片底层数组容量</span><br><span class="line">append()对切片追加元素</span><br><span class="line">func copy(dst, src []Type) int</span><br><span class="line">将src中数据拷贝到dst中，返回拷贝的元素个数</span><br></pre></td></tr></table></figure><p>切片空间与元素个数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice1))<span class="comment">// 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice1))<span class="comment">// 10</span></span><br><span class="line">fmt.Println(slice1)<span class="comment">// [0 0 0 0 0]</span></span><br></pre></td></tr></table></figure><p>切片操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切片增加</span></span><br><span class="line">slice1 = <span class="built_in">append</span>(slice1,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">fmt.Println(slice1)<span class="comment">//输出[0 0 0 0 0 1 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片增加一个新切片</span></span><br><span class="line">sliceTemp := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">slice1 = <span class="built_in">append</span>(slice1,sliceTemp...)</span><br><span class="line">fmt.Println(slice1)<span class="comment">//输出[0 0 0 0 0 1 2 0 0 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片拷贝</span></span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>&#125;</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)<span class="comment">//必须给与充足的空间</span></span><br><span class="line">num := <span class="built_in">copy</span>(s2, s1)</span><br><span class="line"></span><br><span class="line">fmt.Println(s1)<span class="comment">//[1 3 6 9]</span></span><br><span class="line">fmt.Println(s2)<span class="comment">//[1 3 6 9 0 0 0 0 0 0]</span></span><br><span class="line">fmt.Println(num)<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片中删除元素</span></span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>&#125;</span><br><span class="line">index := <span class="number">2</span><span class="comment">//删除该位置元素</span></span><br><span class="line">s1 = <span class="built_in">append</span>(s1[:index], s1[index+<span class="number">1</span>:]...)</span><br><span class="line">fmt.Println(s1)<span class="comment">//[1 3 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片拷贝</span></span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line"><span class="built_in">copy</span>(s1,s2) <span class="comment">//复制s2前三个元素到slice1前3位置</span></span><br><span class="line"><span class="built_in">copy</span>(s2,s1) <span class="comment">//复制s1前三个元素到slice2</span></span><br></pre></td></tr></table></figure><p>注意：没有…会编译错误，默认第二个参数后是元素值，传入切片需要展开。如果追加的长度超过当前已分配的存储空间，切片会自动分配更大的内存。  </p><h4 id="2-2-切片的一些简便操作"><a href="#2-2-切片的一些简便操作" class="headerlink" title="2.2 切片的一些简便操作"></a>2.2 切片的一些简便操作</h4><ul><li>slice的默认开始位置是0，ar[:n]等价于ar[0:n]</li><li>slice的第二个序列默认是数组的长度，ar[n:]等价于ar[n:len(ar)]</li><li>如果从一个数组里面直接获取slice，可以这样ar[:]，因为默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)]</li><li>切片的遍历可以使用for循环，也可以使用range函数  </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个数组</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">10</span>]<span class="keyword">byte</span>&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>&#125;</span><br><span class="line"><span class="comment">// 声明两个slice</span></span><br><span class="line"><span class="keyword">var</span> aSlice, bSlice []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示一些简便操作</span></span><br><span class="line">aSlice = array[:<span class="number">3</span>] <span class="comment">// 等价于aSlice = array[0:3] aSlice包含元素: a,b,c</span></span><br><span class="line">aSlice = array[<span class="number">5</span>:] <span class="comment">// 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,j</span></span><br><span class="line">aSlice = array[:] <span class="comment">// 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从slice中获取slice</span></span><br><span class="line">aSlice = array[<span class="number">3</span>:<span class="number">7</span>] <span class="comment">// aSlice包含元素: d,e,f,g，len=4，cap=7</span></span><br><span class="line">bSlice = aSlice[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">// bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,f</span></span><br><span class="line">bSlice = aSlice[:<span class="number">3</span>] <span class="comment">// bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,f</span></span><br><span class="line">bSlice = aSlice[<span class="number">0</span>:<span class="number">5</span>] <span class="comment">// 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,h</span></span><br><span class="line">bSlice = aSlice[:] <span class="comment">// bSlice包含所有aSlice的元素: d,e,f,g</span></span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 2.3 切片的截取</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- `</span>s[n]<span class="string">`：切片s中索引为位置为n的项</span></span><br><span class="line"><span class="string">- `</span>s[:]<span class="string">`：从切片s的索引位置0到`</span><span class="built_in">len</span>(s)<span class="number">-1</span><span class="string">`所获得的切片</span></span><br><span class="line"><span class="string">- `</span>s[low:]<span class="string">`：从切片s的索引位置low到`</span><span class="built_in">len</span>(s)<span class="number">-1</span><span class="string">`所获得的切片</span></span><br><span class="line"><span class="string">- `</span>s[:high]<span class="string">`：从切片s的索引位置0到high所获得的切片</span></span><br><span class="line"><span class="string">- `</span>s[low:high]<span class="string">`：从切片s的索引位置low到high所获得的切片</span></span><br><span class="line"><span class="string">- `</span>s[low:high:max]<span class="string">`：从low到high的切片，且容量`</span><span class="built_in">cap</span>=max-low<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 1.7 字符串转切片  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line">str := <span class="string">"hello,世界"</span></span><br><span class="line">a := []<span class="keyword">byte</span>(str)<span class="comment">//字符串转换为[]byte类型切片</span></span><br><span class="line">b := []<span class="keyword">rune</span>(str)<span class="comment">//字符串转换为[]rune类型切片</span></span><br></pre></td></tr></table></figure><h2 id="三-切片存储结构"><a href="#三-切片存储结构" class="headerlink" title="三 切片存储结构"></a>三 切片存储结构</h2><p>与数组相比，切片多了一个存储能力值的概念，即元素个数与分配空间可以是两个不同的值，其结构如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">arrary = unsafe.Pointer<span class="comment">//指向底层数组的指针</span></span><br><span class="line"><span class="built_in">len</span> <span class="keyword">int</span><span class="comment">//切片元素数量</span></span><br><span class="line"><span class="built_in">cap</span> <span class="keyword">int</span><span class="comment">//底层数组的容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以切片通过内部的指针和相关属性引用数组片段，实现了变长方案，Slice并不是真正意义上的动态数组。  </p><p>合理设置存储能力，可以大幅提升性能，比如知道最多元素个数为50，那么提前设置为50，而不是先设为30，可以明显减少重新分配内存的操作。  </p><h2 id="四-切片作为函数参数"><a href="#四-切片作为函数参数" class="headerlink" title="四 切片作为函数参数"></a>四 切片作为函数参数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"test---%p\n"</span>, s) <span class="comment">// 打印与main函数相同的地址</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Printf(<span class="string">"test---%p\n"</span>, s) <span class="comment">// 一旦append的数据超过切片长度，则会打印新地址</span></span><br><span class="line">fmt.Println(<span class="string">"test---"</span>, s)    <span class="comment">// [0 0 0 1 2 3 4 5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">test(s1)</span><br><span class="line">fmt.Printf(<span class="string">"main---%p\n"</span>, s1) <span class="comment">// 不会因为test函数内的append而改变</span></span><br><span class="line">fmt.Println(<span class="string">"main---"</span>, s1)    <span class="comment">// [ 0 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-函数2-闭包</title>
      <link href="/2020/06/16/%E5%87%BD%E6%95%B0-2-%E9%97%AD%E5%8C%85/"/>
      <url>/2020/06/16/%E5%87%BD%E6%95%B0-2-%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="一-闭包"><a href="#一-闭包" class="headerlink" title="一 闭包"></a>一 闭包</h2><h4 id="1-1-闭包概念"><a href="#1-1-闭包概念" class="headerlink" title="1.1 闭包概念"></a>1.1 闭包概念</h4><p>闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使己经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量。  </p><p>简单的说 : 函数+引用环境=闭包  </p><p>贴士：闭包( Closure)在某些编程语言中也被称为 Lambda表达式（如Java）</p><p>在闭包中可以修改引用的变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello"</span></span><br><span class="line">foo := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;<span class="comment">// 声明一个匿名函数</span></span><br><span class="line">str = <span class="string">"world"</span></span><br><span class="line">&#125;</span><br><span class="line">foo()<span class="comment">//  调用匿名函数，修改str值</span></span><br><span class="line">fmt.Print(str)<span class="comment">// world</span></span><br></pre></td></tr></table></figure><h4 id="1-2-闭包案例一-简单示例"><a href="#1-2-闭包案例一-简单示例" class="headerlink" title="1.2 闭包案例一  简单示例"></a>1.2 闭包案例一  简单示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn1</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="built_in">print</span>(&amp;a, a)</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">f := fn1(<span class="number">1</span>)<span class="comment">//输出地址</span></span><br><span class="line">g := fn1(<span class="number">2</span>)<span class="comment">//输出地址</span></span><br><span class="line"></span><br><span class="line">fmt.Println(f(<span class="number">1</span>))<span class="comment">//输出1</span></span><br><span class="line">fmt.Println(f(<span class="number">1</span>))<span class="comment">//输出1</span></span><br><span class="line"></span><br><span class="line">fmt.Println(g(<span class="number">2</span>))<span class="comment">//输出2</span></span><br><span class="line">fmt.Println(g(<span class="number">2</span>))<span class="comment">//输出2</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-闭包案例二-实现累加器"><a href="#1-3-闭包案例二-实现累加器" class="headerlink" title="1.3 闭包案例二 实现累加器"></a>1.3 闭包案例二 实现累加器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Accumulate</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;<span class="comment">// 返回一个闭包</span></span><br><span class="line">value++</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">accAdd := Accumulate(<span class="number">1</span>)</span><br><span class="line">fmt.Println(accAdd())<span class="comment">// 2</span></span><br><span class="line">fmt.Println(accAdd())<span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-结构体</title>
      <link href="/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-4-%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-4-%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一-结构体的基本使用"><a href="#一-结构体的基本使用" class="headerlink" title="一 结构体的基本使用"></a>一 结构体的基本使用</h2><p>结构体可以用来声明新的类型，作为其他类型的属性/字段的容器，如下定义一个学生结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按顺序初始化：每个成员都必须初始化</span></span><br><span class="line"><span class="keyword">var</span> p1 Person = Person&#123;<span class="string">"lisi"</span>, <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制定成员初始化：没有被初始化的，自动赋零值</span></span><br><span class="line">p2 := Person&#123;age:<span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 申请结构体</span></span><br><span class="line">p3 := <span class="built_in">new</span>(Person)      <span class="comment">//被new生成的结构体实例其实是指针类型</span></span><br><span class="line">p3.name = <span class="string">"zs"</span>          <span class="comment">//这里的.语法只是语法糖，将p3.name转换成了(*p3).name</span></span><br><span class="line">p3.age = <span class="number">27</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接声明</span></span><br><span class="line"><span class="keyword">var</span> s4 Person</span><br><span class="line">p4.name = <span class="string">"ww"</span></span><br><span class="line">p4.age = <span class="number">30</span></span><br></pre></td></tr></table></figure><p>贴士：</p><ul><li>struct的结构中的类型可以是任意类型，且存储空间是连续的，其字段按照声明时的顺序存放  </li><li>如果结构体的所有的成员都是可以比较的，那么结构体本身也是可以比较的，使用 == != ，不支持 &gt; 和 &lt;</li><li>如果结构体的成员要被包外调用，需要大写首字母。</li></ul><h2 id="二-结构体地址与实例化"><a href="#二-结构体地址与实例化" class="headerlink" title="二 结构体地址与实例化"></a>二 结构体地址与实例化</h2><p>前面说过，对结构体的new其实是生成了一个指针类型。其实对结构体进行<code>&amp;</code>取地址操作时，也可以视为对该类型进行一次<code>new</code>的实例化操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ins := &amp;T&#123;&#125;</span><br><span class="line"></span><br><span class="line"># T是结构体类型</span><br><span class="line"># ins为结构体的实例，类型为*T，是指针类型</span><br></pre></td></tr></table></figure><h2 id="四-内嵌结构体"><a href="#四-内嵌结构体" class="headerlink" title="四 内嵌结构体"></a>四 内嵌结构体</h2><p>当前结构体可以直接访问其内嵌结构体的内部字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Animal</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Person</span><br><span class="line">ClassName <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方式1</span></span><br><span class="line">s1 := Student&#123;</span><br><span class="line">Person&#123;</span><br><span class="line">Animal: Animal &#123;</span><br><span class="line">Age: <span class="number">15</span>,</span><br><span class="line">&#125;,</span><br><span class="line">Name:<span class="string">"lisi"</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"一班"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s1.Age)<span class="comment">// 正确输出15</span></span><br><span class="line">fmt.Println(s1.Person.Name)<span class="comment">// 正确输出lisi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方式2</span></span><br><span class="line"><span class="keyword">var</span> s2 Student</span><br><span class="line">s2.Name = <span class="string">"zs"</span></span><br><span class="line">s2.Age = <span class="number">30</span></span><br><span class="line">s2.ClassName = <span class="string">"二班"</span></span><br><span class="line">fmt.Println(s2.Age)<span class="comment">// 正确输出30</span></span><br><span class="line">fmt.Println(s2.Person.Name)<span class="comment">// 正确输出zs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-匿名字段"><a href="#四-匿名字段" class="headerlink" title="四 匿名字段"></a>四 匿名字段</h2><p>结构体的字段名与类型一一对应，如果不提供名字，则为匿名字段。</p><p>匿名字段如果是一个struct，这个struct拥有的全部字段都被隐式引入了当前的struct。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person                   <span class="comment">// 匿名字段，那么默认Student就包含了Human的所有字段</span></span><br><span class="line">    classroom <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅仅是struct，其他所有内置类型和自定义类型都可以作为匿名字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> course []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Person <span class="comment">// 匿名字段，struct</span></span><br><span class="line">course<span class="comment">// 内置一个切片类型</span></span><br><span class="line">classroom <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个学生</span></span><br><span class="line">s := Student&#123;Person:Person&#123;<span class="string">"LiLei"</span>, <span class="number">17</span>&#125;, classroom:<span class="string">"二班"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问该学生字段</span></span><br><span class="line">fmt.Println(<span class="string">"name = "</span>, s.name)</span><br><span class="line">fmt.Println(<span class="string">"classroom =  "</span>, s.classroom)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改学生的课程</span></span><br><span class="line">s.course = []<span class="keyword">string</span>&#123;<span class="string">"语文"</span>, <span class="string">"美术"</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"course = "</span>, s.course)<span class="comment">// [语文 美术]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贴士：如果Person和Student中都有同一个字段，那么Go会优先访问当前层。例如二者都有<code>tel</code>字段，那么<code>s.tel</code>将会访问的是Student中的数据。</p>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-数组</title>
      <link href="/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-3-%E6%95%B0%E7%BB%84/"/>
      <url>/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-3-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="一-数组"><a href="#一-数组" class="headerlink" title="一 数组"></a>一 数组</h2><h4 id="1-1-数组的声明"><a href="#1-1-数组的声明" class="headerlink" title="1.1 数组的声明"></a>1.1 数组的声明</h4><p>数组是一段固定长度的连续内存区域。数组的长度定义后不可更改，长度使用 len() 获取。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 [<span class="number">10</span>]<span class="keyword">int</span><span class="comment">//定义长度为10的整型数组，很少这样使用</span></span><br><span class="line">arr2 [<span class="number">5</span>]<span class="keyword">int</span> := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;<span class="comment">//定义并初始化</span></span><br><span class="line">arr3 := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;<span class="comment">//自动推导并初始化</span></span><br><span class="line">arr4 := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;<span class="comment">//指定总长度，前几位被初始化，没有的使用零值</span></span><br><span class="line">arr5 := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>:<span class="number">10</span>, <span class="number">4</span>:<span class="number">11</span>&#125;<span class="comment">//有选择的初始化，没被初始化的使用零值</span></span><br><span class="line">arr6 := [...]<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;<span class="comment">//自动计算长度</span></span><br></pre></td></tr></table></figure><h4 id="1-2-数组常用操作"><a href="#1-2-数组常用操作" class="headerlink" title="1.2 数组常用操作"></a>1.2 数组常用操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr[:]      代表所有元素</span><br><span class="line">arr[:5]     代表前五个元素，即区间的左闭右开</span><br><span class="line">arr[5:]     代表从第5个开始（不包含第5个）</span><br><span class="line">len(arr)    数组的长度</span><br></pre></td></tr></table></figure><p>贴士：上述操作会引发类型的变化，数组将会转化为Go中新的数据类型slice，见09节</p><h4 id="1-3-数组的遍历"><a href="#1-3-数组的遍历" class="headerlink" title="1.3 数组的遍历"></a>1.3 数组的遍历</h4><p>方式一：for循环遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">fmt.Println(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：for-range遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">fmt.Println(k)<span class="comment">//元素位置</span></span><br><span class="line">fmt.Println(v)<span class="comment">//元素值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-数组使用注意事项"><a href="#1-4-数组使用注意事项" class="headerlink" title="1.4 数组使用注意事项"></a>1.4 数组使用注意事项</h4><p>数组创建完长度就固定，不可以再追加元素；  </p><p>长度是数组类型的一部分，因此<code>[3]int</code>与<code>[4]int</code>是不同的类型；  </p><p>数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该函数的副本，而不是他的指针。</p>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言介绍</title>
      <link href="/2020/06/16/Go%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/06/16/Go%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一-Go语言介绍"><a href="#一-Go语言介绍" class="headerlink" title="一 Go语言介绍"></a>一 Go语言介绍</h2><p>Go语言是Google公司开发的一种静态、编译型语言，具备自动垃圾回收功能，原生支持并发开发。   </p><p>Go的诞生是为了解决当下编程语言对并发支持不友好、编译速度慢、编程复杂这三个主要问题。   </p><p>Go既拥有接近静态编译语言（如C）的安全和性能，又有接近脚本语言（如python）的开发效率，其主要特点有：   </p><ul><li>天然并发：语言层面支持并发，包括gorotuine、channel</li><li>语法优势：没有历史包袱，包含多返回值、匿名函数、defer</li><li>语言层面支持多核CPU利用</li></ul><p>与Java相比的不同：</p><ul><li>没有Java支持的一些面向对象思想：重载、构造函数、继承等</li><li>代码规范严格：花括号位置固定，变量名大小写代表公有私有等</li><li>支持函数式编程：匿名函数，闭包</li><li>接口非侵入式：不需要显式声明对接口的继承，实现了接口的方法即为实现了该接口类型</li></ul><h2 id="二-Go安装"><a href="#二-Go安装" class="headerlink" title="二 Go安装"></a>二 Go安装</h2><p>推荐使用官方的安装包直接安装，下载地址：<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a>   </p><p>贴士：本笔记都是基于go1.13    </p><p><strong>Win安装Go</strong>：<br>打开Win安装包下一步下一步即可，默认安装在目录：c:\Go  </p><p><strong>Mac安装Go</strong>：<br>打开Mac安装包下一步下一步即可，需要预装Xcode。安装完毕后需配置环境变量即可使用，但是如果要使用一些<code>go mod</code>功能推荐如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.bash_profile</span><br><span class="line"></span><br><span class="line">export GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go                 # golang本身的安装位置</span><br><span class="line">export GOPATH&#x3D;~&#x2F;go&#x2F;                         # golang包的本地安装位置</span><br><span class="line">export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.io           # golang包的下载代理</span><br><span class="line">export GO111MODULE&#x3D;on                       # 开启go mod模式</span><br><span class="line">export PATH&#x3D;$PATH:$GOROOT&#x2F;bin               # go本身二进制文件的环境变量</span><br><span class="line">export PATH&#x3D;$PATH:$GOPATH&#x2F;bin               # go第三方二进制文件的环境便令</span><br><span class="line"></span><br><span class="line"># 重启环境</span><br><span class="line">source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure><p><strong>Linux安装Go</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 下载解压</span><br><span class="line">wget https:&#x2F;&#x2F;dl.google.com&#x2F;go&#x2F;go1.13.1.linux-amd64.tar.gz</span><br><span class="line">tar zxvf go*.tar.gz -C &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line"></span><br><span class="line"># 配置环境：注意该环境必须是go1.11版本及以上且项目要求使用go mod才可以开启</span><br><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line">export GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go                 # golang本身的安装位置</span><br><span class="line">export GOPATH&#x3D;~&#x2F;go                          # golang包的本地安装位置</span><br><span class="line">export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.io,direct    # golang包的下载代理,回源地址获取</span><br><span class="line">export GO111MODULE&#x3D;on                       # 开启go mod模式</span><br><span class="line">export PATH&#x3D;$PATH:$GOROOT&#x2F;bin               # go本身二进制文件的环境变量</span><br><span class="line">export PATH&#x3D;$PATH:$GOPATH&#x2F;bin               # go第三方二进制文件的环境便令</span><br><span class="line"></span><br><span class="line"># 重启环境</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>测试安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看go版本</span><br><span class="line">go version</span><br><span class="line"></span><br><span class="line"># 查看go环境配置</span><br><span class="line">go env</span><br></pre></td></tr></table></figure><p>关于<code>go modules</code>的详细讲解位于本章12节。</p><h2 id="三-HelloWorld"><a href="#三-HelloWorld" class="headerlink" title="三 HelloWorld"></a>三 HelloWorld</h2><p>新建文件<code>hello.go</code>，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main                        <span class="comment">//每个程序都有且仅有一个main包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span>    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;                       <span class="comment">//主函数main只有一个</span></span><br><span class="line">    fmt.Println(<span class="string">"Hello World!"</span>)     <span class="comment">//函数调用：包名.函数名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 执行方式一：先编译，再运行</span><br><span class="line">go build hello.go        # 编译。在同级目录下生成文件&#96;hello&#96;，添加参数&#96;-o 名称&#96; 则可指定生成的文件名 </span><br><span class="line">.&#x2F;hello                  # 运行。贴士：win下生成的是.exe文件，直接双击执行即可</span><br><span class="line"></span><br><span class="line"># 执行方式二：直接运行</span><br><span class="line">go run hello.go</span><br></pre></td></tr></table></figure><p>两种执行流程的区别：  </p><ul><li>先编译方式：可执行文件可以在任意没有go环境的机器上运行，（因为go依赖被打包进了可执行文件）</li><li>直接执行方式：源码执行时，依赖于机器上的go环境，没有go环境无法直接运行</li></ul><h2 id="四-Go语法注意"><a href="#四-Go语法注意" class="headerlink" title="四 Go语法注意"></a>四 Go语法注意</h2><ul><li>Go源文件以 “go” 为扩展名</li><li>与Java、C语言类似，Go应用程序的执行入口也是main()函数</li><li>Go语言严格区分大小写</li><li>Go不需要分号结尾</li><li>Go编译是一行一行执行，所以不能将类似两个 Print 函数写在一行</li><li>Go语言定义的变量或者import的包如果没有使用到，代码不能编译通过</li><li>Go的注释使用 // 或者 /*  */</li></ul><h2 id="五-开发工具推荐"><a href="#五-开发工具推荐" class="headerlink" title="五 开发工具推荐"></a>五 开发工具推荐</h2><p>笔者推荐的go开发工具：</p><ul><li>goland</li><li>vscode</li></ul><p>vscode的相关go插件会出现无法下载情况，解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 如果开启了go mod，则</span><br><span class="line">    go get -u -v github.com&#x2F;ramya-rao-a&#x2F;go-outline</span><br><span class="line">    go get -u -v github.com&#x2F;acroca&#x2F;go-symbols</span><br><span class="line">    go get -u -v golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;guru</span><br><span class="line">    go get -u -v golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;gorename</span><br><span class="line">    go get -u -v github.com&#x2F;rogpeppe&#x2F;godef</span><br><span class="line">    go get -u -v github.com&#x2F;sqs&#x2F;goreturns</span><br><span class="line">    go get -u -v github.com&#x2F;cweill&#x2F;gotests&#x2F;gotests</span><br><span class="line">    go get -u -v golang.org&#x2F;x&#x2F;lint&#x2F;golint</span><br><span class="line"></span><br><span class="line"># 如果未开启go mod，则需要进入cd $GOPATH&#x2F;src ，使用 git clone 下载上述文件        </span><br><span class="line"></span><br><span class="line"># 安装</span><br><span class="line">cd $GOPATH</span><br><span class="line">    go install github.com&#x2F;ramya-rao-a&#x2F;go-outline</span><br><span class="line">    go install github.com&#x2F;acroca&#x2F;go-symbols</span><br><span class="line">    go install golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;guru</span><br><span class="line">    go install golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;gorename</span><br><span class="line">    go install github.com&#x2F;rogpeppe&#x2F;godef</span><br><span class="line">    go install github.com&#x2F;sqs&#x2F;goreturns</span><br><span class="line">    go install github.com&#x2F;cweill&#x2F;gotests&#x2F;gotests</span><br><span class="line">    go install golang.org&#x2F;x&#x2F;lint&#x2F;golint</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-类型转换</title>
      <link href="/2020/06/16/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%88%AB%E5%90%8D/"/>
      <url>/2020/06/16/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%88%AB%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="一-数据类型转换"><a href="#一-数据类型转换" class="headerlink" title="一 数据类型转换"></a>一 数据类型转换</h2><h4 id="1-1-显式转换"><a href="#1-1-显式转换" class="headerlink" title="1.1 显式转换"></a>1.1 显式转换</h4><p>Go在不同类型的变量之间赋值时需要显式转换。也就是说Golang中数据类型不能自动转换。</p><h4 id="1-2-数值类型转换"><a href="#1-2-数值类型转换" class="headerlink" title="1.2 数值类型转换"></a>1.2 数值类型转换</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int32</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> n1 <span class="keyword">float64</span> = <span class="keyword">float64</span>(i)</span><br><span class="line">fmt.Printf(<span class="string">"n1=%v"</span>, n1)<span class="comment">//输出100</span></span><br></pre></td></tr></table></figure><p>注意：在转换中，比如将<code>int64</code>转成<code>int8【-128---127】</code>，编译时不会报错，只是转换的结果是按溢出处理，和我们希望的结果不一样。 因此在转换时，需要考虑范围。</p><h4 id="1-3-基本数据类型与字符串转换"><a href="#1-3-基本数据类型与字符串转换" class="headerlink" title="1.3 基本数据类型与字符串转换"></a>1.3 基本数据类型与字符串转换</h4><p>基本数据类型转字符串：fmt.Sprintf();该函数会返回转换后的字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">str = fmt.Sprintf(<span class="string">"%t"</span>, b)</span><br><span class="line">fmt.Printf(str)<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>字符串转基本数据类型：使用包strconv</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"true"</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span></span><br><span class="line">b, _ = strconv.ParseBool(str)</span><br><span class="line">   fmt.Printf(<span class="string">"%v"</span>, b)</span><br></pre></td></tr></table></figure><p>注意：在将<code>String</code>类型转成基本数据类型时，要确保<code>String</code>类型能够转成有效的数据，比如可以把”123”,转成一个整数，但不能转换”hello”，如果这样做，Golang 直接将其转成<code>0</code>，其它类型也是一样的道理，如：<code>float =&gt; 0 bool =&gt; false</code>。</p><h2 id="二-类型别名"><a href="#二-类型别名" class="headerlink" title="二 类型别名"></a>二 类型别名</h2><h4 id="2-1-类型别名的使用"><a href="#2-1-类型别名的使用" class="headerlink" title="2.1 类型别名的使用"></a>2.1 类型别名的使用</h4><p>Go在1.9版本加入了类型别名。主要用于代码升级、迁移中类型的兼容问题（C/C++中使用宏来解决重构升级带来的问题）。  </p><p>Go1.9之前的版本内部定义了新的类型byte和rune，用于指代<code>uint8</code>和<code>int32</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> <span class="keyword">int32</span></span><br></pre></td></tr></table></figure><p>Go1.9之后<code>uint8</code>和<code>int32</code>使用了类型别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span><span class="comment">// 使用 = 号定义后，都会按照等号右边的类型打印、计算</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">类型定义是定义了一个全新的类型的类型。类型别名只是某个类型的小名，并非创造了新的类型：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span>                          <span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">type</span> AliasInt = <span class="keyword">int</span>                     <span class="comment">// 类型别名，支持使用括号，同时起多个别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1 MyInt</span><br><span class="line">fmt.Printf(<span class="string">"a1 type: %T\n"</span>, a1)<span class="comment">//main.MyInt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a2 AliasInt</span><br><span class="line">fmt.Printf(<span class="string">"a2 type: %T\n"</span>, a2)<span class="comment">//int</span></span><br></pre></td></tr></table></figure><h4 id="2-2-不同包下的类型定义"><a href="#2-2-不同包下的类型定义" class="headerlink" title="2.2 不同包下的类型定义"></a>2.2 不同包下的类型定义</h4><p>如下示例，在项目根目录新建文件夹<code>mypack</code>，在该目录建立<code>person.go</code>文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span><span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"run..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main.go中，如下使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"TestGo/mypack"</span><span class="comment">// // TestGo 是 go.mod文件中定义的项目名：module TestGo</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student  mypack.Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">Study</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"study..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s := &amp;Student&#123;&#125;</span><br><span class="line">s.Study()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-不同包下的类型别名"><a href="#2-3-不同包下的类型别名" class="headerlink" title="2.3 不同包下的类型别名"></a>2.3 不同包下的类型别名</h4><p>2.2 中的案例如果将类型定义改为类型别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student = mypack.Person                <span class="comment">// 这时Student的方法就会报错：无法为 Person 添加新的方法</span></span><br></pre></td></tr></table></figure><p>使用方式：必须直接在person文件中直接使用类型别名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span><span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"run..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student = Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Student)</span> <span class="title">Study</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"study..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main中调用别名方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span><span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"run..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student = Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Student)</span> <span class="title">Study</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"study..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-Go的类型系统补充"><a href="#三-Go的类型系统补充" class="headerlink" title="三 Go的类型系统补充"></a>三 Go的类型系统补充</h3><h3 id="3-1-命名类型和未命名类型"><a href="#3-1-命名类型和未命名类型" class="headerlink" title="3.1 命名类型和未命名类型"></a>3.1 命名类型和未命名类型</h3><ul><li>命名类型：Named Type。类型通过标识符、自定义类型表示</li><li>未命名类型：Unamed Type。也称为类型字面量（Type Literal），由预声明类型、关键字、操作符等组合而成，如array、slice、channel、pointer、function、未使用type定义的struct、未使用type定义的interface。 </li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名类型，其类型是 Person</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 未命名类型，其类型是 struct &#123; name string &#125;</span></span><br><span class="line">p := <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-底层类型"><a href="#3-2-底层类型" class="headerlink" title="3.2 底层类型"></a>3.2 底层类型</h3><p>所有类型都有一个底层类型 underlying type，其规则如下：</p><ul><li>预声明类型（Pre-declared types）和类型字面量（type literals）的底层类型是他们自身</li><li>自定义类型<code>type newtype oldtype</code>中newtype的底层类型是逐层递归向下查找的，直到找到oldtype的预声明类型或字面量类型</li></ul><h3 id="3-3-Go中的类型相同"><a href="#3-3-Go中的类型相同" class="headerlink" title="3.3 Go中的类型相同"></a>3.3 Go中的类型相同</h3><p>Go中类型相同的规范：</p><ul><li>命名类型的数据类型相同：声明语句必须完全相同</li><li>未命名类型数据类型相同：类型声明字面量结构相同，且内部元素的类型相同</li><li>命名类型与未命名类型永远不同</li><li>通过类型别名语句声明的两个类型相同。类型别名语法：<code>type T1 = T2</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-标识符与变量</title>
      <link href="/2020/06/16/%E6%A0%87%E8%AF%86%E7%AC%A6%E4%B8%8E%E5%8F%98%E9%87%8F/"/>
      <url>/2020/06/16/%E6%A0%87%E8%AF%86%E7%AC%A6%E4%B8%8E%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一-标识符"><a href="#一-标识符" class="headerlink" title="一 标识符"></a>一 标识符</h2><h4 id="1-1-关键字"><a href="#1-1-关键字" class="headerlink" title="1.1 关键字"></a>1.1 关键字</h4><p>Go现在拥有25个关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if      for     func    case        struct      import               </span><br><span class="line">go      type    chan    defer       default     package</span><br><span class="line">map     const   else    break       select      interface</span><br><span class="line">var     goto    range   return      switch      continue     fallthrough</span><br></pre></td></tr></table></figure><h4 id="1-2-保留字"><a href="#1-2-保留字" class="headerlink" title="1.2 保留字"></a>1.2 保留字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">内建常量：  </span><br><span class="line">        true        false       iota        nil</span><br><span class="line">内建类型：  </span><br><span class="line">        int         int8        int16       int32       int64</span><br><span class="line">        uint        uint8       uint16      uint32      uint64      uintptr</span><br><span class="line">        float32     float64 </span><br><span class="line">        complex128  complex64</span><br><span class="line">bool：      </span><br><span class="line">        byte        rune        string     error</span><br><span class="line">内建函数：   </span><br><span class="line">        make        delete      complex     panic       append      copy    </span><br><span class="line">        close       len         cap        real        imag        new       recover</span><br></pre></td></tr></table></figure><h2 id="二-变量"><a href="#二-变量" class="headerlink" title="二 变量"></a>二 变量</h2><h4 id="2-1-变量声明"><a href="#2-1-变量声明" class="headerlink" title="2.1 变量声明"></a>2.1 变量声明</h4><p>Go变量声明的三种方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span>    <span class="comment">// 声明一个变量，默认为0</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>    <span class="comment">// 声明并初始化，且自动推导类型</span></span><br><span class="line">c := <span class="number">20</span>    <span class="comment">// 初始化，且自动推导</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>:=</code>定义变量只能在函数内部使用，所以经常用var定义全局变量</li><li>Go对已经声明但未使用的变量会在编译阶段报错：<code>** not used</code></li><li>Go中的标识符以字母或者下划线开头，大小写敏感</li><li>Go推荐使用驼峰命名 </li></ul><h4 id="2-2-多变量声明"><a href="#2-2-多变量声明" class="headerlink" title="2.2 多变量声明"></a>2.2 多变量声明</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> a1,b1 <span class="keyword">string</span> = <span class="string">"哼"</span>,<span class="string">"哈"</span></span><br><span class="line"><span class="keyword">var</span> a2,b2 <span class="keyword">int</span> = <span class="number">1</span>,<span class="number">2</span>                             <span class="comment">//类型可以直接省略</span></span><br><span class="line">c,d := <span class="number">1</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">e <span class="keyword">int</span></span><br><span class="line">f <span class="keyword">bool</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="2-3-变量值互换"><a href="#2-3-变量值互换" class="headerlink" title="2.3 变量值互换"></a>2.3 变量值互换</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m,n = n,m<span class="comment">//变量值互换</span></span><br><span class="line">temp,_ = m,n<span class="comment">//匿名变量：变量值互换，且丢弃变量n</span></span><br></pre></td></tr></table></figure><h4 id="2-4-丢弃变量"><a href="#2-4-丢弃变量" class="headerlink" title="2.4 _丢弃变量"></a>2.4 _丢弃变量</h4><p><code>_</code>是个特殊的变量名，任何赋予它的值都会被丢弃。该变量不占用命名空间，也不会分配内存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, b := <span class="number">34</span>, <span class="number">35</span>      <span class="comment">//将值`35`赋予`b`，并同时丢弃`34`：</span></span><br></pre></td></tr></table></figure><h4 id="2-5-声明的注意事项"><a href="#2-5-声明的注意事项" class="headerlink" title="2.5 := 声明的注意事项"></a>2.5 := 声明的注意事项</h4><p>下面是正确的代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in, err := os.Open(file)</span><br><span class="line">out, err := os.Create(file)     <span class="comment">// err已经在上方定义，此处的 err其实是赋值</span></span><br></pre></td></tr></table></figure><p>但是如果在第二行赋值的变量名全部和第一行一致，则编译不通过：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in, err := os.Open(file)</span><br><span class="line">in, err := os.Create(file)     <span class="comment">// 即 := 必须确保至少有一个变量是用于声明</span></span><br></pre></td></tr></table></figure><p><code>:=</code>只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么<code>:=</code>将会在当前词法域重新声明一个新的变量。</p><h4 id="2-6-多数据分组书写"><a href="#2-6-多数据分组书写" class="headerlink" title="2.6 多数据分组书写"></a>2.6 多数据分组书写</h4><p>Go可以使用该方式声明多个数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    i = <span class="number">100</span></span><br><span class="line">    pi = <span class="number">3.1415</span></span><br><span class="line">    prefix = <span class="string">"Go_"</span></span><br><span class="line">)</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">var</span>(</span><br><span class="line">    i <span class="keyword">int</span></span><br><span class="line">    pi <span class="keyword">float32</span></span><br><span class="line">    prefix <span class="keyword">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="三-关键字iota"><a href="#三-关键字iota" class="headerlink" title="三 关键字iota"></a>三 关键字iota</h2><p>关键字iota声明初始值为0，每行递增1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span>            <span class="comment">// 0</span></span><br><span class="line">    b =<span class="literal">iota</span>         <span class="comment">// 1        </span></span><br><span class="line">    c = <span class="literal">iota</span>         <span class="comment">// 2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    d = <span class="literal">iota</span>            <span class="comment">//  0</span></span><br><span class="line">    e <span class="comment">// 1        </span></span><br><span class="line">    f <span class="comment">// 2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果iota在同一行，则值都一样</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    g = <span class="literal">iota</span>            <span class="comment">//0</span></span><br><span class="line">    h,i,j = <span class="literal">iota</span>,<span class="literal">iota</span>,<span class="literal">iota</span>      <span class="comment">// 1,1,1</span></span><br><span class="line">    <span class="comment">// k = 3                    // 此处不能定义缺省常量，会编译错误</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-数据类型</title>
      <link href="/2020/06/16/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/06/16/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一-数据类型分类"><a href="#一-数据类型分类" class="headerlink" title="一 数据类型分类"></a>一 数据类型分类</h2><p>值类型：基本数据类型是Go语言实际的原子，复合数据类型是由不同的方式组合基本类型构造出来的数据类型，如：数组，slice，map，结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">整型    int8,uint               # 基础类型之数字类型</span><br><span class="line">浮点型  float32，float64         # 基础类型之数字类型</span><br><span class="line">复数                            # 基础类型之数字类型</span><br><span class="line">布尔型  bool                    # 基础类型，只能存true&#x2F;false，占据1个字节，不能转换为整型，0和1也不能转换为布尔</span><br><span class="line">字符串  string                  # 基础类型</span><br><span class="line">数组                            # 复合类型 </span><br><span class="line">结构体  struct                  # 复合类型</span><br></pre></td></tr></table></figure><p>引用类型：即保存的是对程序中一个变量的或状态的间接引用，对其修改将影响所有该引用的拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指针    *</span><br><span class="line">切片    slice</span><br><span class="line">字典    map</span><br><span class="line">函数    func</span><br><span class="line">管道    chan</span><br><span class="line">接口    interface</span><br></pre></td></tr></table></figure><p>贴士：Go语言没有字符型，可以使用byte来保存单个字母</p><h2 id="二-零值机制"><a href="#二-零值机制" class="headerlink" title="二 零值机制"></a>二 零值机制</h2><p>Go变量初始化会自带默认值，不像其他语言为空，下面列出各种数据类型对应的0值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>     <span class="number">0</span></span><br><span class="line"><span class="keyword">int8</span>    <span class="number">0</span></span><br><span class="line"><span class="keyword">int32</span>   <span class="number">0</span></span><br><span class="line"><span class="keyword">int64</span>   <span class="number">0</span></span><br><span class="line"><span class="keyword">uint</span>    <span class="number">0x0</span></span><br><span class="line"><span class="keyword">rune</span>    <span class="number">0</span>           <span class="comment">//rune的实际类型是 int32</span></span><br><span class="line"><span class="keyword">byte</span>    <span class="number">0x0</span>         <span class="comment">// byte的实际类型是 uint8</span></span><br><span class="line"><span class="keyword">float32</span> <span class="number">0</span>           <span class="comment">//长度为 4 byte</span></span><br><span class="line"><span class="keyword">float64</span> <span class="number">0</span>           <span class="comment">//长度为 8 byte</span></span><br><span class="line"><span class="keyword">bool</span>    <span class="literal">false</span></span><br><span class="line"><span class="keyword">string</span>  <span class="string">""</span></span><br></pre></td></tr></table></figure><h2 id="三-格式化输出"><a href="#三-格式化输出" class="headerlink" title="三 格式化输出"></a>三 格式化输出</h2><p>常用格式化输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%%%字面量</span><br><span class="line">%b二进制整数值，基数为2，或者是一个科学记数法表示的指数为2的浮点数</span><br><span class="line">%c该值对应的unicode字符</span><br><span class="line">%d十进制数值，基数为10</span><br><span class="line">%e科学记数法e表示的浮点或者复数</span><br><span class="line">%E科学记数法E表示的浮点或者附属</span><br><span class="line">%f标准计数法表示的浮点或者附属</span><br><span class="line">%o8进制度</span><br><span class="line">%p十六进制表示的一个地址值</span><br><span class="line">%s输出字符串或字节数组</span><br><span class="line">%T输出值的类型，注意int32和int是两种不同的类型，编译器不会自动转换，需要类型转换。</span><br><span class="line">%v值的默认格式表示</span><br><span class="line">%+v类似%v，但输出结构体时会添加字段名</span><br><span class="line">%#v值的Go语法表示</span><br><span class="line">%t单词true或false</span><br><span class="line">%q该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示</span><br><span class="line">%x表示为十六进制，使用a-f</span><br><span class="line">%X表示为十六进制，使用A-F</span><br><span class="line">%U表示为Unicode格式：U+1234，等价于&quot;U+%04X&quot;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">user : = User&#123;</span><br><span class="line">    <span class="string">"overnote"</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%%\n"</span>)                   <span class="comment">// %</span></span><br><span class="line">fmt.Printf(<span class="string">"%b\n"</span>, <span class="number">16</span>)               <span class="comment">// 10000</span></span><br><span class="line">fmt.Printf(<span class="string">"%c\n"</span>, <span class="number">65</span>)               <span class="comment">// A</span></span><br><span class="line">fmt.Printf(<span class="string">"%c\n"</span>, <span class="number">0x4f60</span>)           <span class="comment">// 你</span></span><br><span class="line">fmt.Printf(<span class="string">"%U\n"</span>, <span class="string">'你'</span>)              <span class="comment">// U+4f60</span></span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, <span class="string">'你'</span>)              <span class="comment">// 4f60</span></span><br><span class="line">fmt.Printf(<span class="string">"%X\n"</span>, <span class="string">'你'</span>)              <span class="comment">// 4F60</span></span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, <span class="string">'A'</span>)              <span class="comment">// 65</span></span><br><span class="line">fmt.Printf(<span class="string">"%t\n"</span>, <span class="number">1</span> &gt; <span class="number">2</span>)            <span class="comment">// false</span></span><br><span class="line">fmt.Printf(<span class="string">"%e\n"</span>, <span class="number">4396.7777777</span>)     <span class="comment">// 4.396778e+03 默认精度6位</span></span><br><span class="line">fmt.Printf(<span class="string">"%20.3e\n"</span>, <span class="number">4396.7777777</span>) <span class="comment">//            4.397e+03 设置宽度20,精度3,宽度一般用于对齐</span></span><br><span class="line">fmt.Printf(<span class="string">"%E\n"</span>, <span class="number">4396.7777777</span>)     <span class="comment">// 4.396778E+03</span></span><br><span class="line">fmt.Printf(<span class="string">"%f\n"</span>, <span class="number">4396.7777777</span>)     <span class="comment">// 4396.777778</span></span><br><span class="line">fmt.Printf(<span class="string">"%o\n"</span>, <span class="number">16</span>)               <span class="comment">// 20</span></span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;)         <span class="comment">// 0xc000016110</span></span><br><span class="line">fmt.Printf(<span class="string">"Hello %s\n"</span>, <span class="string">"World"</span>)    <span class="comment">// Hello World</span></span><br><span class="line">fmt.Printf(<span class="string">"Hello %q\n"</span>, <span class="string">"World"</span>)    <span class="comment">// Hello "World"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, <span class="number">3.0</span>)              <span class="comment">// float64</span></span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, user)             <span class="comment">// &#123;overnote 1&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, user)            <span class="comment">// &#123;Name:overnote Age:1&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, user)            <span class="comment">// main.User&#123;Name:"overnote", Age:1&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-运算符</title>
      <link href="/2020/06/16/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2020/06/16/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="一-运算符"><a href="#一-运算符" class="headerlink" title="一 运算符"></a>一 运算符</h2><h4 id="1-1-运算符汇总"><a href="#1-1-运算符汇总" class="headerlink" title="1.1 运算符汇总"></a>1.1 运算符汇总</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">算术运算符：+-*&#x2F;%++--</span><br><span class="line">关系运算符：&#x3D;&#x3D;!&#x3D;&lt;&#x3D;&gt;&#x3D;&lt;&gt;</span><br><span class="line">逻辑运算符：!&amp;&amp;||</span><br><span class="line">位运算：&amp;（按位与）|（按位或）^（按位取反）&lt;&lt;（左移）&gt;&gt;（右移）</span><br><span class="line">赋值运算符：&#x3D;+&#x3D;-&#x3D;*&#x3D;&#x2F;&#x3D;%&#x3D;&lt;&lt;&#x3D;&gt;&gt;&#x3D;&amp;&#x3D;^&#x3D;|&#x3D;</span><br><span class="line">其他运算符：&amp;（取地址）*（取指针值） &lt;-（Go Channel相关运算符）</span><br></pre></td></tr></table></figure><h4 id="1-2-自增、自减"><a href="#1-2-自增、自减" class="headerlink" title="1.2 自增、自减"></a>1.2 自增、自减</h4><p>Go中只有<code>后--</code>和<code>后++</code>，且自增自减不能用于表达式中，只能独立使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = i++           <span class="comment">// 错误用法</span></span><br><span class="line"><span class="keyword">if</span> i++ &gt; <span class="number">0</span> &#123;&#125;     <span class="comment">// 错误用法</span></span><br><span class="line">i++               <span class="comment">// 正确用法</span></span><br></pre></td></tr></table></figure><h4 id="1-3-位运算"><a href="#1-3-位运算" class="headerlink" title="1.3 位运算"></a>1.3 位运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;     按位与，参与运算的两个数二进制位相与：同时为1，结果为1，否则为0</span><br><span class="line">|     按位或，参与运算的两个数二进制位相或：有一个为1，结果为1，否则为0</span><br><span class="line">^     按位异或：二进位不同，结果为1，否则为0</span><br><span class="line">&lt;&lt;    按位左移：二进位左移若干位，高位丢弃，低位补0，左移n位其实就是乘以2的n次方</span><br><span class="line">&gt;&gt;    按位右移：二进位右移若干位，右移n位其实就是除以2的n次方</span><br></pre></td></tr></table></figure><h2 id="二-优先级"><a href="#二-优先级" class="headerlink" title="二 优先级"></a>二 优先级</h2><p><img src="../images/go/01-01.svg" alt=""></p><h2 id="三-进制转换"><a href="#三-进制转换" class="headerlink" title="三 进制转换"></a>三 进制转换</h2><h4 id="1-1-常见进制"><a href="#1-1-常见进制" class="headerlink" title="1.1 常见进制"></a>1.1 常见进制</h4><ul><li>二进制：只有0和1，Go中不能直接使用二进制表示整数</li><li>八进制：0-7，以数字0开头</li><li>十进制：0-9</li><li>十六进制：0-9以及A-F，以0X开头，A-F以及X不区分大小写</li></ul><h4 id="1-2-任意进制转换为十进制"><a href="#1-2-任意进制转换为十进制" class="headerlink" title="1.2 任意进制转换为十进制"></a>1.2 任意进制转换为十进制</h4><p>二进制转十进制：  </p><blockquote><p>从最低位开始，每个位上数乘以2（位数-1）次方然后求和<br>1011 = 1*2<sup>0</sup> + 1*2<sup>1</sup> + 0*2<sup>2</sup> + 1*2<sup>3</sup> = 11  </p></blockquote><p>八进制转十进制：  </p><blockquote><p>从最低位开始，每个位上数乘以8（位数-1）次方然后求和<br>0123 = 3*8<sup>0</sup> + 2*8<sup>1</sup> + 1*8<sup>2</sup> + 0*8<sup>3</sup> = 83</p></blockquote><p>其他进制转十进制同理。</p><h4 id="1-3-十进制转其他进制"><a href="#1-3-十进制转其他进制" class="headerlink" title="1.3 十进制转其他进制"></a>1.3 十进制转其他进制</h4><p>十进制转二进制：  </p><blockquote><p>不断除以2，直到0为止,余数倒过来即可，如图计算28转换为二进制11100</p></blockquote><p><img src="../images/go/01-02.svg" alt=""></p><p>十进制转八进制：不断除以8，直到0为止，余数倒过来即可。  </p><p>十进制转十六进制：不断除以16，直到0为止，余数倒过来即可。</p><h4 id="1-4-其他进制互转"><a href="#1-4-其他进制互转" class="headerlink" title="1.4 其他进制互转"></a>1.4 其他进制互转</h4><ul><li>二进制转换八进制：将二进制数从低位开始，每三位一组，转换成八进制数即可</li><li>二进制转十六进制：将二进制数从低位开始，每四位一组，转换成十六进制数即可</li><li>八进制转换二进制：将八进制数每1位转换成一个3位的二进制数（首位0除外）</li><li>十六进制转二进制：将十六进制每1位转换成对应的一个4位的二进制数即可  </li></ul><h2 id="四-计算机运算原理"><a href="#四-计算机运算原理" class="headerlink" title="四 计算机运算原理"></a>四 计算机运算原理</h2><p>计算机常见的术语：</p><ul><li>bit：比特，代表1个二进制位，一个位只能是0或者1</li><li>Byte：字节，代表8个二进制位，计算机中存储的最小单元是字节</li><li>WORD：双字节，即2个字节，16位</li><li>DWORD：两个WORD，即4个字节，32位</li></ul><p>一些常用单位：</p><ul><li>1b：1bit，1位</li><li>1Kb：1024bit，即1024位</li><li>1Mb：1024*1024bit</li><li>1B：1Byte，1字节，8位</li><li>1KB：1024B</li><li>1MB：1024K</li></ul><p>对于有符号数而言，二进制的最高为是符号位：0表示正数，1表示负数，比如 1在二进制中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1  二进制位：0000  0001</span><br><span class="line">-1 二进制位：1000  0001</span><br></pre></td></tr></table></figure><p>正数的原码、反码、补码都一样，负数的反码=原码符号位不变，其他位取反，补码是反码+1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">         1              -1</span><br><span class="line">原码  0000  0001        1000  0001</span><br><span class="line">反码  0000  0001        1111  1110</span><br><span class="line">补码  0000  0001        1111  1111</span><br></pre></td></tr></table></figure><p>常见理解：</p><ul><li>0的反码补码都是0</li><li>计算机中是以补码形式运算的</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-流程控制</title>
      <link href="/2020/06/16/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2020/06/16/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一-流程控制之-条件语句"><a href="#一-流程控制之-条件语句" class="headerlink" title="一 流程控制之-条件语句"></a>一 流程控制之-条件语句</h2><h4 id="1-1-判断语句-if"><a href="#1-1-判断语句-if" class="headerlink" title="1.1 判断语句 if"></a>1.1 判断语句 if</h4><p><code>if</code>判断示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化与判断写在一起： if a := 10; a == 10</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="string">'3'</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if</code>的特殊写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := Connect(); err != <span class="literal">nil</span> &#123;         <span class="comment">// 这里的 err!=nil 才是真正的if判断表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-分支语句-switch"><a href="#1-2-分支语句-switch" class="headerlink" title="1.2 分支语句 switch"></a>1.2 分支语句 switch</h4><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> num &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span>:                          <span class="comment">// case 中可以是表达式</span></span><br><span class="line">      fmt.Println(<span class="string">"111"</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      fmt.Println(<span class="string">"222"</span>)</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(<span class="string">"000"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贴士：</p><ul><li>Go保留了<code>break</code>，用来跳出switch语句，上述案例的分支中默认就书写了该关键字</li><li>Go也提供<code>fallthrough</code>，代表不跳出switch，后面的语句无条件执行</li></ul><h2 id="二-流程控制之-循环语句"><a href="#二-流程控制之-循环语句" class="headerlink" title="二 流程控制之-循环语句"></a>二 流程控制之-循环语句</h2><h4 id="2-1-for循环"><a href="#2-1-for循环" class="headerlink" title="2.1 for循环"></a>2.1 for循环</h4><p>Go只支持for一种循环语句，但是可以对应很多场景：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统的for循环</span></span><br><span class="line"><span class="keyword">for</span> init;condition;post&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环简化</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> ; ; i++ &#123;</span><br><span class="line">   <span class="keyword">if</span>(i &gt; <span class="number">10</span>)&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似while循环</span></span><br><span class="line"><span class="keyword">for</span> condition &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 死循环</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for range:一般用于遍历数组、切片、字符串、map、管道</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-跳出循环"><a href="#2-2-跳出循环" class="headerlink" title="2.2 跳出循环"></a>2.2 跳出循环</h4><p>常用的跳出循环关键字：</p><ul><li><code>break</code>用于函数内跳出当前<code>for</code>、<code>switch</code>、<code>select</code>语句的执行</li><li><code>continue</code>用于跳出<code>for</code>循环的本次迭代。  </li><li><code>goto</code>可以退出多层循环</li></ul><p>break跳出循环案例(continue同下)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OuterLoop:</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">         <span class="keyword">switch</span> j &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">               fmt.Println(i,j)</span><br><span class="line">               <span class="keyword">break</span> OuterLoop</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">               fmt.Println(i,j)</span><br><span class="line">               <span class="keyword">break</span> OuterLoop</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>goto跳出多重循环案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x:=<span class="number">0</span>; x&lt;<span class="number">10</span>; x++ &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">for</span> y:=<span class="number">0</span>; y&lt;<span class="number">10</span>; x++ &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> y==<span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> breakHere</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">breakHere:</span><br><span class="line">   fmt.Println(<span class="string">"break"</span>)</span><br></pre></td></tr></table></figure><p>贴士：goto也可以用来统一错误处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">goto</span> onExit</span><br><span class="line">&#125;</span><br><span class="line">onExit:</span><br><span class="line">   fmt.Pritln(err)</span><br><span class="line">   exitProcess()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-指针</title>
      <link href="/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-3-%E6%8C%87%E9%92%88/"/>
      <url>/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-3-%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="一-指针"><a href="#一-指针" class="headerlink" title="一 指针"></a>一 指针</h2><h3 id="1-1-指针的创建"><a href="#1-1-指针的创建" class="headerlink" title="1.1 指针的创建"></a>1.1 指针的创建</h3><p>Go保留了指针，代表某个内存地址，默认值为 <code>nil</code> ，使用 <code>&amp;</code> 取变量地址，通过 <code>*</code> 访问目标对象。  </p><p>简单示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">"&amp;a="</span>, &amp;a)<span class="comment">// 0xc000096008 一个十六进制数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = &amp;a</span><br><span class="line">fmt.Println(<span class="string">"*p="</span>, *p)<span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>Go同样支持多级指针，如 <code>**T</code></li><li>空指针：声明但未初始化的指针  </li><li>野指针：引用了无效地址的指针，如：<code>var p *int = 0</code>，<code>var p *int = 0xff00</code>(超出范围)</li><li>Go中直接使用<code>.</code>访问目标成员</li></ul><h3 id="1-2-指针使用示例：实现变量值交换"><a href="#1-2-指针使用示例：实现变量值交换" class="headerlink" title="1.2 指针使用示例：实现变量值交换"></a>1.2 指针使用示例：实现变量值交换</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(p1,p2 *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">*p1,*p2 = *p2,*p1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-结构体指针"><a href="#1-3-结构体指针" class="headerlink" title="1.3 结构体指针"></a>1.3 结构体指针</h3><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> u = User&#123;</span><br><span class="line">name:<span class="string">"lisi"</span>,</span><br><span class="line">age: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">p := &amp;u</span><br><span class="line">fmt.Println(u.name)<span class="comment">//输出李四</span></span><br><span class="line">fmt.Println(p.name)<span class="comment">//输出李四</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-Go不支持指针运算"><a href="#1-4-Go不支持指针运算" class="headerlink" title="1.4 Go不支持指针运算"></a>1.4 Go不支持指针运算</h3><p>由于垃圾回收机制的存在，指针运算造成许多困扰，所以Go直接禁止了指针运算</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">1</span></span><br><span class="line">p := &amp;a</span><br><span class="line">p++        <span class="comment">//报错：non-numeric type *int</span></span><br></pre></td></tr></table></figure><h3 id="1-5-new-函数使用"><a href="#1-5-new-函数使用" class="headerlink" title="1.5 new()函数使用"></a>1.5 new()函数使用</h3><p>new()函数可以在 heap堆 区申请一片内存地址空间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">bool</span></span><br><span class="line">p = <span class="built_in">new</span>(<span class="keyword">bool</span>)</span><br><span class="line">fmt.Println(*p)<span class="comment">// false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-字符串</title>
      <link href="/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-2-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-2-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="一-字符"><a href="#一-字符" class="headerlink" title="一 字符"></a>一 字符</h2><p>Golang 中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存，且使用单引号包裹。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 <span class="keyword">byte</span> = <span class="string">'a'</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="keyword">byte</span> = <span class="string">'0'</span></span><br><span class="line">fmt.Println(<span class="string">"c1="</span>, c1)<span class="comment">//输出 97   </span></span><br><span class="line">fmt.Println(<span class="string">"c2="</span>, c2)<span class="comment">//输出48</span></span><br><span class="line">fmt.Printf(<span class="string">"c1=%c,c2=%c\n"</span>, c1, c2)    <span class="comment">//输出原值 a 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//var c3 byte = '北'</span></span><br><span class="line"><span class="comment">//fmt.Printf("c3=%c", c3)// 溢出错误:overflows byte</span></span><br></pre></td></tr></table></figure><p>贴士：</p><ul><li>字符类型也可以用<code>d%</code>打印为整型</li><li>如果我们保存的字符在 ASCII 表的,比如[0-1, a-z,A-Z..]直接可以保存到 byte</li><li>如果我们保存的字符对应码值大于 255,这时我们可以考虑使用 int 类型保存</li><li>如果我们需要安装字符的方式输出，这时我们需要格式化输出，即 fmt.Printf(“%c”, c1)</li><li>字符可以和整型进行运算</li></ul><h2 id="二-字符串"><a href="#二-字符串" class="headerlink" title="二 字符串"></a>二 字符串</h2><p>传统的字符串是由字符组成的，而Go的字符串是由单个字节连接起来的，即Go字符串是一串固定长度的字符连接起来的字符序列。  </p><p>字符串在Go语言中是基本类型，内容在初始化后不能修改。  </p><p>Go中的字符串都是采用UTF-8字符集编码，使用一对双引号<code>&quot;&quot;</code>或反引号<code>``</code>定义。<code>``</code>可以额外解析换行，即其没有字符转义功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 <span class="keyword">string</span></span><br><span class="line">str1 = <span class="string">"Hello "</span></span><br><span class="line">str2 := <span class="string">" World!"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(str1[<span class="number">0</span>])     <span class="comment">// 输出字符串第一个字符 72</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(str1))   <span class="comment">// 输出长度 6</span></span><br><span class="line">fmt.Println(str1 + str2) <span class="comment">// 输出不带空格的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串不可变，编译报错： cannot assign to 因为</span></span><br><span class="line"><span class="comment">// str1[0] = 'c'</span></span><br></pre></td></tr></table></figure><p>由于Go中的字符串不可直接改变，可以使用下列两种方式进行修改：</p><p>方式一：通过转换为字节数组<code>[]byte</code>类型，构造一个临时字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">strTemp := []<span class="keyword">byte</span>(str)</span><br><span class="line">fmt.Println(<span class="string">"strTemp="</span>, strTemp)<span class="comment">// [104 101 108 108 111]</span></span><br><span class="line"></span><br><span class="line">strTemp[<span class="number">0</span>] = <span class="string">'c'</span></span><br><span class="line">strResult := <span class="keyword">string</span>(strTemp)</span><br><span class="line">fmt.Println(<span class="string">"strResult="</span>, strResult)<span class="comment">// strResult= cello</span></span><br></pre></td></tr></table></figure><p>方式二：使用切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello"</span></span><br><span class="line">str = <span class="string">"c"</span>+ str[<span class="number">1</span>:]<span class="comment">// 1: 表示从第1位开始到最后</span></span><br></pre></td></tr></table></figure><p>Go和Java等语言一样，字符串默认是不可变的，这样保证了线程安全，大家使用的都是只读对象，无须加锁，且能很方便的共享内存，不必使用写时复制。</p><h2 id="三-字符串常用操作"><a href="#三-字符串常用操作" class="headerlink" title="三 字符串常用操作"></a>三 字符串常用操作</h2><h4 id="3-1-len-函数与字符串遍历"><a href="#3-1-len-函数与字符串遍历" class="headerlink" title="3.1 len()函数与字符串遍历"></a>3.1 len()函数与字符串遍历</h4><p>len()函数是go语言的内建函数，可以用来获取字符串、切片、通道等的长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unicode/utf8"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">str1 := <span class="string">"hello world"</span></span><br><span class="line">str2 := <span class="string">"你好，"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(str1))<span class="comment">// 11</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(str2))<span class="comment">// 9</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(str2))<span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个函数输出11很容易理解，第二个函数却输出了9，理论上我们会认为应该是3才对。这是因为Go的字符串都是以UTF-8格式保存，每个中文占据3个字节。Go中计算UTF-8字符串格式的长度应该使用<code>utf8.RuneCountInString</code>。</p><p>字符串遍历方式一：使用字节数组，注意每个中文在UTF-8中占据3个字节</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">fmt.Println(i,str[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串遍历方式二：range关键字只是第一种遍历方式的简写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"你好"</span></span><br><span class="line"><span class="keyword">for</span> i,ch := <span class="keyword">range</span> str &#123;</span><br><span class="line">fmt.Println(i,ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：由于上述len()函数本身原因，Unicode字符遍历需要使用range。</p><h4 id="3-2-string-函数类型转换"><a href="#3-2-string-函数类型转换" class="headerlink" title="3.2 string()函数类型转换"></a>3.2 string()函数类型转换</h4><p>go的内建函数 <code>string()</code>可以将其他类型转变为字符串类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num := <span class="number">12</span></span><br><span class="line">fmt.Printf(<span class="string">"%T \n"</span>, <span class="keyword">string</span>(num))<span class="comment">// string</span></span><br></pre></td></tr></table></figure><h4 id="3-3-字符串连接"><a href="#3-3-字符串连接" class="headerlink" title="3.3 字符串连接"></a>3.3 字符串连接</h4><p>使用<code>+</code>能够连接字符串。但是该操作并不高效（因为字符串在Go中是基本类型，每次拼接都是拷贝了内存！）。Go1.10提供了类似Java的StringBuilder机制来进行高效字符串连接：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">str1 := <span class="string">"hello "</span></span><br><span class="line">str2 := <span class="string">" world"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建字节缓冲</span></span><br><span class="line"><span class="keyword">var</span> stringBuilder bytes.Buffer</span><br><span class="line"></span><br><span class="line"><span class="comment">//把字符串写入缓冲</span></span><br><span class="line">stringBuilder.WriteString(str1)</span><br><span class="line">stringBuilder.WriteString(str2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//将缓冲以字符串形式输出</span></span><br><span class="line">fmt.Println(stringBuilder.String())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在1.10版本前，可以使用bytes.Buffer拼接字符串（因为字符串其实是字节数组）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">buf.WriteString(<span class="string">"hello"</span>)</span><br><span class="line">fmt.Println(buf.String())</span><br></pre></td></tr></table></figure><h2 id="四-strings包相关函数"><a href="#四-strings包相关函数" class="headerlink" title="四 strings包相关函数"></a>四 strings包相关函数</h2><p>strings包提供了字符串的一些常见操作函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找s在字符串str中的索引</span></span><br><span class="line">Index(str, s <span class="keyword">string</span>) <span class="keyword">int</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//判断str是否包含s</span></span><br><span class="line">Contains(str, s <span class="keyword">string</span>) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过字符串str连接切片 s</span></span><br><span class="line">Join(s []<span class="keyword">string</span>, str <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//替换字符串str中old字符串为new字符串，n表示替换的次数，小于0全部替换</span></span><br><span class="line">Replace(str,old,<span class="built_in">new</span> <span class="keyword">string</span>,n <span class="keyword">int</span>) <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串str按照s分割，返回切片</span></span><br><span class="line">Splite(str,s <span class="keyword">string</span>)[]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除头部、尾部指定的字符串</span></span><br><span class="line">Trim(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除空格，返回切片</span></span><br><span class="line">Fields(s <span class="keyword">string</span>) []<span class="keyword">string</span></span><br></pre></td></tr></table></figure><h2 id="五-strconv包的字符串转换函数"><a href="#五-strconv包的字符串转换函数" class="headerlink" title="五 strconv包的字符串转换函数"></a>五 strconv包的字符串转换函数</h2><p>在Java中遇到 <code>&quot;你好&quot; + 123</code>会将 <code>+</code>转变为连接符。而Go语言要求 <code>+</code> 号两边数据的数据类型必须一致，这使得类似的操作变得比较不便，Go提供了strconv包用于字符串与基本类型之间的转换，常用函数有Append、Format、Parse。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Append 系列函数将整数等转换为字符串后，添加到现有的字节数组中</span></span><br><span class="line">str1 := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">str1 = strconv.AppendInt(str1, <span class="number">4567</span>, <span class="number">10</span>)</span><br><span class="line">str1 = strconv.AppendBool(str1, <span class="literal">false</span>)</span><br><span class="line">str1 = strconv.AppendQuote(str1, <span class="string">"abcdefg"</span>)</span><br><span class="line">str1 = strconv.AppendQuoteRune(str1, <span class="string">'单'</span>)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(str1))<span class="comment">// 4567false"abcdefg"'单'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Format 系列函数把其他类型的转换为字符串</span></span><br><span class="line">a := strconv.FormatBool(<span class="literal">false</span>)</span><br><span class="line">b := strconv.FormatFloat(<span class="number">123.23</span>, <span class="string">'g'</span>, <span class="number">12</span>, <span class="number">64</span>)</span><br><span class="line">c := strconv.FormatInt(<span class="number">1234</span>, <span class="number">10</span>)</span><br><span class="line">d := strconv.FormatUint(<span class="number">12345</span>, <span class="number">10</span>)</span><br><span class="line">e := strconv.Itoa(<span class="number">1023</span>)</span><br><span class="line">fmt.Println(a, b, c, d, e)<span class="comment">// false 123.23 1234 12345 1023</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse 系列函数把字符串转换为其他类型</span></span><br><span class="line">f, _ := strconv.ParseBool(<span class="string">"false"</span>)</span><br><span class="line">g, _ := strconv.ParseFloat(<span class="string">"123.23"</span>, <span class="number">64</span>)</span><br><span class="line">h, _ := strconv.ParseInt(<span class="string">"1234"</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">i, _ := strconv.ParseUint(<span class="string">"12345"</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">j, _ := strconv.Atoi(<span class="string">"1023"</span>)</span><br><span class="line">fmt.Println(f, g, h, j, i, j)<span class="comment">// false 123.23 1234 1023 12345 1023</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-常量</title>
      <link href="/2020/06/16/%E5%B8%B8%E9%87%8F/"/>
      <url>/2020/06/16/%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一-常量"><a href="#一-常量" class="headerlink" title="一 常量"></a>一 常量</h2><p>常量：在编译阶段就确定下来的值，程序运行时无法改变。   </p><p>定义方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A = <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> PI <span class="keyword">float32</span> = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span> &lt;&lt; <span class="number">3</span><span class="comment">//常量与表达式</span></span><br></pre></td></tr></table></figure><p>错误写法：常量赋值是一个编译期行为，右边的值不能出现在运行时才能得到结果的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HOME = os.GetEnv(<span class="string">"HOME"</span>)</span><br></pre></td></tr></table></figure><h2 id="二-无类型常量"><a href="#二-无类型常量" class="headerlink" title="二 无类型常量"></a>二 无类型常量</h2><p>一个常量可以有任意一个确定的基础类型，例如int或float64，但是许多常量并没有一个明确的基础类型。  </p><p>无类型常量的作用：</p><ul><li>编译器会为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算，可以认为至少有256bit的运算精度</li><li>无类型的常量可以直接用于更多的表达式而不需要显式的类型转换</li></ul><p>示例：math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float32</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">float64</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> z <span class="keyword">complex128</span> = math.Pi</span><br></pre></td></tr></table></figure><p>如果math.Pi被确定为特定类型，比如float64，那么结果精度可能会不一样，同时对于需要float32或complex128类型值的地方则会强制需要一个明确的类型转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi64 <span class="keyword">float64</span> = math.Pi</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">float32</span> = <span class="keyword">float32</span>(Pi64)</span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">float64</span> = Pi64</span><br><span class="line"><span class="keyword">var</span> z <span class="keyword">complex128</span> = <span class="keyword">complex128</span>(Pi64)</span><br></pre></td></tr></table></figure><p>对于常量面值，不同的写法可能会对应不同的类型。例如0、0.0、0i和<code>\u0000</code>虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，true和false也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。</p><p>前面说过除法运算符/会根据操作数的类型生成对应类型的结果。因此，不同写法的常量除法表达式可能对应不同的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="number">212</span></span><br><span class="line">fmt.Println((f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>)     <span class="comment">// "100"; (f - 32) * 5 is a float64</span></span><br><span class="line">fmt.Println(<span class="number">5</span> / <span class="number">9</span> * (f - <span class="number">32</span>))     <span class="comment">// "0";   5/9 is an untyped integer, 0</span></span><br><span class="line">fmt.Println(<span class="number">5.0</span> / <span class="number">9.0</span> * (f - <span class="number">32</span>)) <span class="comment">// "100"; 5.0/9.0 is an untyped float</span></span><br></pre></td></tr></table></figure><p>只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语句，或者出现在有明确类型的变量声明的右边，如下面的其余三行语句，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="number">3</span> + <span class="number">0i</span> <span class="comment">// untyped complex -&gt; float64</span></span><br><span class="line">f = <span class="number">2</span>                  <span class="comment">// untyped integer -&gt; float64</span></span><br><span class="line">f = <span class="number">1e123</span>              <span class="comment">// untyped floating-point -&gt; float64</span></span><br><span class="line">f = <span class="string">'a'</span>                <span class="comment">// untyped rune -&gt; float64</span></span><br></pre></td></tr></table></figure><p>上面的语句相当于:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="keyword">float64</span>(<span class="number">3</span> + <span class="number">0i</span>)</span><br><span class="line">f = <span class="keyword">float64</span>(<span class="number">2</span>)</span><br><span class="line">f = <span class="keyword">float64</span>(<span class="number">1e123</span>)</span><br><span class="line">f = <span class="keyword">float64</span>(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure><p>无论是隐式或显式转换，将一种类型转换为另一种类型都要求目标可以表示原始值。对于浮点数和复数，可能会有舍入处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">deadbeef = <span class="number">0xdeadbeef</span> <span class="comment">// untyped int with value 3735928559</span></span><br><span class="line">a = <span class="keyword">uint32</span>(deadbeef)  <span class="comment">// uint32 with value 3735928559</span></span><br><span class="line">b = <span class="keyword">float32</span>(deadbeef) <span class="comment">// float32 with value 3735928576 (rounded up)</span></span><br><span class="line">c = <span class="keyword">float64</span>(deadbeef) <span class="comment">// float64 with value 3735928559 (exact)</span></span><br><span class="line">d = <span class="keyword">int32</span>(deadbeef)   <span class="comment">// compile error: constant overflows int32</span></span><br><span class="line">e = <span class="keyword">float64</span>(<span class="number">1e309</span>)    <span class="comment">// compile error: constant overflows float64</span></span><br><span class="line">f = <span class="keyword">uint</span>(<span class="number">-1</span>)          <span class="comment">// compile error: constant underflows uint</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型，就像下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span>      <span class="comment">// untyped integer;        implicit int(0)</span></span><br><span class="line">r := <span class="string">'\000'</span> <span class="comment">// untyped rune;           implicit rune('\000')</span></span><br><span class="line">f := <span class="number">0.0</span>    <span class="comment">// untyped floating-point; implicit float64(0.0)</span></span><br><span class="line">c := <span class="number">0i</span>     <span class="comment">// untyped complex;        implicit complex128(0i)</span></span><br></pre></td></tr></table></figure><p>注意有一点不同：无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。<br>如果不知道浮点数类型的内存大小是很难写出正确的数值算法的，因此Go语言不存在整型类似的不确定内存大小的浮点数和复数类型。  </p><p>如果要给变量一个不同的类型，我们必须显式地将无类型的常量转化为所需的类型，或给声明的变量指定明确的类型，像下面例子这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="keyword">int8</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int8</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>当尝试将这些无类型的常量转为一个接口值时（见第7章），这些默认类型将显得尤为重要，因为要靠它们明确接口对应的动态类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, <span class="number">0</span>)      <span class="comment">// "int"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, <span class="number">0.0</span>)    <span class="comment">// "float64"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, <span class="number">0i</span>)     <span class="comment">// "complex128"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, <span class="string">'\000'</span>) <span class="comment">// "int32" (rune)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-反射2</title>
      <link href="/2020/05/09/%E5%8F%8D%E5%B0%84-2-%E5%BA%94%E7%94%A8/"/>
      <url>/2020/05/09/%E5%8F%8D%E5%B0%84-2-%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一-反射的使用"><a href="#一-反射的使用" class="headerlink" title="一 反射的使用"></a>一 反射的使用</h2><h4 id="1-1-反射操作简单数据类型"><a href="#1-1-反射操作简单数据类型" class="headerlink" title="1.1 反射操作简单数据类型"></a>1.1 反射操作简单数据类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="keyword">int64</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置值：指针传递</span></span><br><span class="line">ptrValue := reflect.ValueOf(&amp;num)</span><br><span class="line">newValue := ptrValue.Elem()                         <span class="comment">// Elem()用于获取原始值的反射对象</span></span><br><span class="line">fmt.Println(<span class="string">"type："</span>, newValue.Type())<span class="comment">// int64</span></span><br><span class="line">fmt.Println(<span class="string">" can set："</span>, newValue.CanSet())<span class="comment">// true</span></span><br><span class="line">newValue.SetInt(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取值：值传递</span></span><br><span class="line">rValue := reflect.ValueOf(num)</span><br><span class="line">fmt.Println(rValue.Int())<span class="comment">// 方式一：200</span></span><br><span class="line">fmt.Println(rValue.Interface().(<span class="keyword">int64</span>))<span class="comment">// 方式二：200</span></span><br></pre></td></tr></table></figure><h4 id="1-2-反射进行类型推断"><a href="#1-2-反射进行类型推断" class="headerlink" title="1.2 反射进行类型推断"></a>1.2 反射进行类型推断</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u := &amp;user&#123;</span><br><span class="line">Name: <span class="string">"Ruyue"</span>,</span><br><span class="line">Age:  <span class="number">100</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(reflect.TypeOf(u))<span class="comment">// *main.user</span></span><br><span class="line">fmt.Println(reflect.TypeOf(*u))<span class="comment">// main.user</span></span><br><span class="line">fmt.Println(reflect.TypeOf(*u).Name())<span class="comment">// user</span></span><br><span class="line">fmt.Println(reflect.TypeOf(*u).Kind())<span class="comment">// struct</span></span><br></pre></td></tr></table></figure><h4 id="1-3-反射操作指针"><a href="#1-3-反射操作指针" class="headerlink" title="1.3 反射操作指针"></a>1.3 反射操作指针</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u := &amp;user&#123;</span><br><span class="line">Name: <span class="string">"Ruyue"</span>,</span><br><span class="line">Age:  <span class="number">100</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typeOfUser = reflect.TypeOf(u).Elem()</span><br><span class="line">fmt.Println(<span class="string">"element name: "</span>, typeOfUser.Name())<span class="comment">// user</span></span><br><span class="line">fmt.Println(<span class="string">"element kind: "</span>, typeOfUser.Kind())<span class="comment">// struct</span></span><br></pre></td></tr></table></figure><h4 id="1-4-反射操作结构体"><a href="#1-4-反射操作结构体" class="headerlink" title="1.4 反射操作结构体"></a>1.4 反射操作结构体</h4><p>反射可以获取结构体的详细信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age  <span class="keyword">int</span> <span class="string">`json:"age" id:"100"`</span> <span class="comment">// 结构体标签</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s := user&#123;</span><br><span class="line">Name: <span class="string">"zs"</span>,</span><br><span class="line">Age:  <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typeOfUser := reflect.TypeOf(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字段用法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; typeOfUser.NumField(); i++ &#123;        <span class="comment">// NumField 当前结构体有多少个字段</span></span><br><span class="line">fieldType := typeOfUser.Field(i)                <span class="comment">// 获取每个字段</span></span><br><span class="line">fmt.Println(fieldType.Name, fieldType.Tag)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> userAge, ok := typeOfUser.FieldByName(<span class="string">"Age"</span>); ok &#123;</span><br><span class="line">fmt.Println(userAge)<span class="comment">// &#123;Age  int json:"age" id:"100" 16 [1] false&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法用法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; typeOfUser.NumMethod(); i++ &#123;</span><br><span class="line">fieldType := typeOfUser.Method(i)                <span class="comment">// 获取每个字段</span></span><br><span class="line">fmt.Println(fieldType.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-反射调用函数与方法"><a href="#二-反射调用函数与方法" class="headerlink" title="二 反射调用函数与方法"></a>二 反射调用函数与方法</h2><h4 id="2-1-使用反射调用函数"><a href="#2-1-使用反射调用函数" class="headerlink" title="2.1 使用反射调用函数"></a>2.1 使用反射调用函数</h4><p>如果反射值对象(reflect.Value)中值的类型为函数时，可以通过 reflect.Value调用该 函数。使用反射调用函数时，需要将参数使用反射值对象的切片 口reflect.Value 构造后传入 Call()方法中 ， 调用完成时，函数的返回值通过 []reflect.Value 返回 。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"name is %s, age is %d \n"</span>, name, age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">funcValue := reflect.ValueOf(add)</span><br><span class="line">params := []reflect.Value&#123;reflect.ValueOf(<span class="string">"lisi"</span>), reflect.ValueOf(<span class="number">20</span>)&#125;</span><br><span class="line"></span><br><span class="line">reList := funcValue.Call(params)</span><br><span class="line">fmt.Println(reList)<span class="comment">// 函数返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-反射调用方法"><a href="#2-2-反射调用方法" class="headerlink" title="2.2 反射调用方法"></a>2.2 反射调用方法</h3><p>方法的调用是需要接收者的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">ShowName</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(u.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">AddAge</span><span class="params">(addNum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"age add result:"</span>, u.Age + addNum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">u := &amp;user&#123;<span class="string">"lisi"</span>, <span class="number">20</span>&#125;</span><br><span class="line">v := reflect.ValueOf(u)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用无参方法</span></span><br><span class="line">methodV := v.MethodByName(<span class="string">"ShowName"</span>)</span><br><span class="line">methodV.Call(<span class="literal">nil</span>)<span class="comment">// 或者传递一个空切片也可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用有参方法</span></span><br><span class="line">methodV2 := v.MethodByName(<span class="string">"AddAge"</span>)</span><br><span class="line">args := []reflect.Value&#123;reflect.ValueOf(<span class="number">30</span>)&#125;<span class="comment">//</span></span><br><span class="line">methodV2.Call(args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-反射-1</title>
      <link href="/2020/05/03/%E5%8F%8D%E5%B0%84-1-%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/05/03/%E5%8F%8D%E5%B0%84-1-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一-反射简介"><a href="#一-反射简介" class="headerlink" title="一 反射简介"></a>一 反射简介</h2><p>反射是指在程序运行期对程序本身进行访问和修改的能力，即可以在运行时动态获取变量的各种信息，比如变量的类型（type），类别（kind），如果是结构体变量，还可以获取到结构体本身的信息（字段与方法），通过反射，还可以修改变量的值，可以调用关联的方法。  </p><p>反射常用在框架的开发上，一些常见的案例，如JSON序列化时候tag标签的产生，适配器函数的制作等，都需要用到反射。反射的两个使用常见使用场景：</p><ul><li>不知道函数的参数类型：没有约定好参数、传入类型很多，此时类型不能统一表示，需要反射</li><li>不知道调用哪个函数：比如根据用户的输入来决定调用特定函数，此时需要依据函数、函数参数进行反射，在运行期间动态执行函数</li></ul><p>Go程序的反射系统无法获取到一个可执行文件空间中或者是一个包中的所有类型信息，需要配合使用标准库中对应的词法、语法解析器和抽象语法树( AST) 对源码进行扫描后获得这些信息。  </p><p>贴士：</p><ul><li>C，C++没有支持反射功能，只能通过 typeid 提供非常弱化的程序运行时类型信息。</li><li>Java、 C#等语言都支持完整的反射功能。</li><li>Lua、JavaScript类动态语言，由于其本身的语法特性就可以让代码在运行期访问程序自身的值和类型信息，因此不需要反射系统。    </li></ul><p>注意：</p><ul><li>在编译期间，无法对反射代码进行一些错误提示。</li><li>反射影响性能</li></ul><h2 id="二-反射是如何实现的"><a href="#二-反射是如何实现的" class="headerlink" title="二 反射是如何实现的"></a>二 反射是如何实现的</h2><p>反射是通过接口的类型信息实现的，即反射建立在类型的基础上：当向接口变量赋予一个实体类型的时候，接口会存储实体的类型信息。  </p><p>Go中反射相关的包是<code>reflect</code>，在该包中，定义了各种类型，实现了反射的各种函数，通过它们可以在运行时检测类型的信息、改变类型的值。  </p><p>变量包括type、value两个部分（所以 <code>nil != nil</code> ），type包括两部分：</p><ul><li>static type：在开发时使用的类型，如int、string</li><li>concrete type：是runtime系统使用的类型</li></ul><p>类型能够断言成功，取决于 concrete type ，如果一个reader变量，如果 concrete type 实现了 write 方法，那么它可以被类型断言为writer。  </p><p>Go中，反射与interface类型相关，其type是 concrete type，只有interface才有反射！每个interface变量都有一个对应的pair，pair中记录了变量的实际值和类型（value, type）。即一个接口类型变量包含2个指针，一个指向对应的 concrete type ，另一个指向实际的值 value。  </p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r io.Reader<span class="comment">// 定义了一个接口类型</span></span><br><span class="line">r, err := os.OpenFile()<span class="comment">// 记录接口的实际类型、实际值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w io.Writer<span class="comment">// 定义一个接口类型</span></span><br><span class="line">w = r.(io.Writer)<span class="comment">// 赋值时，接口内部的pair不变，所以 w 和 r 是同一类型</span></span><br></pre></td></tr></table></figure><h2 id="三-Go中反射初识"><a href="#三-Go中反射初识" class="headerlink" title="三 Go中反射初识"></a>三 Go中反射初识</h2><h3 id="3-1-reflect包的两个函数"><a href="#3-1-reflect包的两个函数" class="headerlink" title="3.1 reflect包的两个函数"></a>3.1 reflect包的两个函数</h3><p>reflect 提供了2个重要函数：</p><ul><li>ValueOf()：获取变量的值，即pair中的 value</li><li>TypeOf()：获取变量的类型，即pair中的  concrete type</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">p := Person&#123; <span class="string">"lisi"</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(reflect.ValueOf(p))<span class="comment">// &#123;lisi 13&#125;  变量的值</span></span><br><span class="line">fmt.Println(reflect.ValueOf(p).Type())<span class="comment">// main.Person 变量类型的对象名</span></span><br><span class="line"></span><br><span class="line">fmt.Println(reflect.TypeOf(p))<span class="comment">//  main.Person变量类型的对象名</span></span><br><span class="line"></span><br><span class="line">fmt.Println(reflect.TypeOf(p).Name())<span class="comment">// Person:变量类型对象的类型名</span></span><br><span class="line">fmt.Println(reflect.TypeOf(p).Kind())<span class="comment">// struct:变量类型对象的种类名</span></span><br><span class="line"></span><br><span class="line">fmt.Println(reflect.TypeOf(p).Name() == <span class="string">"Person"</span>)<span class="comment">// true</span></span><br><span class="line">fmt.Println(reflect.TypeOf(p).Kind() == reflect.Struct)<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>类型与种类的区别：</p><ul><li>Type是原生数据类型： int、string、bool、float32 ，以及 type 定义的类型，对应的反射获取方法是 reflect.Type 中 的 Name()</li><li>Kind是对象归属的品种：Int、Bool、Float32、Chan、String、Struct、Ptr（指针）、Map、Interface、Fune、Array、Slice、Unsafe Pointer等</li></ul><h3 id="3-2-静态类型与动态类型"><a href="#3-2-静态类型与动态类型" class="headerlink" title="3.2 静态类型与动态类型"></a>3.2 静态类型与动态类型</h3><p>静态类型：变量声明时候赋予的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span><span class="comment">// int 是静态类型</span></span><br><span class="line"><span class="keyword">var</span> i *<span class="keyword">int</span><span class="comment">// *int 是静态类型</span></span><br></pre></td></tr></table></figure><p>动态类型：运行时给这个变量赋值时，这个值的类型即为动态类型（为nil时没有动态类型）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A <span class="keyword">interface</span>&#123;&#125;<span class="comment">// 空接口 是静态类型，必须是接口类型才能实现类型动态变化</span></span><br><span class="line">A = <span class="number">10</span><span class="comment">// 此时静态类型为 interface&#123;&#125; 动态为int</span></span><br><span class="line">A = <span class="string">"hello"</span><span class="comment">// 此时静态类型为 interface&#123;&#125; 动态为string</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-时间操作</title>
      <link href="/2020/04/26/%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/04/26/%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="一-时间操作"><a href="#一-时间操作" class="headerlink" title="一 时间操作"></a>一 时间操作</h2><h3 id="1-1-创建时间"><a href="#1-1-创建时间" class="headerlink" title="1.1 创建时间"></a>1.1 创建时间</h3><p>Golang中时间操作位于 time 包中，常见操作有：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前时间</span></span><br><span class="line">nowTime := time.Now()</span><br><span class="line">fmt.Printf(<span class="string">"当前时间为：%T\n"</span>, nowTime)<span class="comment">// 其类型是 time.Time</span></span><br><span class="line">fmt.Println(nowTime)<span class="comment">// 2019-01-01 13:50:07.522712 +0800 CST m=+0.000138178</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义时间</span></span><br><span class="line">customTime := time.Date(<span class="number">2008</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">30</span>,<span class="number">0</span>,<span class="number">0</span>, time.Local)</span><br><span class="line">fmt.Println(customTime)<span class="comment">// 2008-07-15 13:30:00 +0800 CST</span></span><br></pre></td></tr></table></figure><h3 id="1-2-时间格式化与解析"><a href="#1-2-时间格式化与解析" class="headerlink" title="1.2 时间格式化与解析"></a>1.2 时间格式化与解析</h3><p>Go的时间格式化必须传入Go的生日：<code>Mon Jan 2 15:04:05 -0700 MST 2006</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nowTime := time.Now()</span><br><span class="line">stringTime := nowTime.Format(<span class="string">"2006年1月2日 15:04:05"</span>)</span><br><span class="line">fmt.Println(stringTime)<span class="comment">// 2019年01月01日 13:55:30</span></span><br></pre></td></tr></table></figure><p>Go的时间解析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   stringTime := <span class="string">"2019-01-01 15:03:01"</span></span><br><span class="line">objTime,_ := time.Parse(<span class="string">"2006-01-02 15:04:05"</span>,stringTime)</span><br><span class="line">fmt.Println(objTime)<span class="comment">// 2019-01-01 15:03:01 +0000 UTC</span></span><br></pre></td></tr></table></figure><p>注意：这些方法的参数模板必须与时间一一对应，否则报错！</p><h3 id="1-3-获取-年-月-日"><a href="#1-3-获取-年-月-日" class="headerlink" title="1.3 获取 年 月 日"></a>1.3 获取 年 月 日</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   nowTime := time.Now()</span><br><span class="line"></span><br><span class="line">year, month, day := nowTime.Date()</span><br><span class="line">fmt.Println(year, month, day)<span class="comment">// 2019 November 01</span></span><br><span class="line"></span><br><span class="line">hour, min, sec := nowTime.Clock()</span><br><span class="line">fmt.Println(hour, min, sec)</span><br><span class="line"></span><br><span class="line">fmt.Println(nowTime.Year())</span><br><span class="line">fmt.Println(nowTime.Month())</span><br><span class="line">fmt.Println(nowTime.Hour())</span><br><span class="line"></span><br><span class="line">fmt.Println(nowTime.YearDay())<span class="comment">// 指今年一共过了多少天</span></span><br></pre></td></tr></table></figure><h3 id="1-4-时间戳"><a href="#1-4-时间戳" class="headerlink" title="1.4 时间戳"></a>1.4 时间戳</h3><p>时间戳是指计算时间距离 1970年1月1日的秒数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nowTime := time.Now()</span><br><span class="line">fmt.Println(nowTime.Unix())</span><br></pre></td></tr></table></figure><h3 id="1-5-时间间隔"><a href="#1-5-时间间隔" class="headerlink" title="1.5 时间间隔"></a>1.5 时间间隔</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nowTime := time.Now()</span><br><span class="line">fmt.Println(nowTime.Add(time.Second * <span class="number">10</span>))  <span class="comment">// 10秒后</span></span><br><span class="line">   fmt.Println(nowTime.AddDate(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>))<span class="comment">// 1年后</span></span><br></pre></td></tr></table></figure><p>贴士：</p><ul><li>传入负数则是往前计算</li><li>Sub()函数可以用来计算两个时间的差值</li></ul><h3 id="1-6-时间睡眠"><a href="#1-6-时间睡眠" class="headerlink" title="1.6 时间睡眠"></a>1.6 时间睡眠</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.Sleep(time.Second * <span class="number">3</span>)<span class="comment">// 程序睡眠三秒钟</span></span><br></pre></td></tr></table></figure><h2 id="二-时间中的通道操作（定时器）"><a href="#二-时间中的通道操作（定时器）" class="headerlink" title="二 时间中的通道操作（定时器）"></a>二 时间中的通道操作（定时器）</h2><p>标准库中的Timer可以让用户自定义一个定时器，在用对select处理多个channel的超时、单channel读写的超时等情形时很方便：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timer := time.NewTimer(time.Second * <span class="number">3</span>)<span class="comment">// 类型为 *time.Timer</span></span><br><span class="line">ch := timer.C<span class="comment">// timer内部包含一个通道</span></span><br><span class="line">fmt.Println(&lt;-ch)<span class="comment">// 3秒后，通道内有了数据，可以取出</span></span><br></pre></td></tr></table></figure><p>配合协程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">timer := time.NewTimer(time.Second * <span class="number">3</span>)<span class="comment">// 类型为 *time.Timer</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;- timer.C</span><br><span class="line">fmt.Println(<span class="string">"timer 结束"</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">flag := timer.Stop()<span class="comment">// 取消定时器</span></span><br><span class="line">   fmt.Println(flag)<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>time.After函数的使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch := time.After(time.Second * <span class="number">3</span>)<span class="comment">// 底层其实是 new Timer(d).C</span></span><br><span class="line">newTime := &lt;-ch<span class="comment">// 阻塞3秒</span></span><br><span class="line">fmt.Println(newTime)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-文件的读操作</title>
      <link href="/2020/04/23/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-2-%E8%AF%BB%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/04/23/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-2-%E8%AF%BB%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="一-文件读取"><a href="#一-文件读取" class="headerlink" title="一 文件读取"></a>一 文件读取</h2><p>文件读写的接口位于io包，file文件类是这些接口的实现类。</p><h3 id="1-1-直接读取-read"><a href="#1-1-直接读取-read" class="headerlink" title="1.1 直接读取 read()"></a>1.1 直接读取 read()</h3><p>read() 实现的是按字节数读取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">readByte := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">128</span>)<span class="comment">// 指定要读取的长度</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := f.Read(readByte)<span class="comment">// 将数据读取如切片，返回值 n 是实际读取到的字节数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF&#123;<span class="comment">// 如果读到了文件末尾：EOF 即 end of file</span></span><br><span class="line">fmt.Println(<span class="string">"read file : "</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"read: "</span>, <span class="keyword">string</span>(readByte[:n]))</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">128</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read end"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-bufio的写操作"><a href="#1-2-bufio的写操作" class="headerlink" title="1.2 bufio的写操作"></a>1.2 bufio的写操作</h3><p>bufio封装了io.Reader、io.Writer接口对象，并创建了另一个也实现了该接口的对象：bufio.Reader、bufio.Writer。通过该实现，bufio实现了文件的缓冲区设计，可以大大提高文件I/O的效率。  </p><p>使用bufio读取文件时，先将数据读入内存的缓冲区（缓冲区一般比要比程序中设置的文件接收对象要大），这样就可以有效降低直接I/O的次数。  </p><p><code>bufio.Read([]byte)</code>相当于读取大小<code>len(p)</code>的内容：</p><ul><li>当缓冲区有内容时，将缓冲区内容全部填入p并清空缓冲区</li><li>当缓冲区没有内容且<code>len(p)&gt;len(buf)</code>，即要读取的内容比缓冲区还要大，直接去文件读取即可</li><li>当缓冲区没有内容且<code>len(p)&lt;len(buf)</code>，即要读取的内容比缓冲区小，读取文件内容并填满缓冲区，并将p填满</li><li>以后再次读取时，缓冲区有内容，将缓冲区内容全部填入p并清空缓冲区（和第一步一致）</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建读对象</span></span><br><span class="line">reader := bufio.NewReader(f)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读一行数据</span></span><br><span class="line">byt, _ := reader.ReadBytes(<span class="string">'\n'</span>)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(byt))</span><br></pre></td></tr></table></figure><p>ReadString() 函数也具有同样的功能，且能直接读取到字符串数据，无需转换，示例：读取大文件的全部数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">reader := bufio.NewReader(f)</span><br><span class="line"><span class="keyword">for</span> &#123;<span class="comment">// 按照缓冲区读取：读取到特定字符结束</span></span><br><span class="line">str, err := reader.ReadString(<span class="string">'\n'</span>)<span class="comment">// 按行读取</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line">fmt.Println(<span class="string">"read err: "</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"str = "</span>, str)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">fmt.Print(<span class="string">"read end"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Unix设计思想中，一切皆文件，命令行输入也可以作为文件读入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line">s, _ := reader.ReadString(<span class="string">"-"</span>)<span class="comment">// 假设命令行以 - 开始</span></span><br></pre></td></tr></table></figure><p>缓冲的思想：通过bufio，数据被写入用户缓冲，再进入系统缓冲，最后由操作系统将系统缓冲区的数据写入磁盘。  </p><h3 id="1-3-io-ioutil-包文件读取"><a href="#1-3-io-ioutil-包文件读取" class="headerlink" title="1.3 io/ioutil 包文件读取"></a>1.3 io/ioutil 包文件读取</h3><p>ioutil直接读取文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ret, err := ioutil.ReadFile(<span class="string">"test.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read err :"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(ret))</span><br></pre></td></tr></table></figure><h3 id="二-文件写入"><a href="#二-文件写入" class="headerlink" title="二 文件写入"></a>二 文件写入</h3><h3 id="2-1-直接写"><a href="#2-1-直接写" class="headerlink" title="2.1 直接写"></a>2.1 直接写</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.OpenFile(<span class="string">"test.txt"</span>, os.O_CREATE | os.O_WRONLY, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">n, err := f.Write([]<span class="keyword">byte</span>(<span class="string">"hello world"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"write err:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(n)<span class="comment">// 每次都会从头开始重新写入</span></span><br></pre></td></tr></table></figure><p>上述案例中，如果我们不想每次写入都会从头开始重新写入，那么需要将打开模式修改为：<code>os.O_CREATE | os.O_WRONLY | os.O_APPEND</code></p><h3 id="2-2-bufio的写操作"><a href="#2-2-bufio的写操作" class="headerlink" title="2.2 bufio的写操作"></a>2.2 bufio的写操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">writer := bufio.NewWriter(f)</span><br><span class="line">_, err = writer.WriteString(<span class="string">"hello world!"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"write err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">writer.Flush()<span class="comment">// 必须刷新缓冲区：将缓冲区的内容写入文件中。如果不刷新，则只会在内容超出缓冲区大小时写入</span></span><br></pre></td></tr></table></figure><h3 id="2-3-io-ioutil-包文件写入"><a href="#2-3-io-ioutil-包文件写入" class="headerlink" title="2.3  io/ioutil 包文件写入"></a>2.3  io/ioutil 包文件写入</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"你好世界"</span></span><br><span class="line">err := ioutil.WriteFile(<span class="string">"test.txt"</span>, []<span class="keyword">byte</span>(s), os.ModePerm)</span><br></pre></td></tr></table></figure><h2 id="三-文件读取偏移量"><a href="#三-文件读取偏移量" class="headerlink" title="三 文件读取偏移量"></a>三 文件读取偏移量</h2><p>文件读取时，是可以控制光标位置的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.OpenFile(<span class="string">"test.txt"</span>, os.O_RDWR, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取前五个字节，假设读取的文件内容为： hello world!</span></span><br><span class="line">bs := []<span class="keyword">byte</span>&#123;<span class="number">0</span>&#125;<span class="comment">// 创建1个字节的切片</span></span><br><span class="line">_, err = f.Read(bs)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"读到的数据是："</span>, <span class="keyword">string</span>(bs))<span class="comment">// h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动光标</span></span><br><span class="line">_, err = f.Seek(<span class="number">4</span>, io.SeekStart)<span class="comment">// 光标从开始位置(h之前)，移动4位，到达o之前</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"seek err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">_, err = f.Read(bs)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"读到的数据是："</span>, <span class="keyword">string</span>(bs))<span class="comment">// o</span></span><br></pre></td></tr></table></figure><p>通过记录光标的位置，可以实现断点续传：假设已经下载了1KB文件，即本地临时文件存储了1KB，此时断电，重启后通过本地文件大小、Seek()方法获取到上次读取文件的光标位置即可实现继续下载！</p>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-接口使用</title>
      <link href="/2020/04/21/%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B-1-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/04/21/%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B-1-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一-接口-interface"><a href="#一-接口-interface" class="headerlink" title="一 接口 interface"></a>一 接口 interface</h2><p>接口（interface）是调用方和实现方均需要遵守的一种约束，约束开发者按照统一的方法命名、参数类型、数量来处理具体业务。实际上，接口就是一组没有实现的方法声明，到某个自定义类型要使用该方法时，根据具体情况把这些方法实现出来。接口语法：  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span> &#123;</span><br><span class="line">方法名<span class="number">1</span>(参数列表) 返回值列表</span><br><span class="line">方法名<span class="number">2</span>(参数列表) 返回值列表</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运输方式</span></span><br><span class="line"><span class="keyword">type</span> Transporter <span class="keyword">interface</span> &#123;</span><br><span class="line">BicycleTran()</span><br><span class="line">CarTran()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驾驶员</span></span><br><span class="line"><span class="keyword">type</span> Driver <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现运输方式接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">BicycleTran</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"使用自行车运输"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">CarTran</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"使用小汽车运输"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d := &amp;Driver&#123;</span><br><span class="line"><span class="string">"张三"</span>,</span><br><span class="line"><span class="number">27</span>,</span><br><span class="line">&#125;</span><br><span class="line">trans(d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要实现了 Transporter接口的类型都可以作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trans</span><span class="params">(t Transporter)</span></span> &#123;</span><br><span class="line">t.BicycleTran()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>Go语言的接口在命名时，一般会在单词后面添加er，如写操作的接口叫做Writer</li><li>当方法名首字母大写，且实现的接口首字母也是大写，则该方法可以被接口所在包之外的代码访问</li><li>方法与接口中的方法签名一致（方法名、参数列表、返回列表都必须一致）</li><li>参数列表和返回值列表中的变量名可以被忽略，如：type writer interfae{ Write([]byte) error}</li><li>接口中所有的方法都必须被实现</li><li>如果编译时发现实现接口的方法签名不一致，则会报错：<code>does not implement</code>。  </li></ul><h2 id="二-Go接口的特点"><a href="#二-Go接口的特点" class="headerlink" title="二 Go接口的特点"></a>二 Go接口的特点</h2><p>在上述示例中，Go无须像Java那样显式声明实现了哪个接口，即为非侵入式，接口编写者无需知道接口被哪些类型实现，接口实现者只需要知道实现的是什么样子的接口，但无需指明实现了哪个接口。编译器知道最终编译时使用哪个类型实现哪个接口，或者接口应该由谁来实现。  </p><p>类型和接口之间有一对多和多对一的关系，即：</p><ul><li>一个类型可以实现多个接口，接口间是彼此独立的，互相不知道对方的实现</li><li>多个类型也可以实现相同的接口。   </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;</span><br><span class="line">Start()</span><br><span class="line">Log(<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志器</span></span><br><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//日志输出方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Logger)</span> <span class="title">Log</span><span class="params">(s <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"日志："</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏服务</span></span><br><span class="line"><span class="keyword">type</span> GameService <span class="keyword">struct</span> &#123;</span><br><span class="line">Logger</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现游戏服务的Start方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GameService)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"游戏服务启动"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">new</span>(GameService)</span><br><span class="line">s.Start()</span><br><span class="line">s.Log(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述案例中，即使没有接口也能运行，但是当存在接口时，会隐式实现接口，让接口给类提供约束。</p><p>使用接口调用了结构体中的方法，也可以理解为实现了面向对象中的多态。  </p><h2 id="三-接口嵌套"><a href="#三-接口嵌套" class="headerlink" title="三 接口嵌套"></a>三 接口嵌套</h2><p>Go中不仅结构体之间可以嵌套，接口之间也可以嵌套。接口与接口嵌套形成了新的接口，只要接口的所有方法被实现，则这个接口中所有嵌套接口的方法均可以被调用。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个 写 接口</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, e error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 读 接口</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">Read() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 嵌套接口</span></span><br><span class="line"><span class="keyword">type</span> IO <span class="keyword">interface</span> &#123;</span><br><span class="line">Writer</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-空接口"><a href="#四-空接口" class="headerlink" title="四 空接口"></a>四 空接口</h2><h4 id="4-1-空接口定义"><a href="#4-1-空接口定义" class="headerlink" title="4.1 空接口定义"></a>4.1 空接口定义</h4><p>空接口是接口的特殊形式，没有任何方法，因此任何具体的类型都可以认为实现了空接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">any = <span class="number">1</span></span><br><span class="line">fmt.Println(any)</span><br><span class="line"></span><br><span class="line">any = <span class="string">"hello"</span></span><br><span class="line">fmt.Println(any)</span><br></pre></td></tr></table></figure><p>空接口作为函数参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Test(<span class="number">3</span>)<span class="comment">// int</span></span><br><span class="line">Test(<span class="string">"hello"</span>)<span class="comment">// sting</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用空接口，可以实现任意类型的存储：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">m[<span class="string">"name"</span>] = <span class="string">"李四"</span></span><br><span class="line">m[<span class="string">"age"</span>] = <span class="number">30</span></span><br></pre></td></tr></table></figure><h4 id="4-2-从空接口获取值"><a href="#4-2-从空接口获取值" class="headerlink" title="4.2 从空接口获取值"></a>4.2 从空接口获取值</h4><p>保存到空接口的值，如果直接取出指定类型的值时，会发生编译错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = a</span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = i<span class="comment">//这里编译报错（类型不一致），可以这样做：b := i</span></span><br></pre></td></tr></table></figure><h4 id="4-3-空接口值比较"><a href="#4-3-空接口值比较" class="headerlink" title="4.3 空接口值比较"></a>4.3 空接口值比较</h4><p>类型不同的空接口比较：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = <span class="string">"hi"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a == b)<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>不能比较空接口中的动态值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c <span class="keyword">interface</span>&#123;&#125; = []<span class="keyword">int</span>&#123;<span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">interface</span>&#123;&#125; = []<span class="keyword">int</span>&#123;<span class="number">20</span>&#125;</span><br><span class="line">fmt.Println(c == d)<span class="comment">//运行报错</span></span><br></pre></td></tr></table></figure><p>空接口的类型和可比较性：</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>map</td><td>不可比较，会发生宕机错误</td></tr><tr><td>切片</td><td>不可比较，会发生宕机错误</td></tr><tr><td>通道</td><td>可比较，必须由同一个make生成，即同一个通道才是true</td></tr><tr><td>数组</td><td>可比较，编译期即可知道是否一致</td></tr><tr><td>结构体</td><td>可比较，可诸葛比较结构体的值</td></tr><tr><td>函数</td><td>可比较</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-文件的写操作</title>
      <link href="/2020/04/21/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-1-%E5%86%99%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/04/21/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-1-%E5%86%99%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="一-文件的基本操作"><a href="#一-文件的基本操作" class="headerlink" title="一 文件的基本操作"></a>一 文件的基本操作</h2><h3 id="1-1-创建文件"><a href="#1-1-创建文件" class="headerlink" title="1.1 创建文件"></a>1.1 创建文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Create(<span class="string">"test.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(f)<span class="comment">// 打印文件指针</span></span><br><span class="line">f.Close()<span class="comment">// 打开的资源在不使用时必须关闭</span></span><br></pre></td></tr></table></figure><p>使用Create()创建文件时：</p><ul><li>如果文件不存在，则创建文件。</li><li>如果文件存在，则清空文件内内容。  </li><li>Create创建的文件任何人都可以读写。 </li></ul><h3 id="1-2-打开文件，写入内容"><a href="#1-2-打开文件，写入内容" class="headerlink" title="1.2 打开文件，写入内容"></a>1.2 打开文件，写入内容</h3><p>打开文件有两种方式：</p><ul><li>Open()：以只读的方式打开文件，若文件不存在则会打开失败</li><li>OpenFile()：打开文件时，可以传入打开方式，该函数的三个参数：<ul><li>参数1：要打开的文件路径</li><li>参数2：文件打开模式，如 <code>O_RDONLY</code>，<code>O_WRONGLY</code>，<code>O_RDWR</code>，还可以通过管道符来指定文件不存在时创建文件</li><li>参数3：文件创建时候的权限级别，在0-7之间，常用参数为6</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.OpenFile(<span class="string">"test.txt"</span>, os.O_APPEND | os.O_RDWR, os.ModeAppend)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">f.Close()</span><br></pre></td></tr></table></figure><p>常用的文件打开模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">O_RDONLY <span class="keyword">int</span> = syscall.O_RDONLY<span class="comment">// 只读</span></span><br><span class="line">O_WRONGLY<span class="keyword">int</span> = syscall.O_WRONGLY<span class="comment">// 只写</span></span><br><span class="line">O_RDWR <span class="keyword">int</span> = syscall.O_RDWR<span class="comment">// 读写</span></span><br><span class="line">O_APPEND <span class="keyword">int</span> = syscall.O_APPEND<span class="comment">// 写操作时将数据追加到文件末尾</span></span><br><span class="line">O_CREATE <span class="keyword">int</span> = syscall.O_CREATE<span class="comment">// 如果不存在则创建一个新文件</span></span><br><span class="line">O_EXCL <span class="keyword">int</span> = syscall.O_EXCL<span class="comment">// 打开文件用于同步I/O</span></span><br><span class="line">O_TRUNC<span class="keyword">int</span> = syscall.O_TRUNC<span class="comment">// 如果可能，打开时清空文件</span></span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 1.3 写文件</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">写入字节 `</span>Write()<span class="string">`：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="comment">// 写入文件内容</span></span><br><span class="line">n, err := f.Write([]<span class="keyword">byte</span>(<span class="string">"hello"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"write err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"write number = "</span>, n)</span><br></pre></td></tr></table></figure><p>按字符串写 <code>WriteString()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入文件内容</span></span><br><span class="line">n, err := f.WriteString([<span class="string">"hello"</span>)<span class="comment">// 会将前5个字符替换为 hello</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"write err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"write number = "</span>, n)</span><br></pre></td></tr></table></figure><p>修改文件的读写指针位置 <code>Seek()</code>，包含两个参数：</p><ul><li>参数1：偏移量，为正数时向文件尾偏移，为负数时向文件头偏移</li><li>参数2：偏移的开始位置，包括：<ul><li>io.SeekStart：从文件起始位置开始</li><li>io.SeekCurrent：从文件当前位置开始</li><li>io.SeekEnd：从文件末尾位置开始</li></ul></li></ul><p><code>Seek()</code>函数返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f, _ := os.OpenFile(<span class="string">"test.txt"</span>,os.O_RDWR, <span class="number">6</span>)</span><br><span class="line">off, _ := f.Seek(<span class="number">5</span>, io.SeekStart)</span><br><span class="line">fmt.Println(off)<span class="comment">// 5</span></span><br><span class="line">n, _ := f.WriteAt([]<span class="keyword">byte</span>(<span class="string">"111"</span>), off)</span><br><span class="line">fmt.Println(n)</span><br><span class="line">f.Close()</span><br></pre></td></tr></table></figure><h3 id="1-4-获取文件描述信息-os-Stat"><a href="#1-4-获取文件描述信息-os-Stat" class="headerlink" title="1.4 获取文件描述信息 os.Stat()"></a>1.4 获取文件描述信息 os.Stat()</h3><p>Go的os包中定义了file类，封装了文件描述信息，同时也提供了Read、Write的实现。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fileInfo, err := os.Stat(<span class="string">"./test.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"stat err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, fileInfo)<span class="comment">// *os.fileStat</span></span><br></pre></td></tr></table></figure><p>获取到的fileInfo内部包含 <code>文件名Name()</code>、<code>大小Size()</code>、<code>是否是目录IsDir()</code> 等操作。  </p><h3 id="1-5-路径、目录操作"><a href="#1-5-路径、目录操作" class="headerlink" title="1.5 路径、目录操作"></a>1.5 路径、目录操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径操作</span></span><br><span class="line">fmt.Println(filepath.IsAbs(<span class="string">"./test.txt"</span>))<span class="comment">// false：判断是否是绝对路径</span></span><br><span class="line">fmt.Println(filepath.Abs(<span class="string">"./test.txt"</span>))<span class="comment">// 转换为绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建目录</span></span><br><span class="line">err := os.Mkdir(<span class="string">"./test"</span>, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"mkdir err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多级目录</span></span><br><span class="line">err = os.MkdirAll(<span class="string">"./dd/rr"</span>, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"mkdirAll err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">贴士：Openfile()可以用于打开目录。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 1.6 删除文件</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line">err := os.Remove(<span class="string">"test.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"remove err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数也可用于删除目录（只能删除空目录）。如果要删除非空目录，需要使用 <code>RemoveAll()</code> 函数</p>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-接口断言、多态</title>
      <link href="/2020/04/15/%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B-2-%E6%96%AD%E8%A8%80%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
      <url>/2020/04/15/%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B-2-%E6%96%AD%E8%A8%80%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h2 id="一-断言"><a href="#一-断言" class="headerlink" title="一 断言"></a>一 断言</h2><p>接口是编程的规范，他也可以作为函数的参数，以让函数更具备适用性。在下列示例中，有三个接口动物接口、飞翔接口、游泳接口，两个实现类鸟类与鱼类：</p><ul><li>鸟类：实现了动物接口，飞翔接口</li><li>鱼类：实现了动物接口，游泳接口</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个通用接口：动物接口</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">Breath()<span class="comment">// 动物都具备 呼吸方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Flyer <span class="keyword">interface</span> &#123;</span><br><span class="line">Fly()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Swimer <span class="keyword">interface</span> &#123;</span><br><span class="line">Swim()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个鸟类：其呼吸的方式是在陆地</span></span><br><span class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Food <span class="keyword">string</span></span><br><span class="line">Kind <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bird)</span> <span class="title">Breath</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"鸟 在 陆地 呼吸"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bird)</span> <span class="title">Fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s 在 飞\n"</span>, b.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一定一个鱼类：其呼吸方式是在水下</span></span><br><span class="line"><span class="keyword">type</span> Fish <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Kind <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fish)</span> <span class="title">Breath</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"鱼 在 水下 呼吸"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fish)</span> <span class="title">Swim</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s 在游泳\n"</span>, f.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个普通函数，参数是动物接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Display</span><span class="params">(a Animal)</span></span> &#123;</span><br><span class="line"><span class="comment">// 直接调用接口中的方法</span></span><br><span class="line">a.Breath()</span><br><span class="line"><span class="comment">// 调用实现类的成员：此时会报错</span></span><br><span class="line">fmt.Println(a.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b = &amp;Bird&#123;</span><br><span class="line"><span class="string">"斑鸠"</span>,</span><br><span class="line"><span class="string">"蚂蚱"</span>,</span><br><span class="line"><span class="string">"鸟类"</span></span><br><span class="line">&#125;</span><br><span class="line">Display(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口类型无法直接访问其具体实现类的成员，需要使用断言（type assertions），对接口的类型进行判断，类型断言格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := i.(T)<span class="comment">//不安全写法：如果i没有完全实现T接口的方法，这个语句将会触发宕机</span></span><br><span class="line">t, ok := i.(T)<span class="comment">// 安全写法：如果接口未实现接口，将会把ok掷为false，t掷为T类型的0值</span></span><br></pre></td></tr></table></figure><ul><li>i代表接口变量</li><li>T代表转换的目标类型</li><li>t代表转换后的变量</li></ul><p>上述案例的Dsiplay就可以书写为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Display</span><span class="params">(a Animal)</span></span> &#123;</span><br><span class="line"><span class="comment">// 直接调用接口中的方法</span></span><br><span class="line">a.Breath()</span><br><span class="line"><span class="comment">// 调用实现类的成员：此时会报错</span></span><br><span class="line">instance, ok := a.(*Bird)<span class="comment">// 注意：这里必须是 *Bird类型，因为是*Bird实现了接口，不是Bird实现了接口</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="comment">// 得到了具体的实现类，才能访问实现类的成员</span></span><br><span class="line">fmt.Println(<span class="string">"该鸟类的名字是："</span>, instance.Name)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"该动物不是鸟类"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-接口类型转换"><a href="#二-接口类型转换" class="headerlink" title="二 接口类型转换"></a>二 接口类型转换</h2><p>在接口定义时，其类型已经确定，因为接口的本质是方法签名的集合，如果两个接口的方法签名结合相同（顺序可以不同），则这2个接口之间不需要强制类型转换就可以相互赋值，因为go编译器在校验接口是否能赋值时，比较的是二者的方法集。  </p><p>在上一节中，函数Display接收的是Animal接口类型，在断言后转换为了别的类型：*Bird(实现类指针类型)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Display</span><span class="params">(a Animal)</span></span> &#123;</span><br><span class="line">instance, ok := a.(*Bird)<span class="comment">// 动物接口转换为了 *Bird实现类</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="comment">// 得到了具体的实现类，才能访问实现类的成员</span></span><br><span class="line">fmt.Println(<span class="string">"该鸟类的名字是："</span>, instance.Name)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"该动物不是鸟类"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，断言还可以将接口转换成另外一个接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Display</span><span class="params">(a Animal)</span></span> &#123;</span><br><span class="line">instance, ok := a.(Flyer)<span class="comment">// 动物接口转换为了飞翔接口</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">instance.Fly()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"该动物不会飞"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个实现类往往实现了很多接口，为了精准类型查询，可以使用switch语句来判断对象类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 interfaceP&#123;&#125; = ...</span><br><span class="line"><span class="keyword">switch</span> v := v1.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-多态"><a href="#三-多态" class="headerlink" title="三 多态"></a>三 多态</h2><p>多态是面向对象的三大特性之一，即一个类型具备多种具体的表现形式。  </p><p>上述示例中，鸟和鱼都实现了动物接口的 Breath方法，即动物的Breath方法在鸟和鱼中具备不同的体现。我们在new出动物的具体对象实例时，这个对象实例也就实现了对应自己的接口方法。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New出Animal的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAnimal</span><span class="params">(kind <span class="keyword">string</span>)</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> kind &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"鸟类"</span>:</span><br><span class="line"><span class="keyword">return</span> &amp;Bird&#123;&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"鱼类"</span>:</span><br><span class="line"><span class="keyword">return</span> &amp;Fish&#123;&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取的是动物接口类型，但是实现类是鸟类</span></span><br><span class="line">a1 := NewAnimal(<span class="string">"鸟类"</span>)</span><br><span class="line">a1.Breath()<span class="comment">// 鸟 在 陆地 呼吸</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取的是动物接口类型，但是实现类是鱼类</span></span><br><span class="line">a2 := NewAnimal(<span class="string">"鱼类"</span>)</span><br><span class="line">a2.Breath()<span class="comment">// 鱼 在 水下 呼吸</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

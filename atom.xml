<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dwl&#39;s blog</title>
  
  <subtitle>记录生活中的点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cool2feel.github.io/"/>
  <updated>2020-06-16T08:38:47.114Z</updated>
  <id>https://cool2feel.github.io/</id>
  
  <author>
    <name>Dwesome</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git使用规范</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84git%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84git%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</id>
    <published>2020-06-16T08:34:57.000Z</published>
    <updated>2020-06-16T08:38:47.114Z</updated>
    
    <content type="html"><![CDATA[<p>祖师爷 Linus 在创造了伟大的 Linux 之后，又创造了应用最广泛的代码管理工具 —— Git，极大地提高了程序员的生产力。 现如今大部分项目都在使用 Git 作为代码管理工具，不论是在代码管理、版本控制以及团队协作上，Git 相比其他版本控制软件都有着无可比拟的优势。</p><p>虽然 Git 是个优秀的工具，但是在项目中是否能够正确合理地使用，是否能够发挥其最大的优势，就我自己这几年的工作经历来看，对于大部分团队这个问题的答案是否定的。</p><p>大部分程序员对 Git 的使用基本上都停留在 git add、git commit、git push、git pull 这几个指令上，而且大部分团队也没有 Git 规范，提交信息充斥着大量的 “fix”、“update”，分支管理也很混乱，代码提交哪个分支上也没具体的规定，导致在团队协作过程中经常出现代码合并后谁的代码不见了，修过的 bug 在新版本又出现了……<br>0. 我们可能面临的问题</p><p>试想遇到以下这些问题，你会采取怎样的方式去解决：</p><pre><code>* 需要线上某个历史版本的源码，直接在 develop 分支根据提交记录和时间找对应的节点？* 线上版本出现严重 bug 需要紧急修复发版本，而你的项目就一个分支，上个版本发布之后已经有大量改动了，怎么办？* 某个提交改动了部分代码，涉及到 10 几个文件，现在这个改动不需要了，此时要一个个找出这些文件然后再改回去么？* 出现了一个 bug，之前好像处理过，但是现在忘了当初怎么处理的了，在一堆写着 “fix bug”、“update” 的提交记录中，如何找到当初那笔的提交？* 某个功能本来准备发布的，现在突然决定这个版本不上了，现在要一处处找到之前的代码，然后再改回去？* ……</code></pre><p>以上这些问题在我们的项目中都是会或多或少出现的，部分问题可能涉及到的是对 Git 的功能是否熟悉的问题，大部分问题则是涉及到一个项目的 Git 使用规范问题，如果有一个很好的规范，在项目中合理地使用 Git，很多问题压根就不是问题。</p><ol><li>Git 规范的必要性</li></ol><p>既然认同需要一份 Git 规范，那么这个规范需要规范哪些内容，解决哪些问题，又带来哪些好处呢？个人认为有以下几点：</p><ol><li><p>分支管理</p><p> 代码提交在应该提交的分支<br> 随时可以切换到线上稳定版本代码<br> 多个版本的开发工作同时进行</p></li><li><p>提交记录的可读性</p><p> 准确的提交描述，具备可检索性<br> 合理的提交范围，避免一个功能就一笔提交<br> 分支间的合并保有提交历史，且合并后结果清晰明了<br> 避免出现过多的分叉</p></li><li><p>团队协作</p><p> 明确每个分支的功用，做到对应的分支执行对应的操作<br> 合理的提交，每次提交有明确的改动范围和规范的提交信息<br> 使用 Git 管理版本迭代、紧急线上 bug fix、功能开发等任务</p></li></ol><p>以上就是一份 Git 规范的作用和使命。</p><p>接下来结合 Git-Flow 和个人实际的项目经验，总结了一份项目中使用 Git 的规范，其中大部分内容都是对 Git-Flow 进行一个解读和扩展，告诉大家为什么这么做以及怎么做。 这里也推荐一下 Git-Flow 相关的内容：</p><pre><code>A successful Git branching model » nvie.com</code></pre><p>这是一份 2010 年提出来的分支管理规范，距今已过去 8 年了，但是其工作流程至今还是适用的，也衍生出很多优秀的开发流程。</p><p>以下就是 Git-Flow 的经典流程图：<br><img src="https://jaeger.itscoder.com/img/postimg/git-flow.png" alt=""><br>如果你熟悉 Git-Flow，那么你对上图中的各种分支和线应该都能够理解，如果你之前没了解过相关的知识，那你可能会有点懵，不过在读完本文之后再看这张图，应该就能够理解了。<br>2. 分支管理规范<br>2.1 分支说明和操作</p><pre><code>master 分支    主分支，永远处于稳定状态，对应当前线上版本    以 tag 标记一个版本，因此在 master 分支上看到的每一个 tag 都应该对应一个线上版本    不允许在该分支直接提交代码develop 分支    开发分支，包含了项目最新的功能和代码，所有开发都依赖 develop 分支进行    小的改动可以直接在 develop 分支进行，改动较多时切出新的 feature 分支进行    注： 更好的做法是 develop 分支作为开发的主分支，也不允许直接提交代码。小改动也应该以 feature 分支提 merge request 合并，目的是保证每个改动都经过了强制代码 review，降低代码风险feature 分支    功能分支，开发新功能的分支    开发新的功能或者改动较大的调整，从 develop 分支切换出 feature 分支，分支名称为 feature/xxx    开发完成后合并回 develop 分支并且删除该 feature/xxx 分支release 分支    发布分支，新功能合并到 develop 分支，准备发布新版本时使用的分支    当 develop 分支完成功能合并和部分 bug fix，准备发布新版本时，切出一个 release 分支，来做发布前的准备，分支名约定为release/xxx    发布之前发现的 bug 就直接在这个分支上修复，确定准备发版本就合并到 master 分支，完成发布，同时合并到 develop 分支hotfix 分支    紧急修复线上 bug 分支    当线上版本出现 bug 时，从 master 分支切出一个 hotfix/xxx 分支，完成 bug 修复，然后将 hotfix/xxx 合并到 master 和 develop 分支(如果此时存在 release 分支，则应该合并到 release 分支)，合并完成后删除该 hotfix/xxx 分支</code></pre><p>以上就是在项目中应该出现的分支以及每个分支功能的说明。 其中稳定长期存在的分支只有 master 和 develop 分支，别的分支在完成对应的使命之后都会合并到这两个分支然后被删除。简单总结如下：</p><pre><code>master 分支: 线上稳定版本分支develop 分支: 开发分支，衍生出 feature 分支和 release 分支release 分支: 发布分支，准备待发布版本的分支，存在多个，版本发布之后删除feature 分支: 功能分支，完成特定功能开发的分支，存在多个，功能合并之后删除hotfix 分支: 紧急热修复分支，存在多个，紧急版本发布之后删除</code></pre><p>2.2 分支间操作注意事项</p><p>在团队开发过程中，避免不了和其他人一起协作， 同时也会遇到合并分支等一些操作，这里提交 2 个个人觉得比较好的分支操作规范。</p><pre><code>同一分支 git pull 使用 rebase首先看一张图：</code></pre><p><img src="https://jaeger.itscoder.com/img/postimg/git_pull_no_rebase.jpg" alt=""><br>    看到这样的  提交线图，想从中看出一条清晰的提交线几乎是不可能的，充满了 Merge remote-tracking branch ‘origin/xxx’ into xxx 这样的提交记录，同时也将提交线弄成了交错纵横的图，没有了可读性。</p><pre><code>这里最大的原因就是因为默认的 git pull 使用的是 merge 行为，当你更新代码时，如果本地存在未推送到远程的提交，就会产生一个这样的 merge 提交记录。因此在同一个分支上更新代码时推荐使用 git pull --rebase。下面这张图展示了默认的 git pull 和 git pull --rebase 的结果差异，使用 git pull --rebase 目的是修整提交线图，使其形成一条直线。</code></pre><p><img src="https://jaeger.itscoder.com/img/postimg/git_pull_rebase_diff.jpg" alt=""><br>    默认的 git pull 行为是 merge，可以进行如下设置修改默认的 git pull 行为：</p><pre><code># 为某个分支单独设置，这里是设置 dev 分支git config branch.dev.rebase true# 全局设置，所有的分支 git pull 均使用 --rebasegit config --global pull.rebase truegit config --global branch.autoSetupRebase always这里需要说明一下，在我看来使用 git pull --rebase 操作是比较好的，能够得到一条很清晰的提交直线图，方便查看提交记录和 code review，但是由于 rebase 会改变提交历史，也存在一些不好的影响。这里就不做过多的讨论了，有兴趣的话可以移步知乎上的讨论：在开发过程中使用 git rebase 还是 git merge，优缺点分别是什么？分支合并使用 --no-ff  # 例如当前在 develop 分支，需要合并 feature/xxx 分支  git merge --no-ff feature/xxx在解释这个命令之前，先解释下 Git 中的 fast-forward： 举例来说，开发一直在 develop 分支进行，此时有个新功能需要开发，新建一个 feature/a 分支，并在其上进行一系列开发和提交。当完成功能开发时，此时回到 develop 分支，此时 develop 分支在创建 feature/a 分支之后没有产生任何的 commit，那么此时的合并就叫做 fast-forward。fast-forward 合并的结果如下图所示，这种 merge 的结果就是一条直线了，无法明确看到切出一个新的 feature 分支，并完成了一个新的功能开发，因此此时比较推荐使用 git merge --no-ff，得到的结果就很明确知道，新的一系列提交是完成了一个新的功能，如果需要对这个功能进行 code review，那么只需要检视叉的那条线上的提交即可。</code></pre><p><img src="https://jaeger.itscoder.com/img/postimg/git_merge_diff.svg" alt=""><br>    关于以上两个分支间的操作建议，如果需要了解更多，可以阅读洁癖者用 Git：pull –rebase 和 merge –no-ff 这篇文章。</p><p>2.3 项目分支操作流程示例</p><p>这部分内容结合日常项目的开发流程，涉及到开发新功能、分支合并、发布新版本以及发布紧急修复版本等操作，展示常用的命令和操作。</p><pre><code>切到 develop 分支，更新 develop 最新代码git checkout developgit pull --rebase新建 feature 分支，开发新功能git checkout -b feature/xxx...git add &lt;files&gt;git commit -m &quot;feat(xxx): commit a&quot;git commit -m &quot;feat(xxx): commit b&quot;# 其他提交...如果此时 develop 分支有一笔提交，影响到你的 feature 开发，可以 rebase develop 分支，前提是 该 feature 分支只有你自己一个在开发，如果多人都在该分支，需要进行协调：# 切换到 develop 分支并更新 develop 分支代码git checkout developgit pull --rebase# 切回 feature 分支git checkout feature/xxxgit rebase develop# 如果需要提交到远端，且之前已经提交到远端，此时需要强推(强推需慎重！)git push --force上述场景也可以通过 git cherry-pick 来实现，有兴趣的可以去了解一下这个指令。完成 feature 分支，合并到 develop 分支# 切到 develop 分支，更新下代码git check developgit pull --rebase# 合并 feature 分支git merge feature/xxx --no-ff# 删除 feature 分支git branch -d feature/xxx# 推到远端git push origin develop当某个版本所有的 feature 分支均合并到 develop 分支，就可以切出 release 分支，准备发布新版本，提交测试并进行 bug fix# 当前在 develop 分支git checkout -b release/xxx# 在 release/xxx 分支进行 bug fixgit commit -m &quot;fix(xxx): xxxxx&quot;...所有 bug 修复完成，准备发布新版本# master 分支合并 release 分支并添加 taggit checkout mastergit merge --no-ff release/xxx --no-ff# 添加版本标记，这里可以使用版本发布日期或者具体的版本号git tag 1.0.0# develop 分支合并 release 分支git checkout developgit merge --no-ff release/xxx# 删除 release 分支git branch -d release/xxx至此，一个新版本发布完成。线上出现 bug，需要紧急发布修复版本# 当前在 master 分支git checkout master# 切出 hotfix 分支git checkout -b hotfix/xxx... 进行 bug fix 提交# master 分支合并 hotfix 分支并添加 tag(紧急版本)git checkout mastergit merge --no-ff hotfix/xxx --no-ff# 添加版本标记，这里可以使用版本发布日期或者具体的版本号git tag 1.0.1# develop 分支合并 hotfix 分支(如果此时存在 release 分支的话，应当合并到 release 分支)git checkout developgit merge --no-ff hotfix/xxx# 删除 hotfix 分支git branch -d hotfix/xxx至此，紧急版本发布完成。</code></pre><ol start="3"><li>提交信息规范</li></ol><p>提交信息规范部分参考 Angular.js commit messgae。</p><p>git commit 格式 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br></pre></td></tr></table></figure><p>各个部分的说明如下：</p><pre><code>type 类型，提交的类别    feat: 新功能    fix: 修复 bug    docs: 文档变动    style: 格式调整，对代码实际运行没有改动，例如添加空行、格式化等    refactor: bug 修复和添加新功能之外的代码改动    perf: 提升性能的改动    test: 添加或修正测试代码    chore: 构建过程或辅助工具和库（如文档生成）的更改scope 修改范围主要是这次修改涉及到的部分，简单概括，例如 login、train-ordersubject 修改的描述具体的修改描述信息范例feat(detail): 详情页修改样式fix(login): 登录页面错误处理test(list): 列表页添加测试代码</code></pre><p>这里对提交规范加几点说明：</p><pre><code>1. type + scope 能够控制每笔提交改动的文件尽可能少且集中，避免一次很多文件改动或者多个改动合成一笔。2. subject 对于大部分国内项目而已，如果团队整体英文不是较高水平，比较推荐使用中文，方便阅读和检索。3. 避免重复的提交信息，如果发现上一笔提交没改完整，可以使用 git commit --amend 指令追加改动，尽量避免重复的提交信息。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;祖师爷 Linus 在创造了伟大的 Linux 之后，又创造了应用最广泛的代码管理工具 —— Git，极大地提高了程序员的生产力。 现如今大部分项目都在使用 Git 作为代码管理工具，不论是在代码管理、版本控制以及团队协作上，Git 相比其他版本控制软件都有着无可比拟的优势
      
    
    </summary>
    
    
      <category term="Git学习" scheme="https://cool2feel.github.io/categories/Git%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Git" scheme="https://cool2feel.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Go语言-面向对象三大特性</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-2-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-2-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</id>
    <published>2020-06-16T07:47:57.000Z</published>
    <updated>2020-06-16T08:00:18.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-面向对象三大特性"><a href="#一-面向对象三大特性" class="headerlink" title="一 面向对象三大特性"></a>一 面向对象三大特性</h2><h4 id="1-1-封装"><a href="#1-1-封装" class="headerlink" title="1.1 封装"></a>1.1 封装</h4><p>封装：把抽象出的字段和对字段的操作封装在一起,数据被保护在内部,程序的其它包只有通过被授权的操作(方法),才能对字段进行修改，其作用有：</p><ul><li>隐藏实现细节</li><li>可以对数据进行验证，保证安全合理  </li></ul><p>Golang对面向对象做了极大简化，并不强调封装特性，下列示例进行模拟实现：</p><p>在<code>person</code>包下新建<code>person.go</code>文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> person</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span><span class="comment">//年龄是隐私，不允许其他包访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂函数（类似构造函数）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">person</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">Name: name,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">SetAge</span><span class="params">(age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> age &gt; <span class="number">0</span> &amp;&amp; age &lt; <span class="number">150</span> &#123;<span class="comment">//校验</span></span><br><span class="line">p.age = age</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"年龄不合法"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">GetAge</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> p.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.go</code>文件操作person：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"demo/person"</span><span class="comment">// demo是go mod模式下，整体项目名</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := person.NewPerson(<span class="string">"Tom"</span>)</span><br><span class="line">p.SetAge(<span class="number">18</span>)</span><br><span class="line">fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-继承"><a href="#1-2-继承" class="headerlink" title="1.2 继承"></a>1.2 继承</h4><p>在 Golang 中，如果一个 struct 嵌套了另一个匿名结构体，那么这个结构体可以直接访 问匿名结构体的字段和方法，从而实现了继承特性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Father <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Father)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f.Name + <span class="string">" like running..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Son <span class="keyword">struct</span> &#123;</span><br><span class="line">Father              <span class="comment">//嵌套匿名结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s Son</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.Father.Name = "Tom"</span></span><br><span class="line"><span class="comment">//s.Father.age = 10     //可以访问未导出属性</span></span><br><span class="line"><span class="comment">//s.Father.run()          //可以访问未导出方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上述可以简写为：</span></span><br><span class="line">s.Name = <span class="string">"Tom"</span></span><br><span class="line">s.age = <span class="number">10</span></span><br><span class="line">s.run()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>当结构体和匿名结构体有相同的字段或者方法时，编译器采用就近访问原则访问，如果希望访问匿名结构体的字段和方法，可以通过匿名结构体名来区分。</li><li>结构体嵌入多个匿名结构体，如果两个匿名结构体有相同的字段和方法(同时结构体本身没有同名的字段和方法)，访问时必须明确指定匿名结构体名字，否则编译报错。</li><li>如果一个 struct 嵌套了一个有名结构体，这种模式就是组合，如果是组合关系，那么在访问组合的结构体的字段或方法时，必须带上结构体的名字。  </li></ul><p>关于多重继承：如果一个 struct 嵌套了多个匿名结构体，那么该结构体可以直接访问嵌套的匿名结构体的字段和方法，从而实现多重继承。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Father1 <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Father1)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f.Name + <span class="string">" like running..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Father2 <span class="keyword">struct</span> &#123;</span><br><span class="line">Like <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Son1 <span class="keyword">struct</span> &#123;</span><br><span class="line">Father1</span><br><span class="line">Father2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Son2 <span class="keyword">struct</span> &#123;</span><br><span class="line">*Father1</span><br><span class="line">*Father2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s1 := &amp;Son1 &#123;</span><br><span class="line">Father1&#123;</span><br><span class="line">Name: <span class="string">"Tom"</span>,</span><br><span class="line">age: <span class="number">10</span>,</span><br><span class="line">&#125;,</span><br><span class="line">Father2&#123;</span><br><span class="line">Like: <span class="string">"伏特加"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(s1)</span><br><span class="line"></span><br><span class="line">s2 := &amp;Son2&#123;</span><br><span class="line">&amp;Father1&#123;</span><br><span class="line">Name: <span class="string">"Tom"</span>,</span><br><span class="line">age: <span class="number">10</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&amp;Father2&#123;</span><br><span class="line"> Like: <span class="string">"伏特加"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s2.Father1)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#123;&#123;Tom 10&#125; &#123;伏特加&#125;&#125;</span><br><span class="line">&amp;&#123;Tom 10&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-多态"><a href="#1-3-多态" class="headerlink" title="1.3 多态"></a>1.3 多态</h4><p>多态与接口（interface）有关联，参见接口章节</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-面向对象三大特性&quot;&gt;&lt;a href=&quot;#一-面向对象三大特性&quot; class=&quot;headerlink&quot; title=&quot;一 面向对象三大特性&quot;&gt;&lt;/a&gt;一 面向对象三大特性&lt;/h2&gt;&lt;h4 id=&quot;1-1-封装&quot;&gt;&lt;a href=&quot;#1-1-封装&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Go学习" scheme="https://cool2feel.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Go" scheme="https://cool2feel.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言-面向对象基础</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95/</id>
    <published>2020-06-16T07:46:57.000Z</published>
    <updated>2020-06-16T08:00:06.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-面向对象初识"><a href="#一-面向对象初识" class="headerlink" title="一 面向对象初识"></a>一 面向对象初识</h2><h4 id="1-1-模拟构造函数"><a href="#1-1-模拟构造函数" class="headerlink" title="1.1 模拟构造函数"></a>1.1 模拟构造函数</h4><p>Go和传统的面向对象语言如Java有着很大区别。结构体没有构造函数初始化功能，可以通过以下方式模拟：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPersonByName</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">Name: name,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPersonByAge</span><span class="params">(age <span class="keyword">int</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">Age: age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">p := NewPersonByName(<span class="string">"zs"</span>)</span><br><span class="line">fmt.Println(p)<span class="comment">// &#123;zs 0&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贴士：因为Go没有函数重载，为了避免函数名字冲突，使用了<code>NewPersonByName</code>和<code>NewPersonByAge</code>两个不同的函数表示不同的<code>Person</code>构造过程。</p><h4 id="1-2-父子关系结构体初始化"><a href="#1-2-父子关系结构体初始化" class="headerlink" title="1.2 父子关系结构体初始化"></a>1.2 父子关系结构体初始化</h4><p>Person可以看做父类，Student是子类，子类需要继承父类的成员：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Person</span><br><span class="line">ClassName <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造父类</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">Name: name,</span><br><span class="line">Age: age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造子类</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(classname <span class="keyword">string</span>)</span> *<span class="title">Student</span></span> &#123;</span><br><span class="line">p := &amp;Student&#123;&#125;</span><br><span class="line">p.ClassName = classname</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s := NewStudent(<span class="string">"一班"</span>)</span><br><span class="line">fmt.Println(s)<span class="comment">// &amp;&#123;&#123; 0&#125; 一班&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-Go中的面向对象初识"><a href="#1-3-Go中的面向对象初识" class="headerlink" title="1.3 Go中的面向对象初识"></a>1.3 Go中的面向对象初识</h4><p>在Go中，可以给任意类型（除了指针）添加相应方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interger <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Interger)</span> <span class="title">Less</span> <span class="params">(j Interger)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> i &lt; j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i Interger = <span class="number">1</span></span><br><span class="line">fmt.Print(i.Less(<span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-方法"><a href="#二-方法" class="headerlink" title="二 方法"></a>二 方法</h2><h4 id="2-1-方法"><a href="#2-1-方法" class="headerlink" title="2.1 方法"></a>2.1 方法</h4><p>Golang 中的方法是作用在指定的数据类型上的(即:和指定的数据类型绑定)，因此自定义类型，都可以有方法，而不仅仅是 struct。  </p><p>方法的声明和调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recevier <span class="keyword">type</span>)</span> <span class="title">methodName</span><span class="params">(参数列表)</span> <span class="params">(返回值列表)</span></span>&#123; </span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法与函数的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个run函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(p *Person, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">p.Name = name</span><br><span class="line">fmt.Println(<span class="string">"函数 run..."</span>, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个run方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span><span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"方法 run..."</span>, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个对象（结构体）</span></span><br><span class="line">p1 := &amp;Person&#123;</span><br><span class="line"><span class="string">"ruyue"</span>,</span><br><span class="line"><span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行一个普通方法</span></span><br><span class="line">run(p1, <span class="string">"张三"</span>)<span class="comment">// 输出 函数 run... 张三</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行方法</span></span><br><span class="line">p1.run()<span class="comment">// 输出 方法 run... 张三</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-Go方法本质"><a href="#2-2-Go方法本质" class="headerlink" title="2.2 Go方法本质"></a>2.2 Go方法本质</h4><p>Go的方法是一种作用于特定类型变量的函数，这种特定类型的变量叫做接收器（Receiver）。如果特定类型理解为结构体或者“类”时，接收器就类似于其他语言的this或者self。  </p><p>在Go中，接收器可以是任何类型，不仅仅是结构体，依此我们看出，Go中的方法和其他语言的方法类似，但是Go语言的接收器强调方法的作用对象是实例。</p><p>方法与函数的区别就是：函数没有作用对象。</p><p>上述Person案例中，接收器类型是<code>*Person</code>，属于指针类型，非常接近Java中的<code>this</code>，由于指针的特性，调用方法时，修改接收器指针的任意长远变量，在方法结束后，修改都是有效的。  </p><p>当方法作用于非指针接收器时，Go语言会在代码运行时将接收器的值复制一份，在非指针接收器的方法中可以获取接收器的成员值，但修改后无效，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个表示点的结构体</span></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="keyword">int</span></span><br><span class="line">Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非指针接收器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">Add</span><span class="params">(otherP Point)</span> <span class="title">Point</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Point&#123;</span><br><span class="line">p.X + otherP.X,</span><br><span class="line">p.Y + otherP.Y,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">p1 := Point&#123;<span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">p2 := Point&#123;<span class="number">2</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">result := p1.Add(p2)</span><br><span class="line"></span><br><span class="line">fmt.Println(result)<span class="comment">// &#123;3 3&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，小对象由于复制时速度较快，适合使用非指针接收器，大对象因为复制性能较低，适合使用指针接收器，此时再接收器和参数之间传递时不进行复制，只传递指针。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-面向对象初识&quot;&gt;&lt;a href=&quot;#一-面向对象初识&quot; class=&quot;headerlink&quot; title=&quot;一 面向对象初识&quot;&gt;&lt;/a&gt;一 面向对象初识&lt;/h2&gt;&lt;h4 id=&quot;1-1-模拟构造函数&quot;&gt;&lt;a href=&quot;#1-1-模拟构造函数&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Go学习" scheme="https://cool2feel.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Go" scheme="https://cool2feel.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言-结构体</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-4-%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-4-%E7%BB%93%E6%9E%84%E4%BD%93/</id>
    <published>2020-06-16T07:24:57.000Z</published>
    <updated>2020-06-16T08:03:25.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-结构体的基本使用"><a href="#一-结构体的基本使用" class="headerlink" title="一 结构体的基本使用"></a>一 结构体的基本使用</h2><p>结构体可以用来声明新的类型，作为其他类型的属性/字段的容器，如下定义一个学生结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按顺序初始化：每个成员都必须初始化</span></span><br><span class="line"><span class="keyword">var</span> p1 Person = Person&#123;<span class="string">"lisi"</span>, <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制定成员初始化：没有被初始化的，自动赋零值</span></span><br><span class="line">p2 := Person&#123;age:<span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 申请结构体</span></span><br><span class="line">p3 := <span class="built_in">new</span>(Person)      <span class="comment">//被new生成的结构体实例其实是指针类型</span></span><br><span class="line">p3.name = <span class="string">"zs"</span>          <span class="comment">//这里的.语法只是语法糖，将p3.name转换成了(*p3).name</span></span><br><span class="line">p3.age = <span class="number">27</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接声明</span></span><br><span class="line"><span class="keyword">var</span> s4 Person</span><br><span class="line">p4.name = <span class="string">"ww"</span></span><br><span class="line">p4.age = <span class="number">30</span></span><br></pre></td></tr></table></figure><p>贴士：</p><ul><li>struct的结构中的类型可以是任意类型，且存储空间是连续的，其字段按照声明时的顺序存放  </li><li>如果结构体的所有的成员都是可以比较的，那么结构体本身也是可以比较的，使用 == != ，不支持 &gt; 和 &lt;</li><li>如果结构体的成员要被包外调用，需要大写首字母。</li></ul><h2 id="二-结构体地址与实例化"><a href="#二-结构体地址与实例化" class="headerlink" title="二 结构体地址与实例化"></a>二 结构体地址与实例化</h2><p>前面说过，对结构体的new其实是生成了一个指针类型。其实对结构体进行<code>&amp;</code>取地址操作时，也可以视为对该类型进行一次<code>new</code>的实例化操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ins := &amp;T&#123;&#125;</span><br><span class="line"></span><br><span class="line"># T是结构体类型</span><br><span class="line"># ins为结构体的实例，类型为*T，是指针类型</span><br></pre></td></tr></table></figure><h2 id="四-内嵌结构体"><a href="#四-内嵌结构体" class="headerlink" title="四 内嵌结构体"></a>四 内嵌结构体</h2><p>当前结构体可以直接访问其内嵌结构体的内部字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Animal</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Person</span><br><span class="line">ClassName <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方式1</span></span><br><span class="line">s1 := Student&#123;</span><br><span class="line">Person&#123;</span><br><span class="line">Animal: Animal &#123;</span><br><span class="line">Age: <span class="number">15</span>,</span><br><span class="line">&#125;,</span><br><span class="line">Name:<span class="string">"lisi"</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"一班"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s1.Age)<span class="comment">// 正确输出15</span></span><br><span class="line">fmt.Println(s1.Person.Name)<span class="comment">// 正确输出lisi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方式2</span></span><br><span class="line"><span class="keyword">var</span> s2 Student</span><br><span class="line">s2.Name = <span class="string">"zs"</span></span><br><span class="line">s2.Age = <span class="number">30</span></span><br><span class="line">s2.ClassName = <span class="string">"二班"</span></span><br><span class="line">fmt.Println(s2.Age)<span class="comment">// 正确输出30</span></span><br><span class="line">fmt.Println(s2.Person.Name)<span class="comment">// 正确输出zs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-匿名字段"><a href="#四-匿名字段" class="headerlink" title="四 匿名字段"></a>四 匿名字段</h2><p>结构体的字段名与类型一一对应，如果不提供名字，则为匿名字段。</p><p>匿名字段如果是一个struct，这个struct拥有的全部字段都被隐式引入了当前的struct。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person                   <span class="comment">// 匿名字段，那么默认Student就包含了Human的所有字段</span></span><br><span class="line">    classroom <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅仅是struct，其他所有内置类型和自定义类型都可以作为匿名字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> course []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Person <span class="comment">// 匿名字段，struct</span></span><br><span class="line">course<span class="comment">// 内置一个切片类型</span></span><br><span class="line">classroom <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个学生</span></span><br><span class="line">s := Student&#123;Person:Person&#123;<span class="string">"LiLei"</span>, <span class="number">17</span>&#125;, classroom:<span class="string">"二班"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问该学生字段</span></span><br><span class="line">fmt.Println(<span class="string">"name = "</span>, s.name)</span><br><span class="line">fmt.Println(<span class="string">"classroom =  "</span>, s.classroom)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改学生的课程</span></span><br><span class="line">s.course = []<span class="keyword">string</span>&#123;<span class="string">"语文"</span>, <span class="string">"美术"</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"course = "</span>, s.course)<span class="comment">// [语文 美术]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贴士：如果Person和Student中都有同一个字段，那么Go会优先访问当前层。例如二者都有<code>tel</code>字段，那么<code>s.tel</code>将会访问的是Student中的数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-结构体的基本使用&quot;&gt;&lt;a href=&quot;#一-结构体的基本使用&quot; class=&quot;headerlink&quot; title=&quot;一 结构体的基本使用&quot;&gt;&lt;/a&gt;一 结构体的基本使用&lt;/h2&gt;&lt;p&gt;结构体可以用来声明新的类型，作为其他类型的属性/字段的容器，如下定义一个学生
      
    
    </summary>
    
    
      <category term="Go学习" scheme="https://cool2feel.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Go" scheme="https://cool2feel.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言-数组</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-3-%E6%95%B0%E7%BB%84/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-3-%E6%95%B0%E7%BB%84/</id>
    <published>2020-06-16T07:24:57.000Z</published>
    <updated>2020-06-16T08:03:12.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-数组"><a href="#一-数组" class="headerlink" title="一 数组"></a>一 数组</h2><h4 id="1-1-数组的声明"><a href="#1-1-数组的声明" class="headerlink" title="1.1 数组的声明"></a>1.1 数组的声明</h4><p>数组是一段固定长度的连续内存区域。数组的长度定义后不可更改，长度使用 len() 获取。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 [<span class="number">10</span>]<span class="keyword">int</span><span class="comment">//定义长度为10的整型数组，很少这样使用</span></span><br><span class="line">arr2 [<span class="number">5</span>]<span class="keyword">int</span> := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;<span class="comment">//定义并初始化</span></span><br><span class="line">arr3 := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;<span class="comment">//自动推导并初始化</span></span><br><span class="line">arr4 := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;<span class="comment">//指定总长度，前几位被初始化，没有的使用零值</span></span><br><span class="line">arr5 := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>:<span class="number">10</span>, <span class="number">4</span>:<span class="number">11</span>&#125;<span class="comment">//有选择的初始化，没被初始化的使用零值</span></span><br><span class="line">arr6 := [...]<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;<span class="comment">//自动计算长度</span></span><br></pre></td></tr></table></figure><h4 id="1-2-数组常用操作"><a href="#1-2-数组常用操作" class="headerlink" title="1.2 数组常用操作"></a>1.2 数组常用操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr[:]      代表所有元素</span><br><span class="line">arr[:5]     代表前五个元素，即区间的左闭右开</span><br><span class="line">arr[5:]     代表从第5个开始（不包含第5个）</span><br><span class="line">len(arr)    数组的长度</span><br></pre></td></tr></table></figure><p>贴士：上述操作会引发类型的变化，数组将会转化为Go中新的数据类型slice，见09节</p><h4 id="1-3-数组的遍历"><a href="#1-3-数组的遍历" class="headerlink" title="1.3 数组的遍历"></a>1.3 数组的遍历</h4><p>方式一：for循环遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">fmt.Println(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：for-range遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">fmt.Println(k)<span class="comment">//元素位置</span></span><br><span class="line">fmt.Println(v)<span class="comment">//元素值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-数组使用注意事项"><a href="#1-4-数组使用注意事项" class="headerlink" title="1.4 数组使用注意事项"></a>1.4 数组使用注意事项</h4><p>数组创建完长度就固定，不可以再追加元素；  </p><p>长度是数组类型的一部分，因此<code>[3]int</code>与<code>[4]int</code>是不同的类型；  </p><p>数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该函数的副本，而不是他的指针。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-数组&quot;&gt;&lt;a href=&quot;#一-数组&quot; class=&quot;headerlink&quot; title=&quot;一 数组&quot;&gt;&lt;/a&gt;一 数组&lt;/h2&gt;&lt;h4 id=&quot;1-1-数组的声明&quot;&gt;&lt;a href=&quot;#1-1-数组的声明&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="Go学习" scheme="https://cool2feel.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Go" scheme="https://cool2feel.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言-函数2-闭包</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%87%BD%E6%95%B0-2-%E9%97%AD%E5%8C%85/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%87%BD%E6%95%B0-2-%E9%97%AD%E5%8C%85/</id>
    <published>2020-06-16T07:24:57.000Z</published>
    <updated>2020-06-16T07:58:15.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-闭包"><a href="#一-闭包" class="headerlink" title="一 闭包"></a>一 闭包</h2><h4 id="1-1-闭包概念"><a href="#1-1-闭包概念" class="headerlink" title="1.1 闭包概念"></a>1.1 闭包概念</h4><p>闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使己经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量。  </p><p>简单的说 : 函数+引用环境=闭包  </p><p>贴士：闭包( Closure)在某些编程语言中也被称为 Lambda表达式（如Java）</p><p>在闭包中可以修改引用的变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello"</span></span><br><span class="line">foo := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;<span class="comment">// 声明一个匿名函数</span></span><br><span class="line">str = <span class="string">"world"</span></span><br><span class="line">&#125;</span><br><span class="line">foo()<span class="comment">//  调用匿名函数，修改str值</span></span><br><span class="line">fmt.Print(str)<span class="comment">// world</span></span><br></pre></td></tr></table></figure><h4 id="1-2-闭包案例一-简单示例"><a href="#1-2-闭包案例一-简单示例" class="headerlink" title="1.2 闭包案例一  简单示例"></a>1.2 闭包案例一  简单示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn1</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="built_in">print</span>(&amp;a, a)</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">f := fn1(<span class="number">1</span>)<span class="comment">//输出地址</span></span><br><span class="line">g := fn1(<span class="number">2</span>)<span class="comment">//输出地址</span></span><br><span class="line"></span><br><span class="line">fmt.Println(f(<span class="number">1</span>))<span class="comment">//输出1</span></span><br><span class="line">fmt.Println(f(<span class="number">1</span>))<span class="comment">//输出1</span></span><br><span class="line"></span><br><span class="line">fmt.Println(g(<span class="number">2</span>))<span class="comment">//输出2</span></span><br><span class="line">fmt.Println(g(<span class="number">2</span>))<span class="comment">//输出2</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-闭包案例二-实现累加器"><a href="#1-3-闭包案例二-实现累加器" class="headerlink" title="1.3 闭包案例二 实现累加器"></a>1.3 闭包案例二 实现累加器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Accumulate</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;<span class="comment">// 返回一个闭包</span></span><br><span class="line">value++</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">accAdd := Accumulate(<span class="number">1</span>)</span><br><span class="line">fmt.Println(accAdd())<span class="comment">// 2</span></span><br><span class="line">fmt.Println(accAdd())<span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-闭包&quot;&gt;&lt;a href=&quot;#一-闭包&quot; class=&quot;headerlink&quot; title=&quot;一 闭包&quot;&gt;&lt;/a&gt;一 闭包&lt;/h2&gt;&lt;h4 id=&quot;1-1-闭包概念&quot;&gt;&lt;a href=&quot;#1-1-闭包概念&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
      <category term="Go学习" scheme="https://cool2feel.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Go" scheme="https://cool2feel.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言-函数1</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%87%BD%E6%95%B0-1-%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%87%BD%E6%95%B0-1-%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B/</id>
    <published>2020-06-16T07:24:57.000Z</published>
    <updated>2020-06-16T07:57:49.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-函数"><a href="#一-函数" class="headerlink" title="一 函数"></a>一 函数</h2><h4 id="1-1-函数声明"><a href="#1-1-函数声明" class="headerlink" title="1.1 函数声明"></a>1.1 函数声明</h4><p>函数声明格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名字 <span class="params">(参数列表)</span> <span class="params">(返回值列表）&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">// 函数体</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">return</span> 返回值列表</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>函数名首字母小写为私有，大写为公有；</li><li>参数列表可以有0-多个，多参数使用逗号分隔，不支持默认参数；</li><li>返回值列表返回值类型可以不用写变量名</li><li>如果只有一个返回值且不声明类型，可以省略返回值列表与括号</li><li>如果有返回值，函数内必须有return</li></ul><p>Go中函数常见写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无返回值，默认返回0，所以也可以写为 func fn() int &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn</span><span class="params">()</span></span>&#123;&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Go推荐给函数返回值起一个变量名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn1</span><span class="params">()</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种返回值写法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn2</span><span class="params">()</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">result = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多返回值情</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn3</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Go返回值推荐多返回值写法：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn4</span><span class="params">()</span> <span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>, c <span class="keyword">int</span>)</span></span> &#123;多个参数类型如果相同，可以简写为： a,b <span class="keyword">int</span></span><br><span class="line">   a , b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">   <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-值传递和引用传递"><a href="#1-2-值传递和引用传递" class="headerlink" title="1.2 值传递和引用传递"></a>1.2 值传递和引用传递</h4><p>不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝决定拷贝的 数据大小，数据越大，效率越低。  </p><p>如果希望函数内的变量能修改函数外的变量，可以传入变量的地址&amp;，函数内以指针的方式操作变量。</p><h4 id="1-3-可变参数"><a href="#1-3-可变参数" class="headerlink" title="1.3 可变参数"></a>1.3 可变参数</h4><p>可变参数变量是一个包含所有参数的切片。如果要在多个可变参数中传递参数 ，可以在传递时在可变参数变量中默认添 加“ …”，将切片中的元素进行传递，而不是传递可变参数变量本身。</p><p>示例：对可变参数列表进行遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">joinStrings</span><span class="params">(slist ...<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> slist &#123;</span><br><span class="line">buf.WriteString(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(joinStrings(<span class="string">"pig"</span>, <span class="string">" and"</span>, <span class="string">" bird"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：参数传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际打印函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rawPrint</span><span class="params">(rawList ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> rawList &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装打印函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(slist ...<span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line"><span class="comment">// 将slist可变参数切片完整传递给下一个函数</span></span><br><span class="line">rawPrint(slist...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-匿名函数"><a href="#1-4-匿名函数" class="headerlink" title="1.4 匿名函数"></a>1.4 匿名函数</h4><p>匿名函数可以看做函数字面量，所有直接使用函数类型变量的地方都可以由匿名函数代替。匿名函数可以直接赋值给函数变量，可以当做实参，也可以作为返回值使用，还可以直接被调用。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">   a := <span class="number">3</span></span><br><span class="line">   f1 := <span class="function"><span class="keyword">func</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;    <span class="comment">// f1 即为匿名函数</span></span><br><span class="line">      fmt.Println(num) <span class="comment">// 匿名函数访问外部变量</span></span><br><span class="line">   &#125;</span><br><span class="line">   f1(a)</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;         <span class="comment">// 匿名函数自调</span></span><br><span class="line">      fmt.Println(a)</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名函数实战：取最大值,最小值</span></span><br><span class="line">x, y := <span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="params">(max,min <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> i &gt; j &#123;</span><br><span class="line">      max = i</span><br><span class="line">      min = j</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      max = j</span><br><span class="line">      min = i</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">fmt.Println(x + <span class="string">' '</span> + y)</span><br></pre></td></tr></table></figure><h4 id="1-5-函数类型"><a href="#1-5-函数类型" class="headerlink" title="1.5 函数类型"></a>1.5 函数类型</h4><p>函数去掉函数名、参数名和{}后的结果即是函数类型，可以使用%T打印该结果。  </p><p>两个函数类型相同的前提是：拥有相同的形参列表和返回值列表，且列表元素的次序、类型都相同，形参名可以不同。  </p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mathSum</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mathSub</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个函数类型</span></span><br><span class="line"><span class="keyword">type</span> MyMath <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义的函数类型作为参数使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(f MyMath, a , b <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> f(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常可以把函数类型当做一种引用类型，实际函数类型变量和函数名都可以当做指针变量，只想函数代码开始的位置，没有初始化的函数默认值是nil。</p><h2 id="二-Go函数特性总结"><a href="#二-Go函数特性总结" class="headerlink" title="二 Go函数特性总结"></a>二 Go函数特性总结</h2><ul><li>支持有名称的返回值；</li><li>不支持默认值参数；</li><li>不支持重载；</li><li>不支持命名函数嵌套，匿名函数可以嵌套；</li><li>Go函数从实参到形参的传递永远是值拷贝，有时函数调用后实参指向的值发生了变化，是因为参数传递的是指针的拷贝，实参是一个指针变量，传递给形参的是这个指针变量的副本，实质上仍然是值拷贝；</li><li>Go函数支持不定参数；</li></ul><h2 id="三-两个特殊函数"><a href="#三-两个特殊函数" class="headerlink" title="三 两个特殊函数"></a>三 两个特殊函数</h2><h4 id="3-1-init函数"><a href="#3-1-init函数" class="headerlink" title="3.1 init函数"></a>3.1 init函数</h4><p>Go语言中，除了可以在全局声明中初始化实体，也可以在init函数中初始化。init函数是一个特殊的函数，它会在包完成初始化后自动执行，执行优先级高于main函数，并且不能手动调用init函数，每一个文件有且仅有一个init函数，初始化过程会根据包的以来关系顺序单线程执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//在这里可以书写一些初始化操作</span></span><br><span class="line">fmt.Println(<span class="string">"init..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"main..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-new函数"><a href="#3-2-new函数" class="headerlink" title="3.2 new函数"></a>3.2 new函数</h4><p>new函数可以用来创建变量。表达式<code>new(T)</code>将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为<code>*T</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="keyword">int</span>)<span class="comment">// p 为 *int类型，只想匿名的int变量</span></span><br><span class="line">fmt.Println(*p)<span class="comment">// "0"</span></span><br><span class="line">*p = <span class="number">2</span><span class="comment">// 设置 int匿名变量值为2</span></span><br><span class="line">fmt.Println(*p)</span><br></pre></td></tr></table></figure><p>new函数还可以用来为结构体创建实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">f := <span class="built_in">new</span>(file)</span><br></pre></td></tr></table></figure><p>贴士：new函数其实是语法糖，不是新概念，如下所示的两个函数其实拥有相同的行为。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInt1</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInt2</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> dummy <span class="keyword">int</span></span><br><span class="line"><span class="keyword">return</span> &amp;dummy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>new</code>只是一个预定义函数，并不是一个关键字，所以<code>new</code>也有可能会被项目定义为别的类型。</p><h4 id="3-3-make函数"><a href="#3-3-make函数" class="headerlink" title="3.3 make函数"></a>3.3 make函数</h4><p>make函数经常用来创建切片、Map、管道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>上面展示了两种map的创建方式，其不同点是第一种创建方式无法预估长度，当长度超过了当前长度时，会引起内存的拷贝！！第二种创建方式直接限定了长度，这样能有效提升性能！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-函数&quot;&gt;&lt;a href=&quot;#一-函数&quot; class=&quot;headerlink&quot; title=&quot;一 函数&quot;&gt;&lt;/a&gt;一 函数&lt;/h2&gt;&lt;h4 id=&quot;1-1-函数声明&quot;&gt;&lt;a href=&quot;#1-1-函数声明&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
      <category term="Go学习" scheme="https://cool2feel.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Go" scheme="https://cool2feel.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言介绍</title>
    <link href="https://cool2feel.github.io/2020/06/16/Go%E7%AE%80%E4%BB%8B/"/>
    <id>https://cool2feel.github.io/2020/06/16/Go%E7%AE%80%E4%BB%8B/</id>
    <published>2020-06-16T07:24:57.000Z</published>
    <updated>2020-06-16T07:25:21.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-Go语言介绍"><a href="#一-Go语言介绍" class="headerlink" title="一 Go语言介绍"></a>一 Go语言介绍</h2><p>Go语言是Google公司开发的一种静态、编译型语言，具备自动垃圾回收功能，原生支持并发开发。   </p><p>Go的诞生是为了解决当下编程语言对并发支持不友好、编译速度慢、编程复杂这三个主要问题。   </p><p>Go既拥有接近静态编译语言（如C）的安全和性能，又有接近脚本语言（如python）的开发效率，其主要特点有：   </p><ul><li>天然并发：语言层面支持并发，包括gorotuine、channel</li><li>语法优势：没有历史包袱，包含多返回值、匿名函数、defer</li><li>语言层面支持多核CPU利用</li></ul><p>与Java相比的不同：</p><ul><li>没有Java支持的一些面向对象思想：重载、构造函数、继承等</li><li>代码规范严格：花括号位置固定，变量名大小写代表公有私有等</li><li>支持函数式编程：匿名函数，闭包</li><li>接口非侵入式：不需要显式声明对接口的继承，实现了接口的方法即为实现了该接口类型</li></ul><h2 id="二-Go安装"><a href="#二-Go安装" class="headerlink" title="二 Go安装"></a>二 Go安装</h2><p>推荐使用官方的安装包直接安装，下载地址：<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a>   </p><p>贴士：本笔记都是基于go1.13    </p><p><strong>Win安装Go</strong>：<br>打开Win安装包下一步下一步即可，默认安装在目录：c:\Go  </p><p><strong>Mac安装Go</strong>：<br>打开Mac安装包下一步下一步即可，需要预装Xcode。安装完毕后需配置环境变量即可使用，但是如果要使用一些<code>go mod</code>功能推荐如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.bash_profile</span><br><span class="line"></span><br><span class="line">export GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go                 # golang本身的安装位置</span><br><span class="line">export GOPATH&#x3D;~&#x2F;go&#x2F;                         # golang包的本地安装位置</span><br><span class="line">export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.io           # golang包的下载代理</span><br><span class="line">export GO111MODULE&#x3D;on                       # 开启go mod模式</span><br><span class="line">export PATH&#x3D;$PATH:$GOROOT&#x2F;bin               # go本身二进制文件的环境变量</span><br><span class="line">export PATH&#x3D;$PATH:$GOPATH&#x2F;bin               # go第三方二进制文件的环境便令</span><br><span class="line"></span><br><span class="line"># 重启环境</span><br><span class="line">source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure><p><strong>Linux安装Go</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 下载解压</span><br><span class="line">wget https:&#x2F;&#x2F;dl.google.com&#x2F;go&#x2F;go1.13.1.linux-amd64.tar.gz</span><br><span class="line">tar zxvf go*.tar.gz -C &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line"></span><br><span class="line"># 配置环境：注意该环境必须是go1.11版本及以上且项目要求使用go mod才可以开启</span><br><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line">export GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go                 # golang本身的安装位置</span><br><span class="line">export GOPATH&#x3D;~&#x2F;go                          # golang包的本地安装位置</span><br><span class="line">export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.io,direct    # golang包的下载代理,回源地址获取</span><br><span class="line">export GO111MODULE&#x3D;on                       # 开启go mod模式</span><br><span class="line">export PATH&#x3D;$PATH:$GOROOT&#x2F;bin               # go本身二进制文件的环境变量</span><br><span class="line">export PATH&#x3D;$PATH:$GOPATH&#x2F;bin               # go第三方二进制文件的环境便令</span><br><span class="line"></span><br><span class="line"># 重启环境</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>测试安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看go版本</span><br><span class="line">go version</span><br><span class="line"></span><br><span class="line"># 查看go环境配置</span><br><span class="line">go env</span><br></pre></td></tr></table></figure><p>关于<code>go modules</code>的详细讲解位于本章12节。</p><h2 id="三-HelloWorld"><a href="#三-HelloWorld" class="headerlink" title="三 HelloWorld"></a>三 HelloWorld</h2><p>新建文件<code>hello.go</code>，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main                        <span class="comment">//每个程序都有且仅有一个main包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span>    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;                       <span class="comment">//主函数main只有一个</span></span><br><span class="line">    fmt.Println(<span class="string">"Hello World!"</span>)     <span class="comment">//函数调用：包名.函数名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 执行方式一：先编译，再运行</span><br><span class="line">go build hello.go        # 编译。在同级目录下生成文件&#96;hello&#96;，添加参数&#96;-o 名称&#96; 则可指定生成的文件名 </span><br><span class="line">.&#x2F;hello                  # 运行。贴士：win下生成的是.exe文件，直接双击执行即可</span><br><span class="line"></span><br><span class="line"># 执行方式二：直接运行</span><br><span class="line">go run hello.go</span><br></pre></td></tr></table></figure><p>两种执行流程的区别：  </p><ul><li>先编译方式：可执行文件可以在任意没有go环境的机器上运行，（因为go依赖被打包进了可执行文件）</li><li>直接执行方式：源码执行时，依赖于机器上的go环境，没有go环境无法直接运行</li></ul><h2 id="四-Go语法注意"><a href="#四-Go语法注意" class="headerlink" title="四 Go语法注意"></a>四 Go语法注意</h2><ul><li>Go源文件以 “go” 为扩展名</li><li>与Java、C语言类似，Go应用程序的执行入口也是main()函数</li><li>Go语言严格区分大小写</li><li>Go不需要分号结尾</li><li>Go编译是一行一行执行，所以不能将类似两个 Print 函数写在一行</li><li>Go语言定义的变量或者import的包如果没有使用到，代码不能编译通过</li><li>Go的注释使用 // 或者 /*  */</li></ul><h2 id="五-开发工具推荐"><a href="#五-开发工具推荐" class="headerlink" title="五 开发工具推荐"></a>五 开发工具推荐</h2><p>笔者推荐的go开发工具：</p><ul><li>goland</li><li>vscode</li></ul><p>vscode的相关go插件会出现无法下载情况，解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 如果开启了go mod，则</span><br><span class="line">    go get -u -v github.com&#x2F;ramya-rao-a&#x2F;go-outline</span><br><span class="line">    go get -u -v github.com&#x2F;acroca&#x2F;go-symbols</span><br><span class="line">    go get -u -v golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;guru</span><br><span class="line">    go get -u -v golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;gorename</span><br><span class="line">    go get -u -v github.com&#x2F;rogpeppe&#x2F;godef</span><br><span class="line">    go get -u -v github.com&#x2F;sqs&#x2F;goreturns</span><br><span class="line">    go get -u -v github.com&#x2F;cweill&#x2F;gotests&#x2F;gotests</span><br><span class="line">    go get -u -v golang.org&#x2F;x&#x2F;lint&#x2F;golint</span><br><span class="line"></span><br><span class="line"># 如果未开启go mod，则需要进入cd $GOPATH&#x2F;src ，使用 git clone 下载上述文件        </span><br><span class="line"></span><br><span class="line"># 安装</span><br><span class="line">cd $GOPATH</span><br><span class="line">    go install github.com&#x2F;ramya-rao-a&#x2F;go-outline</span><br><span class="line">    go install github.com&#x2F;acroca&#x2F;go-symbols</span><br><span class="line">    go install golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;guru</span><br><span class="line">    go install golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;gorename</span><br><span class="line">    go install github.com&#x2F;rogpeppe&#x2F;godef</span><br><span class="line">    go install github.com&#x2F;sqs&#x2F;goreturns</span><br><span class="line">    go install github.com&#x2F;cweill&#x2F;gotests&#x2F;gotests</span><br><span class="line">    go install golang.org&#x2F;x&#x2F;lint&#x2F;golint</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-Go语言介绍&quot;&gt;&lt;a href=&quot;#一-Go语言介绍&quot; class=&quot;headerlink&quot; title=&quot;一 Go语言介绍&quot;&gt;&lt;/a&gt;一 Go语言介绍&lt;/h2&gt;&lt;p&gt;Go语言是Google公司开发的一种静态、编译型语言，具备自动垃圾回收功能，原生支持并发开发
      
    
    </summary>
    
    
      <category term="Go学习" scheme="https://cool2feel.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Go" scheme="https://cool2feel.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言-字符串</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-2-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-2-%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-06-16T07:24:57.000Z</published>
    <updated>2020-06-16T08:03:00.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-字符"><a href="#一-字符" class="headerlink" title="一 字符"></a>一 字符</h2><p>Golang 中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存，且使用单引号包裹。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 <span class="keyword">byte</span> = <span class="string">'a'</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="keyword">byte</span> = <span class="string">'0'</span></span><br><span class="line">fmt.Println(<span class="string">"c1="</span>, c1)<span class="comment">//输出 97   </span></span><br><span class="line">fmt.Println(<span class="string">"c2="</span>, c2)<span class="comment">//输出48</span></span><br><span class="line">fmt.Printf(<span class="string">"c1=%c,c2=%c\n"</span>, c1, c2)    <span class="comment">//输出原值 a 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//var c3 byte = '北'</span></span><br><span class="line"><span class="comment">//fmt.Printf("c3=%c", c3)// 溢出错误:overflows byte</span></span><br></pre></td></tr></table></figure><p>贴士：</p><ul><li>字符类型也可以用<code>d%</code>打印为整型</li><li>如果我们保存的字符在 ASCII 表的,比如[0-1, a-z,A-Z..]直接可以保存到 byte</li><li>如果我们保存的字符对应码值大于 255,这时我们可以考虑使用 int 类型保存</li><li>如果我们需要安装字符的方式输出，这时我们需要格式化输出，即 fmt.Printf(“%c”, c1)</li><li>字符可以和整型进行运算</li></ul><h2 id="二-字符串"><a href="#二-字符串" class="headerlink" title="二 字符串"></a>二 字符串</h2><p>传统的字符串是由字符组成的，而Go的字符串是由单个字节连接起来的，即Go字符串是一串固定长度的字符连接起来的字符序列。  </p><p>字符串在Go语言中是基本类型，内容在初始化后不能修改。  </p><p>Go中的字符串都是采用UTF-8字符集编码，使用一对双引号<code>&quot;&quot;</code>或反引号<code>``</code>定义。<code>``</code>可以额外解析换行，即其没有字符转义功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 <span class="keyword">string</span></span><br><span class="line">str1 = <span class="string">"Hello "</span></span><br><span class="line">str2 := <span class="string">" World!"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(str1[<span class="number">0</span>])     <span class="comment">// 输出字符串第一个字符 72</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(str1))   <span class="comment">// 输出长度 6</span></span><br><span class="line">fmt.Println(str1 + str2) <span class="comment">// 输出不带空格的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串不可变，编译报错： cannot assign to 因为</span></span><br><span class="line"><span class="comment">// str1[0] = 'c'</span></span><br></pre></td></tr></table></figure><p>由于Go中的字符串不可直接改变，可以使用下列两种方式进行修改：</p><p>方式一：通过转换为字节数组<code>[]byte</code>类型，构造一个临时字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">strTemp := []<span class="keyword">byte</span>(str)</span><br><span class="line">fmt.Println(<span class="string">"strTemp="</span>, strTemp)<span class="comment">// [104 101 108 108 111]</span></span><br><span class="line"></span><br><span class="line">strTemp[<span class="number">0</span>] = <span class="string">'c'</span></span><br><span class="line">strResult := <span class="keyword">string</span>(strTemp)</span><br><span class="line">fmt.Println(<span class="string">"strResult="</span>, strResult)<span class="comment">// strResult= cello</span></span><br></pre></td></tr></table></figure><p>方式二：使用切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello"</span></span><br><span class="line">str = <span class="string">"c"</span>+ str[<span class="number">1</span>:]<span class="comment">// 1: 表示从第1位开始到最后</span></span><br></pre></td></tr></table></figure><p>Go和Java等语言一样，字符串默认是不可变的，这样保证了线程安全，大家使用的都是只读对象，无须加锁，且能很方便的共享内存，不必使用写时复制。</p><h2 id="三-字符串常用操作"><a href="#三-字符串常用操作" class="headerlink" title="三 字符串常用操作"></a>三 字符串常用操作</h2><h4 id="3-1-len-函数与字符串遍历"><a href="#3-1-len-函数与字符串遍历" class="headerlink" title="3.1 len()函数与字符串遍历"></a>3.1 len()函数与字符串遍历</h4><p>len()函数是go语言的内建函数，可以用来获取字符串、切片、通道等的长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unicode/utf8"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">str1 := <span class="string">"hello world"</span></span><br><span class="line">str2 := <span class="string">"你好，"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(str1))<span class="comment">// 11</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(str2))<span class="comment">// 9</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(str2))<span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个函数输出11很容易理解，第二个函数却输出了9，理论上我们会认为应该是3才对。这是因为Go的字符串都是以UTF-8格式保存，每个中文占据3个字节。Go中计算UTF-8字符串格式的长度应该使用<code>utf8.RuneCountInString</code>。</p><p>字符串遍历方式一：使用字节数组，注意每个中文在UTF-8中占据3个字节</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">fmt.Println(i,str[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串遍历方式二：range关键字只是第一种遍历方式的简写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"你好"</span></span><br><span class="line"><span class="keyword">for</span> i,ch := <span class="keyword">range</span> str &#123;</span><br><span class="line">fmt.Println(i,ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：由于上述len()函数本身原因，Unicode字符遍历需要使用range。</p><h4 id="3-2-string-函数类型转换"><a href="#3-2-string-函数类型转换" class="headerlink" title="3.2 string()函数类型转换"></a>3.2 string()函数类型转换</h4><p>go的内建函数 <code>string()</code>可以将其他类型转变为字符串类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num := <span class="number">12</span></span><br><span class="line">fmt.Printf(<span class="string">"%T \n"</span>, <span class="keyword">string</span>(num))<span class="comment">// string</span></span><br></pre></td></tr></table></figure><h4 id="3-3-字符串连接"><a href="#3-3-字符串连接" class="headerlink" title="3.3 字符串连接"></a>3.3 字符串连接</h4><p>使用<code>+</code>能够连接字符串。但是该操作并不高效（因为字符串在Go中是基本类型，每次拼接都是拷贝了内存！）。Go1.10提供了类似Java的StringBuilder机制来进行高效字符串连接：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">str1 := <span class="string">"hello "</span></span><br><span class="line">str2 := <span class="string">" world"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建字节缓冲</span></span><br><span class="line"><span class="keyword">var</span> stringBuilder bytes.Buffer</span><br><span class="line"></span><br><span class="line"><span class="comment">//把字符串写入缓冲</span></span><br><span class="line">stringBuilder.WriteString(str1)</span><br><span class="line">stringBuilder.WriteString(str2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//将缓冲以字符串形式输出</span></span><br><span class="line">fmt.Println(stringBuilder.String())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在1.10版本前，可以使用bytes.Buffer拼接字符串（因为字符串其实是字节数组）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">buf.WriteString(<span class="string">"hello"</span>)</span><br><span class="line">fmt.Println(buf.String())</span><br></pre></td></tr></table></figure><h2 id="四-strings包相关函数"><a href="#四-strings包相关函数" class="headerlink" title="四 strings包相关函数"></a>四 strings包相关函数</h2><p>strings包提供了字符串的一些常见操作函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找s在字符串str中的索引</span></span><br><span class="line">Index(str, s <span class="keyword">string</span>) <span class="keyword">int</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//判断str是否包含s</span></span><br><span class="line">Contains(str, s <span class="keyword">string</span>) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过字符串str连接切片 s</span></span><br><span class="line">Join(s []<span class="keyword">string</span>, str <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//替换字符串str中old字符串为new字符串，n表示替换的次数，小于0全部替换</span></span><br><span class="line">Replace(str,old,<span class="built_in">new</span> <span class="keyword">string</span>,n <span class="keyword">int</span>) <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串str按照s分割，返回切片</span></span><br><span class="line">Splite(str,s <span class="keyword">string</span>)[]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除头部、尾部指定的字符串</span></span><br><span class="line">Trim(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除空格，返回切片</span></span><br><span class="line">Fields(s <span class="keyword">string</span>) []<span class="keyword">string</span></span><br></pre></td></tr></table></figure><h2 id="五-strconv包的字符串转换函数"><a href="#五-strconv包的字符串转换函数" class="headerlink" title="五 strconv包的字符串转换函数"></a>五 strconv包的字符串转换函数</h2><p>在Java中遇到 <code>&quot;你好&quot; + 123</code>会将 <code>+</code>转变为连接符。而Go语言要求 <code>+</code> 号两边数据的数据类型必须一致，这使得类似的操作变得比较不便，Go提供了strconv包用于字符串与基本类型之间的转换，常用函数有Append、Format、Parse。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Append 系列函数将整数等转换为字符串后，添加到现有的字节数组中</span></span><br><span class="line">str1 := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">str1 = strconv.AppendInt(str1, <span class="number">4567</span>, <span class="number">10</span>)</span><br><span class="line">str1 = strconv.AppendBool(str1, <span class="literal">false</span>)</span><br><span class="line">str1 = strconv.AppendQuote(str1, <span class="string">"abcdefg"</span>)</span><br><span class="line">str1 = strconv.AppendQuoteRune(str1, <span class="string">'单'</span>)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(str1))<span class="comment">// 4567false"abcdefg"'单'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Format 系列函数把其他类型的转换为字符串</span></span><br><span class="line">a := strconv.FormatBool(<span class="literal">false</span>)</span><br><span class="line">b := strconv.FormatFloat(<span class="number">123.23</span>, <span class="string">'g'</span>, <span class="number">12</span>, <span class="number">64</span>)</span><br><span class="line">c := strconv.FormatInt(<span class="number">1234</span>, <span class="number">10</span>)</span><br><span class="line">d := strconv.FormatUint(<span class="number">12345</span>, <span class="number">10</span>)</span><br><span class="line">e := strconv.Itoa(<span class="number">1023</span>)</span><br><span class="line">fmt.Println(a, b, c, d, e)<span class="comment">// false 123.23 1234 12345 1023</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse 系列函数把字符串转换为其他类型</span></span><br><span class="line">f, _ := strconv.ParseBool(<span class="string">"false"</span>)</span><br><span class="line">g, _ := strconv.ParseFloat(<span class="string">"123.23"</span>, <span class="number">64</span>)</span><br><span class="line">h, _ := strconv.ParseInt(<span class="string">"1234"</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">i, _ := strconv.ParseUint(<span class="string">"12345"</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">j, _ := strconv.Atoi(<span class="string">"1023"</span>)</span><br><span class="line">fmt.Println(f, g, h, j, i, j)<span class="comment">// false 123.23 1234 1023 12345 1023</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-字符&quot;&gt;&lt;a href=&quot;#一-字符&quot; class=&quot;headerlink&quot; title=&quot;一 字符&quot;&gt;&lt;/a&gt;一 字符&lt;/h2&gt;&lt;p&gt;Golang 中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存，且使用单引号包裹。  &lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Go学习" scheme="https://cool2feel.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Go" scheme="https://cool2feel.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言-切片</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-1-%E5%88%87%E7%89%87/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-1-%E5%88%87%E7%89%87/</id>
    <published>2020-06-16T07:24:57.000Z</published>
    <updated>2020-06-16T08:01:55.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-切片创建"><a href="#一-切片创建" class="headerlink" title="一 切片创建"></a>一 切片创建</h2><p>切片(slice)解决了数组长度不能扩展，以及基本类型数组传递时产生副本的问题。</p><p>常用创建方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">int</span><span class="comment">// 和声明数组一样，只是没有长度，但是这样做没有意义，因为底层的数组指针为nil</span></span><br><span class="line">s2 := []<span class="keyword">byte</span> &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;</span><br><span class="line">fmt.Println(s1)<span class="comment">//输出 []</span></span><br><span class="line">fmt.Print(s2)<span class="comment">//输出 [97 98 99]</span></span><br></pre></td></tr></table></figure><p>使用make函数创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>)<span class="comment">// 创建长度为5，容量为5，初始值为0的切片</span></span><br><span class="line">slice2 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>,<span class="number">7</span>)<span class="comment">// 创建长度为5，容量为7，初始值为0的切片</span></span><br><span class="line">slice3 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;<span class="comment">// 创建长度为5，容量为5，并已经初始化的切片</span></span><br></pre></td></tr></table></figure><p>从数组创建：slice可以从一个数组再次声明。slice通过array[i:j]来获取，其中i是数组的开始位置，j是结束位置，但不包含array[j]，它的长度是j-i:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个含有10个元素元素类型为byte的数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>]<span class="keyword">byte</span> &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明两个含有byte的slice</span></span><br><span class="line">ar a, b []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a指向数组的第3个元素开始，并到第五个元素结束，现在a含有的元素: ar[2]、ar[3]和ar[4]</span></span><br><span class="line">a = arr[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">// b是数组arr的另一个slicre,b的元素是：ar[3]和ar[4]</span></span><br><span class="line">b = arr[<span class="number">3</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>注意：声明数组时，方括号内写明了数组的长度或使用…自动计算长度，而声明slice时，方括号内没有任何字符。  </p><p>从切片创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oldSlice := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">newSlice := oldSlice[:<span class="number">6</span>]<span class="comment">//基于切片前6个元素创建，没有的默认0</span></span><br></pre></td></tr></table></figure><p>注意：如果选择的旧切片长度超出了旧切片的cap()值（切片存储长度），则不合法。  </p><h2 id="二-切片常见操作"><a href="#二-切片常见操作" class="headerlink" title="二 切片常见操作"></a>二 切片常见操作</h2><h4 id="2-1-切片常见内置函数"><a href="#2-1-切片常见内置函数" class="headerlink" title="2.1 切片常见内置函数"></a>2.1 切片常见内置函数</h4><p>切片常用内置函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">len()返回切片长度</span><br><span class="line">cap()返回切片底层数组容量</span><br><span class="line">append()对切片追加元素</span><br><span class="line">func copy(dst, src []Type) int</span><br><span class="line">将src中数据拷贝到dst中，返回拷贝的元素个数</span><br></pre></td></tr></table></figure><p>切片空间与元素个数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice1))<span class="comment">// 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice1))<span class="comment">// 10</span></span><br><span class="line">fmt.Println(slice1)<span class="comment">// [0 0 0 0 0]</span></span><br></pre></td></tr></table></figure><p>切片操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切片增加</span></span><br><span class="line">slice1 = <span class="built_in">append</span>(slice1,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">fmt.Println(slice1)<span class="comment">//输出[0 0 0 0 0 1 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片增加一个新切片</span></span><br><span class="line">sliceTemp := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">slice1 = <span class="built_in">append</span>(slice1,sliceTemp...)</span><br><span class="line">fmt.Println(slice1)<span class="comment">//输出[0 0 0 0 0 1 2 0 0 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片拷贝</span></span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>&#125;</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)<span class="comment">//必须给与充足的空间</span></span><br><span class="line">num := <span class="built_in">copy</span>(s2, s1)</span><br><span class="line"></span><br><span class="line">fmt.Println(s1)<span class="comment">//[1 3 6 9]</span></span><br><span class="line">fmt.Println(s2)<span class="comment">//[1 3 6 9 0 0 0 0 0 0]</span></span><br><span class="line">fmt.Println(num)<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片中删除元素</span></span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>&#125;</span><br><span class="line">index := <span class="number">2</span><span class="comment">//删除该位置元素</span></span><br><span class="line">s1 = <span class="built_in">append</span>(s1[:index], s1[index+<span class="number">1</span>:]...)</span><br><span class="line">fmt.Println(s1)<span class="comment">//[1 3 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片拷贝</span></span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line"><span class="built_in">copy</span>(s1,s2) <span class="comment">//复制s2前三个元素到slice1前3位置</span></span><br><span class="line"><span class="built_in">copy</span>(s2,s1) <span class="comment">//复制s1前三个元素到slice2</span></span><br></pre></td></tr></table></figure><p>注意：没有…会编译错误，默认第二个参数后是元素值，传入切片需要展开。如果追加的长度超过当前已分配的存储空间，切片会自动分配更大的内存。  </p><h4 id="2-2-切片的一些简便操作"><a href="#2-2-切片的一些简便操作" class="headerlink" title="2.2 切片的一些简便操作"></a>2.2 切片的一些简便操作</h4><ul><li>slice的默认开始位置是0，ar[:n]等价于ar[0:n]</li><li>slice的第二个序列默认是数组的长度，ar[n:]等价于ar[n:len(ar)]</li><li>如果从一个数组里面直接获取slice，可以这样ar[:]，因为默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)]</li><li>切片的遍历可以使用for循环，也可以使用range函数  </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个数组</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">10</span>]<span class="keyword">byte</span>&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>&#125;</span><br><span class="line"><span class="comment">// 声明两个slice</span></span><br><span class="line"><span class="keyword">var</span> aSlice, bSlice []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示一些简便操作</span></span><br><span class="line">aSlice = array[:<span class="number">3</span>] <span class="comment">// 等价于aSlice = array[0:3] aSlice包含元素: a,b,c</span></span><br><span class="line">aSlice = array[<span class="number">5</span>:] <span class="comment">// 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,j</span></span><br><span class="line">aSlice = array[:] <span class="comment">// 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从slice中获取slice</span></span><br><span class="line">aSlice = array[<span class="number">3</span>:<span class="number">7</span>] <span class="comment">// aSlice包含元素: d,e,f,g，len=4，cap=7</span></span><br><span class="line">bSlice = aSlice[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">// bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,f</span></span><br><span class="line">bSlice = aSlice[:<span class="number">3</span>] <span class="comment">// bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,f</span></span><br><span class="line">bSlice = aSlice[<span class="number">0</span>:<span class="number">5</span>] <span class="comment">// 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,h</span></span><br><span class="line">bSlice = aSlice[:] <span class="comment">// bSlice包含所有aSlice的元素: d,e,f,g</span></span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 2.3 切片的截取</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- `</span>s[n]<span class="string">`：切片s中索引为位置为n的项</span></span><br><span class="line"><span class="string">- `</span>s[:]<span class="string">`：从切片s的索引位置0到`</span><span class="built_in">len</span>(s)<span class="number">-1</span><span class="string">`所获得的切片</span></span><br><span class="line"><span class="string">- `</span>s[low:]<span class="string">`：从切片s的索引位置low到`</span><span class="built_in">len</span>(s)<span class="number">-1</span><span class="string">`所获得的切片</span></span><br><span class="line"><span class="string">- `</span>s[:high]<span class="string">`：从切片s的索引位置0到high所获得的切片</span></span><br><span class="line"><span class="string">- `</span>s[low:high]<span class="string">`：从切片s的索引位置low到high所获得的切片</span></span><br><span class="line"><span class="string">- `</span>s[low:high:max]<span class="string">`：从low到high的切片，且容量`</span><span class="built_in">cap</span>=max-low<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 1.7 字符串转切片  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line">str := <span class="string">"hello,世界"</span></span><br><span class="line">a := []<span class="keyword">byte</span>(str)<span class="comment">//字符串转换为[]byte类型切片</span></span><br><span class="line">b := []<span class="keyword">rune</span>(str)<span class="comment">//字符串转换为[]rune类型切片</span></span><br></pre></td></tr></table></figure><h2 id="三-切片存储结构"><a href="#三-切片存储结构" class="headerlink" title="三 切片存储结构"></a>三 切片存储结构</h2><p>与数组相比，切片多了一个存储能力值的概念，即元素个数与分配空间可以是两个不同的值，其结构如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">arrary = unsafe.Pointer<span class="comment">//指向底层数组的指针</span></span><br><span class="line"><span class="built_in">len</span> <span class="keyword">int</span><span class="comment">//切片元素数量</span></span><br><span class="line"><span class="built_in">cap</span> <span class="keyword">int</span><span class="comment">//底层数组的容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以切片通过内部的指针和相关属性引用数组片段，实现了变长方案，Slice并不是真正意义上的动态数组。  </p><p>合理设置存储能力，可以大幅提升性能，比如知道最多元素个数为50，那么提前设置为50，而不是先设为30，可以明显减少重新分配内存的操作。  </p><h2 id="四-切片作为函数参数"><a href="#四-切片作为函数参数" class="headerlink" title="四 切片作为函数参数"></a>四 切片作为函数参数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"test---%p\n"</span>, s) <span class="comment">// 打印与main函数相同的地址</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Printf(<span class="string">"test---%p\n"</span>, s) <span class="comment">// 一旦append的数据超过切片长度，则会打印新地址</span></span><br><span class="line">fmt.Println(<span class="string">"test---"</span>, s)    <span class="comment">// [0 0 0 1 2 3 4 5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">test(s1)</span><br><span class="line">fmt.Printf(<span class="string">"main---%p\n"</span>, s1) <span class="comment">// 不会因为test函数内的append而改变</span></span><br><span class="line">fmt.Println(<span class="string">"main---"</span>, s1)    <span class="comment">// [ 0 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-切片创建&quot;&gt;&lt;a href=&quot;#一-切片创建&quot; class=&quot;headerlink&quot; title=&quot;一 切片创建&quot;&gt;&lt;/a&gt;一 切片创建&lt;/h2&gt;&lt;p&gt;切片(slice)解决了数组长度不能扩展，以及基本类型数组传递时产生副本的问题。&lt;/p&gt;
&lt;p&gt;常用创建方式
      
    
    </summary>
    
    
      <category term="Go学习" scheme="https://cool2feel.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Go" scheme="https://cool2feel.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言-集合map</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-2-%E9%9B%86%E5%90%88/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-2-%E9%9B%86%E5%90%88/</id>
    <published>2020-06-16T07:24:57.000Z</published>
    <updated>2020-06-16T08:02:07.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-集合map"><a href="#一-集合map" class="headerlink" title="一 集合map"></a>一 集合map</h2><h4 id="1-1-map的创建"><a href="#1-1-map的创建" class="headerlink" title="1.1 map的创建"></a>1.1 map的创建</h4><p>Go内置了map类型，map是一个无序键值对集合（也有一些书籍翻译为字典）。  </p><p>普通创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个map类型，[]内的类型指任意可以进行比较的类型 int指值类型</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"a"</span>:<span class="number">1</span>,<span class="string">"b"</span>:<span class="number">2</span>&#125;</span><br><span class="line">fmt.Print(m[<span class="string">"a"</span>])</span><br></pre></td></tr></table></figure><p>make方式创建map：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">ID <span class="keyword">string</span></span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>] Person</span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>] Person)</span><br><span class="line">m[<span class="string">"123"</span>] = Person&#123;<span class="string">"123"</span>,<span class="string">"Tom"</span>&#125;</span><br><span class="line">p,isFind := m[<span class="string">"123"</span>]</span><br><span class="line">fmt.Println(isFind)<span class="comment">//true</span></span><br><span class="line">fmt.Println(p)<span class="comment">//&#123;123 Tom&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：golang中map的 key 通常 key 为 int 、string，但也可以是其他类型如：bool、数字、string、指针、channel，还可以是只包含前面几个类型的接口、结构体、数组。slice、map、function由于不能使用 == 来判断，不能作为map的key。  </p><h4 id="1-2-map的使用"><a href="#1-2-map的使用" class="headerlink" title="1.2 map的使用"></a>1.2 map的使用</h4><p>通过key操作元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">numbers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">numbers[<span class="string">"one"</span>] = <span class="number">1</span> <span class="comment">//赋值</span></span><br><span class="line">numbers[<span class="string">"ten"</span>] = <span class="number">10</span> <span class="comment">//赋值</span></span><br><span class="line">numbers[<span class="string">"three"</span>] = <span class="number">3</span></span><br><span class="line"><span class="built_in">delete</span>(numbers, <span class="string">"ten"</span>) <span class="comment">// 删除key为 ten 的元素</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"第三个数字是: "</span>, numbers[<span class="string">"three"</span>]) <span class="comment">// 读取数据</span></span><br></pre></td></tr></table></figure><p>map的遍历：同数组一样，使用for-range 的结构遍历  </p><p>注意：</p><ul><li>map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取；</li><li>map的长度是不固定的，也就是和slice一样，也是一种引用类型    </li><li>内置的len函数同样适用于map，返回map拥有的key的数量</li><li>go没有提供清空元素的方法，可以重新make一个新的map，不用担心垃圾回收的效率，因为go中并行垃圾回收效率比写一个清空函数高效很多</li><li>map和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制</li></ul><h4 id="1-3-并发安全的map"><a href="#1-3-并发安全的map" class="headerlink" title="1.3 并发安全的map"></a>1.3 并发安全的map</h4><p>演示并发读写map的问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;<span class="comment">//无限写入</span></span><br><span class="line">m[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;<span class="comment">//无限读取</span></span><br><span class="line">_ = m[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;&#125;<span class="comment">//无限循环，让并发程序在后台执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译会有错误提示：<code>fatal error: concurrent map read and map write</code>，即出现了并发读写，因为用两个并发程序不断的对map进行读和写，产生了竞态问题。map内部会对这种错误进行检查并提前发现。   </p><p>Go内置的map只有读是线程安全的，读写是线程不安全的。  </p><p>需要并发读写时，一般都是加锁，但是这样做性能不高，在go1.9版本中提供了更高效并发安全的sync.Map。  </p><p>sync.Map的特点：</p><ul><li>无须初始化，直接声明即可</li><li>sync.Map不能使用map的方式进行取值和设值操作，而是使用sync.Map的方法进行调用。Store表示存储，Load表示获取，Delete表示删除。 </li><li>使用Range配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，需要继续迭代时，返回true，终止迭代返回false。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scene sync.Map</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存键值对</span></span><br><span class="line">scene.Store(<span class="string">"id"</span>,<span class="number">1</span>)</span><br><span class="line">scene.Store(<span class="string">"name"</span>,<span class="string">"lisi"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据键取值</span></span><br><span class="line">fmt.Println(scene.Load(<span class="string">"name"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line">scene.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">fmt.Println(k,v)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：map没有提供获取map数量的方法，可以在遍历时手动计算。sync.Map为了并发安全。损失了一定的性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-集合map&quot;&gt;&lt;a href=&quot;#一-集合map&quot; class=&quot;headerlink&quot; title=&quot;一 集合map&quot;&gt;&lt;/a&gt;一 集合map&lt;/h2&gt;&lt;h4 id=&quot;1-1-map的创建&quot;&gt;&lt;a href=&quot;#1-1-map的创建&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Go学习" scheme="https://cool2feel.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Go" scheme="https://cool2feel.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言-指针</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-3-%E6%8C%87%E9%92%88/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-3-%E6%8C%87%E9%92%88/</id>
    <published>2020-06-16T07:24:57.000Z</published>
    <updated>2020-06-16T08:02:20.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-指针"><a href="#一-指针" class="headerlink" title="一 指针"></a>一 指针</h2><h3 id="1-1-指针的创建"><a href="#1-1-指针的创建" class="headerlink" title="1.1 指针的创建"></a>1.1 指针的创建</h3><p>Go保留了指针，代表某个内存地址，默认值为 <code>nil</code> ，使用 <code>&amp;</code> 取变量地址，通过 <code>*</code> 访问目标对象。  </p><p>简单示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">"&amp;a="</span>, &amp;a)<span class="comment">// 0xc000096008 一个十六进制数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = &amp;a</span><br><span class="line">fmt.Println(<span class="string">"*p="</span>, *p)<span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>Go同样支持多级指针，如 <code>**T</code></li><li>空指针：声明但未初始化的指针  </li><li>野指针：引用了无效地址的指针，如：<code>var p *int = 0</code>，<code>var p *int = 0xff00</code>(超出范围)</li><li>Go中直接使用<code>.</code>访问目标成员</li></ul><h3 id="1-2-指针使用示例：实现变量值交换"><a href="#1-2-指针使用示例：实现变量值交换" class="headerlink" title="1.2 指针使用示例：实现变量值交换"></a>1.2 指针使用示例：实现变量值交换</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(p1,p2 *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">*p1,*p2 = *p2,*p1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-结构体指针"><a href="#1-3-结构体指针" class="headerlink" title="1.3 结构体指针"></a>1.3 结构体指针</h3><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> u = User&#123;</span><br><span class="line">name:<span class="string">"lisi"</span>,</span><br><span class="line">age: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">p := &amp;u</span><br><span class="line">fmt.Println(u.name)<span class="comment">//输出李四</span></span><br><span class="line">fmt.Println(p.name)<span class="comment">//输出李四</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-Go不支持指针运算"><a href="#1-4-Go不支持指针运算" class="headerlink" title="1.4 Go不支持指针运算"></a>1.4 Go不支持指针运算</h3><p>由于垃圾回收机制的存在，指针运算造成许多困扰，所以Go直接禁止了指针运算</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">1</span></span><br><span class="line">p := &amp;a</span><br><span class="line">p++        <span class="comment">//报错：non-numeric type *int</span></span><br></pre></td></tr></table></figure><h3 id="1-5-new-函数使用"><a href="#1-5-new-函数使用" class="headerlink" title="1.5 new()函数使用"></a>1.5 new()函数使用</h3><p>new()函数可以在 heap堆 区申请一片内存地址空间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">bool</span></span><br><span class="line">p = <span class="built_in">new</span>(<span class="keyword">bool</span>)</span><br><span class="line">fmt.Println(*p)<span class="comment">// false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-指针&quot;&gt;&lt;a href=&quot;#一-指针&quot; class=&quot;headerlink&quot; title=&quot;一 指针&quot;&gt;&lt;/a&gt;一 指针&lt;/h2&gt;&lt;h3 id=&quot;1-1-指针的创建&quot;&gt;&lt;a href=&quot;#1-1-指针的创建&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="Go学习" scheme="https://cool2feel.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Go" scheme="https://cool2feel.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言-运算符</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2020-06-16T07:24:57.000Z</published>
    <updated>2020-06-16T08:02:33.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-运算符"><a href="#一-运算符" class="headerlink" title="一 运算符"></a>一 运算符</h2><h4 id="1-1-运算符汇总"><a href="#1-1-运算符汇总" class="headerlink" title="1.1 运算符汇总"></a>1.1 运算符汇总</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">算术运算符：+-*&#x2F;%++--</span><br><span class="line">关系运算符：&#x3D;&#x3D;!&#x3D;&lt;&#x3D;&gt;&#x3D;&lt;&gt;</span><br><span class="line">逻辑运算符：!&amp;&amp;||</span><br><span class="line">位运算：&amp;（按位与）|（按位或）^（按位取反）&lt;&lt;（左移）&gt;&gt;（右移）</span><br><span class="line">赋值运算符：&#x3D;+&#x3D;-&#x3D;*&#x3D;&#x2F;&#x3D;%&#x3D;&lt;&lt;&#x3D;&gt;&gt;&#x3D;&amp;&#x3D;^&#x3D;|&#x3D;</span><br><span class="line">其他运算符：&amp;（取地址）*（取指针值） &lt;-（Go Channel相关运算符）</span><br></pre></td></tr></table></figure><h4 id="1-2-自增、自减"><a href="#1-2-自增、自减" class="headerlink" title="1.2 自增、自减"></a>1.2 自增、自减</h4><p>Go中只有<code>后--</code>和<code>后++</code>，且自增自减不能用于表达式中，只能独立使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = i++           <span class="comment">// 错误用法</span></span><br><span class="line"><span class="keyword">if</span> i++ &gt; <span class="number">0</span> &#123;&#125;     <span class="comment">// 错误用法</span></span><br><span class="line">i++               <span class="comment">// 正确用法</span></span><br></pre></td></tr></table></figure><h4 id="1-3-位运算"><a href="#1-3-位运算" class="headerlink" title="1.3 位运算"></a>1.3 位运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;     按位与，参与运算的两个数二进制位相与：同时为1，结果为1，否则为0</span><br><span class="line">|     按位或，参与运算的两个数二进制位相或：有一个为1，结果为1，否则为0</span><br><span class="line">^     按位异或：二进位不同，结果为1，否则为0</span><br><span class="line">&lt;&lt;    按位左移：二进位左移若干位，高位丢弃，低位补0，左移n位其实就是乘以2的n次方</span><br><span class="line">&gt;&gt;    按位右移：二进位右移若干位，右移n位其实就是除以2的n次方</span><br></pre></td></tr></table></figure><h2 id="二-优先级"><a href="#二-优先级" class="headerlink" title="二 优先级"></a>二 优先级</h2><p><img src="../images/go/01-01.svg" alt=""></p><h2 id="三-进制转换"><a href="#三-进制转换" class="headerlink" title="三 进制转换"></a>三 进制转换</h2><h4 id="1-1-常见进制"><a href="#1-1-常见进制" class="headerlink" title="1.1 常见进制"></a>1.1 常见进制</h4><ul><li>二进制：只有0和1，Go中不能直接使用二进制表示整数</li><li>八进制：0-7，以数字0开头</li><li>十进制：0-9</li><li>十六进制：0-9以及A-F，以0X开头，A-F以及X不区分大小写</li></ul><h4 id="1-2-任意进制转换为十进制"><a href="#1-2-任意进制转换为十进制" class="headerlink" title="1.2 任意进制转换为十进制"></a>1.2 任意进制转换为十进制</h4><p>二进制转十进制：  </p><blockquote><p>从最低位开始，每个位上数乘以2（位数-1）次方然后求和<br>1011 = 1*2<sup>0</sup> + 1*2<sup>1</sup> + 0*2<sup>2</sup> + 1*2<sup>3</sup> = 11  </p></blockquote><p>八进制转十进制：  </p><blockquote><p>从最低位开始，每个位上数乘以8（位数-1）次方然后求和<br>0123 = 3*8<sup>0</sup> + 2*8<sup>1</sup> + 1*8<sup>2</sup> + 0*8<sup>3</sup> = 83</p></blockquote><p>其他进制转十进制同理。</p><h4 id="1-3-十进制转其他进制"><a href="#1-3-十进制转其他进制" class="headerlink" title="1.3 十进制转其他进制"></a>1.3 十进制转其他进制</h4><p>十进制转二进制：  </p><blockquote><p>不断除以2，直到0为止,余数倒过来即可，如图计算28转换为二进制11100</p></blockquote><p><img src="../images/go/01-02.svg" alt=""></p><p>十进制转八进制：不断除以8，直到0为止，余数倒过来即可。  </p><p>十进制转十六进制：不断除以16，直到0为止，余数倒过来即可。</p><h4 id="1-4-其他进制互转"><a href="#1-4-其他进制互转" class="headerlink" title="1.4 其他进制互转"></a>1.4 其他进制互转</h4><ul><li>二进制转换八进制：将二进制数从低位开始，每三位一组，转换成八进制数即可</li><li>二进制转十六进制：将二进制数从低位开始，每四位一组，转换成十六进制数即可</li><li>八进制转换二进制：将八进制数每1位转换成一个3位的二进制数（首位0除外）</li><li>十六进制转二进制：将十六进制每1位转换成对应的一个4位的二进制数即可  </li></ul><h2 id="四-计算机运算原理"><a href="#四-计算机运算原理" class="headerlink" title="四 计算机运算原理"></a>四 计算机运算原理</h2><p>计算机常见的术语：</p><ul><li>bit：比特，代表1个二进制位，一个位只能是0或者1</li><li>Byte：字节，代表8个二进制位，计算机中存储的最小单元是字节</li><li>WORD：双字节，即2个字节，16位</li><li>DWORD：两个WORD，即4个字节，32位</li></ul><p>一些常用单位：</p><ul><li>1b：1bit，1位</li><li>1Kb：1024bit，即1024位</li><li>1Mb：1024*1024bit</li><li>1B：1Byte，1字节，8位</li><li>1KB：1024B</li><li>1MB：1024K</li></ul><p>对于有符号数而言，二进制的最高为是符号位：0表示正数，1表示负数，比如 1在二进制中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1  二进制位：0000  0001</span><br><span class="line">-1 二进制位：1000  0001</span><br></pre></td></tr></table></figure><p>正数的原码、反码、补码都一样，负数的反码=原码符号位不变，其他位取反，补码是反码+1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">         1              -1</span><br><span class="line">原码  0000  0001        1000  0001</span><br><span class="line">反码  0000  0001        1111  1110</span><br><span class="line">补码  0000  0001        1111  1111</span><br></pre></td></tr></table></figure><p>常见理解：</p><ul><li>0的反码补码都是0</li><li>计算机中是以补码形式运算的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-运算符&quot;&gt;&lt;a href=&quot;#一-运算符&quot; class=&quot;headerlink&quot; title=&quot;一 运算符&quot;&gt;&lt;/a&gt;一 运算符&lt;/h2&gt;&lt;h4 id=&quot;1-1-运算符汇总&quot;&gt;&lt;a href=&quot;#1-1-运算符汇总&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Go学习" scheme="https://cool2feel.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Go" scheme="https://cool2feel.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言-数值类型</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-1-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-1-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-06-16T07:24:57.000Z</published>
    <updated>2020-06-16T08:02:46.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-数值类型"><a href="#一-数值类型" class="headerlink" title="一 数值类型"></a>一 数值类型</h2><p>数值类型指基本类型中的：整型、浮点型、复数。</p><h2 id="二-整数"><a href="#二-整数" class="headerlink" title="二 整数"></a>二 整数</h2><p>整数类型有无符号(如int)和带符号(如uint)两种，这两种类型的长度相同，但具体长度取决于不同编译器的实现。  </p><p>int8、int16、int32和int64四种有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，<br>同样uint8、uint16、uint32和uint64对应四种无符号整数类型。  </p><p>有符号类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int     32位系统占4字节（与int32范围一样），64位系统占8个节（与int64范围一样）     </span><br><span class="line">int8    占据1字节   范围 -128 ~ 127</span><br><span class="line">int16   占据2字节   范围 -2(15次方) ~ 2（15次方）-1</span><br><span class="line">int32   占据4字节   范围 -2(31次方) ~ 2（31次方）-1</span><br><span class="line">int64   占据8字节   范围 -2(63次方) ~ 2（63次方）-1</span><br><span class="line">runeint32的别称</span><br></pre></td></tr></table></figure><p>无符号类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint32位系统占4字节（与uint32范围一样），64位系统占8字节（与uint64范围一样）     </span><br><span class="line">uint8   占据1字节   范围 0 ~ 255</span><br><span class="line">uint16  占据2字节   范围 0 ~ 2（16次方）-1</span><br><span class="line">uint32  占据4字节   范围 0 ~ 2（32次方）-1</span><br><span class="line">uint64  占据8字节   范围 0 ~ 2（64次方）-1</span><br><span class="line">byteuint8的别称</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>上述类型的变量由于是不同类型，不允许互相赋值或操作</li><li>Go默认的整型类型是int</li><li>查看数据所占据的字节数方法：unsafe.Sizeof()</li></ul><h2 id="三-浮点类型"><a href="#三-浮点类型" class="headerlink" title="三 浮点类型"></a>三 浮点类型</h2><h4 id="3-1-浮点类型的分类"><a href="#3-1-浮点类型的分类" class="headerlink" title="3.1 浮点类型的分类"></a>3.1 浮点类型的分类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float32 单精度  占据4字节   范围 -3.403E38 ~ 3.403E38    (math.MaxFloat32)</span><br><span class="line">float64 双精度  占据8字节   范围 -1.798E208 ~ 1.798E308  (math.MaxFloat64)</span><br></pre></td></tr></table></figure><p>由上看出：</p><ul><li>浮点数是有符号的，浮点数在机器中存放形式是：浮点数=符号位+指数位+尾数位  </li><li>浮点型的范围是固定的，不受操作系统限制</li><li><code>.512</code> 这样数可以识别为 <code>0.512</code></li><li>科学计数法：<ul><li>5.12E2 = 5.12 * 10<sup>2</sup> </li><li>5.12E-2 = 5.12 / 10<sup>2</sup> </li></ul></li></ul><h4 id="3-2-精度损失"><a href="#3-2-精度损失" class="headerlink" title="3.2 精度损失"></a>3.2 精度损失</h4><p>float32可以提供大约6个十进制数的精度，float64大约可以提供15个十进制的精度（一般选择float64）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 <span class="keyword">float32</span> = <span class="number">-123.0000901</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="keyword">float64</span> = <span class="number">-123.0000901</span> </span><br><span class="line">fmt.Println(<span class="string">"num1="</span>,num1)<span class="comment">// -123.00009</span></span><br><span class="line">fmt.Println(<span class="string">"num2="</span>,num2)<span class="comment">// -123.0000901</span></span><br></pre></td></tr></table></figure><h4 id="3-3-浮点数判断相等"><a href="#3-3-浮点数判断相等" class="headerlink" title="3.3 浮点数判断相等"></a>3.3 浮点数判断相等</h4><p>使用 == 号判断浮点数，是不可行的，替代方案如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEqual</span><span class="params">(f1,f2,p <span class="keyword">float64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// p为用户自定义精度，如：0.00001</span></span><br><span class="line">   <span class="keyword">return</span> math.Abs(f1-f2) &lt; p           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-复数"><a href="#四-复数" class="headerlink" title="四 复数"></a>四 复数</h2><p>Go中复数默认类型是complex128（64位实数+64位虚数）。如果需要小一些的，也有complex64(32位实数+32位虚数)。  </p><p>复数的形式为<code>RE + IMi</code>，其中RE是实数部分，IM是虚数部分，而最后的i是虚数单位。</p><p>如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">complex128</span></span><br><span class="line">t = <span class="number">2.1</span> + <span class="number">3.14i</span></span><br><span class="line">t1 = <span class="built_in">complex</span>(<span class="number">2.1</span>,<span class="number">3.14</span>) <span class="comment">// 结果同上</span></span><br><span class="line">fmt.Println(<span class="built_in">real</span>(t))   <span class="comment">// 实部：2.1</span></span><br><span class="line">fmt.Println(<span class="built_in">imag</span>(t))   <span class="comment">// 虚部：3.14</span></span><br></pre></td></tr></table></figure><h2 id="五-NaN非数"><a href="#五-NaN非数" class="headerlink" title="五 NaN非数"></a>五 NaN非数</h2><p>go中的<code>NaN</code>非数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z <span class="keyword">float64</span></span><br><span class="line"><span class="comment">// 输出 "0 -0 +Inf -Inf NaN"</span></span><br><span class="line">fmt.Println(z, -z, <span class="number">1</span>/z, <span class="number">-1</span>/z, z/z)</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>函数<code>math.IsNaN</code>用于测试一个数是否是非数NaN，</li><li>函数<code>math.NaN</code>则返回非数对应的值。</li><li>虽然可以用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等的。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nan := math.NaN()</span><br><span class="line"><span class="comment">// "false false false"</span></span><br><span class="line">fmt.Println(nan == nan, nan &lt; nan, nan &gt; nan)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-数值类型&quot;&gt;&lt;a href=&quot;#一-数值类型&quot; class=&quot;headerlink&quot; title=&quot;一 数值类型&quot;&gt;&lt;/a&gt;一 数值类型&lt;/h2&gt;&lt;p&gt;数值类型指基本类型中的：整型、浮点型、复数。&lt;/p&gt;
&lt;h2 id=&quot;二-整数&quot;&gt;&lt;a href=&quot;#二-整
      
    
    </summary>
    
    
      <category term="Go学习" scheme="https://cool2feel.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Go" scheme="https://cool2feel.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言-数据类型</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-06-16T07:24:57.000Z</published>
    <updated>2020-06-16T08:00:42.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-数据类型分类"><a href="#一-数据类型分类" class="headerlink" title="一 数据类型分类"></a>一 数据类型分类</h2><p>值类型：基本数据类型是Go语言实际的原子，复合数据类型是由不同的方式组合基本类型构造出来的数据类型，如：数组，slice，map，结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">整型    int8,uint               # 基础类型之数字类型</span><br><span class="line">浮点型  float32，float64         # 基础类型之数字类型</span><br><span class="line">复数                            # 基础类型之数字类型</span><br><span class="line">布尔型  bool                    # 基础类型，只能存true&#x2F;false，占据1个字节，不能转换为整型，0和1也不能转换为布尔</span><br><span class="line">字符串  string                  # 基础类型</span><br><span class="line">数组                            # 复合类型 </span><br><span class="line">结构体  struct                  # 复合类型</span><br></pre></td></tr></table></figure><p>引用类型：即保存的是对程序中一个变量的或状态的间接引用，对其修改将影响所有该引用的拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指针    *</span><br><span class="line">切片    slice</span><br><span class="line">字典    map</span><br><span class="line">函数    func</span><br><span class="line">管道    chan</span><br><span class="line">接口    interface</span><br></pre></td></tr></table></figure><p>贴士：Go语言没有字符型，可以使用byte来保存单个字母</p><h2 id="二-零值机制"><a href="#二-零值机制" class="headerlink" title="二 零值机制"></a>二 零值机制</h2><p>Go变量初始化会自带默认值，不像其他语言为空，下面列出各种数据类型对应的0值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>     <span class="number">0</span></span><br><span class="line"><span class="keyword">int8</span>    <span class="number">0</span></span><br><span class="line"><span class="keyword">int32</span>   <span class="number">0</span></span><br><span class="line"><span class="keyword">int64</span>   <span class="number">0</span></span><br><span class="line"><span class="keyword">uint</span>    <span class="number">0x0</span></span><br><span class="line"><span class="keyword">rune</span>    <span class="number">0</span>           <span class="comment">//rune的实际类型是 int32</span></span><br><span class="line"><span class="keyword">byte</span>    <span class="number">0x0</span>         <span class="comment">// byte的实际类型是 uint8</span></span><br><span class="line"><span class="keyword">float32</span> <span class="number">0</span>           <span class="comment">//长度为 4 byte</span></span><br><span class="line"><span class="keyword">float64</span> <span class="number">0</span>           <span class="comment">//长度为 8 byte</span></span><br><span class="line"><span class="keyword">bool</span>    <span class="literal">false</span></span><br><span class="line"><span class="keyword">string</span>  <span class="string">""</span></span><br></pre></td></tr></table></figure><h2 id="三-格式化输出"><a href="#三-格式化输出" class="headerlink" title="三 格式化输出"></a>三 格式化输出</h2><p>常用格式化输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%%%字面量</span><br><span class="line">%b二进制整数值，基数为2，或者是一个科学记数法表示的指数为2的浮点数</span><br><span class="line">%c该值对应的unicode字符</span><br><span class="line">%d十进制数值，基数为10</span><br><span class="line">%e科学记数法e表示的浮点或者复数</span><br><span class="line">%E科学记数法E表示的浮点或者附属</span><br><span class="line">%f标准计数法表示的浮点或者附属</span><br><span class="line">%o8进制度</span><br><span class="line">%p十六进制表示的一个地址值</span><br><span class="line">%s输出字符串或字节数组</span><br><span class="line">%T输出值的类型，注意int32和int是两种不同的类型，编译器不会自动转换，需要类型转换。</span><br><span class="line">%v值的默认格式表示</span><br><span class="line">%+v类似%v，但输出结构体时会添加字段名</span><br><span class="line">%#v值的Go语法表示</span><br><span class="line">%t单词true或false</span><br><span class="line">%q该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示</span><br><span class="line">%x表示为十六进制，使用a-f</span><br><span class="line">%X表示为十六进制，使用A-F</span><br><span class="line">%U表示为Unicode格式：U+1234，等价于&quot;U+%04X&quot;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">user : = User&#123;</span><br><span class="line">    <span class="string">"overnote"</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%%\n"</span>)                   <span class="comment">// %</span></span><br><span class="line">fmt.Printf(<span class="string">"%b\n"</span>, <span class="number">16</span>)               <span class="comment">// 10000</span></span><br><span class="line">fmt.Printf(<span class="string">"%c\n"</span>, <span class="number">65</span>)               <span class="comment">// A</span></span><br><span class="line">fmt.Printf(<span class="string">"%c\n"</span>, <span class="number">0x4f60</span>)           <span class="comment">// 你</span></span><br><span class="line">fmt.Printf(<span class="string">"%U\n"</span>, <span class="string">'你'</span>)              <span class="comment">// U+4f60</span></span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, <span class="string">'你'</span>)              <span class="comment">// 4f60</span></span><br><span class="line">fmt.Printf(<span class="string">"%X\n"</span>, <span class="string">'你'</span>)              <span class="comment">// 4F60</span></span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, <span class="string">'A'</span>)              <span class="comment">// 65</span></span><br><span class="line">fmt.Printf(<span class="string">"%t\n"</span>, <span class="number">1</span> &gt; <span class="number">2</span>)            <span class="comment">// false</span></span><br><span class="line">fmt.Printf(<span class="string">"%e\n"</span>, <span class="number">4396.7777777</span>)     <span class="comment">// 4.396778e+03 默认精度6位</span></span><br><span class="line">fmt.Printf(<span class="string">"%20.3e\n"</span>, <span class="number">4396.7777777</span>) <span class="comment">//            4.397e+03 设置宽度20,精度3,宽度一般用于对齐</span></span><br><span class="line">fmt.Printf(<span class="string">"%E\n"</span>, <span class="number">4396.7777777</span>)     <span class="comment">// 4.396778E+03</span></span><br><span class="line">fmt.Printf(<span class="string">"%f\n"</span>, <span class="number">4396.7777777</span>)     <span class="comment">// 4396.777778</span></span><br><span class="line">fmt.Printf(<span class="string">"%o\n"</span>, <span class="number">16</span>)               <span class="comment">// 20</span></span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;)         <span class="comment">// 0xc000016110</span></span><br><span class="line">fmt.Printf(<span class="string">"Hello %s\n"</span>, <span class="string">"World"</span>)    <span class="comment">// Hello World</span></span><br><span class="line">fmt.Printf(<span class="string">"Hello %q\n"</span>, <span class="string">"World"</span>)    <span class="comment">// Hello "World"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, <span class="number">3.0</span>)              <span class="comment">// float64</span></span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, user)             <span class="comment">// &#123;overnote 1&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, user)            <span class="comment">// &#123;Name:overnote Age:1&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, user)            <span class="comment">// main.User&#123;Name:"overnote", Age:1&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-数据类型分类&quot;&gt;&lt;a href=&quot;#一-数据类型分类&quot; class=&quot;headerlink&quot; title=&quot;一 数据类型分类&quot;&gt;&lt;/a&gt;一 数据类型分类&lt;/h2&gt;&lt;p&gt;值类型：基本数据类型是Go语言实际的原子，复合数据类型是由不同的方式组合基本类型构造出来的数
      
    
    </summary>
    
    
      <category term="Go学习" scheme="https://cool2feel.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Go" scheme="https://cool2feel.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言-类型转换</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%88%AB%E5%90%8D/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%88%AB%E5%90%8D/</id>
    <published>2020-06-16T07:24:57.000Z</published>
    <updated>2020-06-16T07:59:31.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-数据类型转换"><a href="#一-数据类型转换" class="headerlink" title="一 数据类型转换"></a>一 数据类型转换</h2><h4 id="1-1-显式转换"><a href="#1-1-显式转换" class="headerlink" title="1.1 显式转换"></a>1.1 显式转换</h4><p>Go在不同类型的变量之间赋值时需要显式转换。也就是说Golang中数据类型不能自动转换。</p><h4 id="1-2-数值类型转换"><a href="#1-2-数值类型转换" class="headerlink" title="1.2 数值类型转换"></a>1.2 数值类型转换</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int32</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> n1 <span class="keyword">float64</span> = <span class="keyword">float64</span>(i)</span><br><span class="line">fmt.Printf(<span class="string">"n1=%v"</span>, n1)<span class="comment">//输出100</span></span><br></pre></td></tr></table></figure><p>注意：在转换中，比如将<code>int64</code>转成<code>int8【-128---127】</code>，编译时不会报错，只是转换的结果是按溢出处理，和我们希望的结果不一样。 因此在转换时，需要考虑范围。</p><h4 id="1-3-基本数据类型与字符串转换"><a href="#1-3-基本数据类型与字符串转换" class="headerlink" title="1.3 基本数据类型与字符串转换"></a>1.3 基本数据类型与字符串转换</h4><p>基本数据类型转字符串：fmt.Sprintf();该函数会返回转换后的字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">str = fmt.Sprintf(<span class="string">"%t"</span>, b)</span><br><span class="line">fmt.Printf(str)<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>字符串转基本数据类型：使用包strconv</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"true"</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span></span><br><span class="line">b, _ = strconv.ParseBool(str)</span><br><span class="line">   fmt.Printf(<span class="string">"%v"</span>, b)</span><br></pre></td></tr></table></figure><p>注意：在将<code>String</code>类型转成基本数据类型时，要确保<code>String</code>类型能够转成有效的数据，比如可以把”123”,转成一个整数，但不能转换”hello”，如果这样做，Golang 直接将其转成<code>0</code>，其它类型也是一样的道理，如：<code>float =&gt; 0 bool =&gt; false</code>。</p><h2 id="二-类型别名"><a href="#二-类型别名" class="headerlink" title="二 类型别名"></a>二 类型别名</h2><h4 id="2-1-类型别名的使用"><a href="#2-1-类型别名的使用" class="headerlink" title="2.1 类型别名的使用"></a>2.1 类型别名的使用</h4><p>Go在1.9版本加入了类型别名。主要用于代码升级、迁移中类型的兼容问题（C/C++中使用宏来解决重构升级带来的问题）。  </p><p>Go1.9之前的版本内部定义了新的类型byte和rune，用于指代<code>uint8</code>和<code>int32</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> <span class="keyword">int32</span></span><br></pre></td></tr></table></figure><p>Go1.9之后<code>uint8</code>和<code>int32</code>使用了类型别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span><span class="comment">// 使用 = 号定义后，都会按照等号右边的类型打印、计算</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">类型定义是定义了一个全新的类型的类型。类型别名只是某个类型的小名，并非创造了新的类型：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span>                          <span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">type</span> AliasInt = <span class="keyword">int</span>                     <span class="comment">// 类型别名，支持使用括号，同时起多个别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1 MyInt</span><br><span class="line">fmt.Printf(<span class="string">"a1 type: %T\n"</span>, a1)<span class="comment">//main.MyInt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a2 AliasInt</span><br><span class="line">fmt.Printf(<span class="string">"a2 type: %T\n"</span>, a2)<span class="comment">//int</span></span><br></pre></td></tr></table></figure><h4 id="2-2-不同包下的类型定义"><a href="#2-2-不同包下的类型定义" class="headerlink" title="2.2 不同包下的类型定义"></a>2.2 不同包下的类型定义</h4><p>如下示例，在项目根目录新建文件夹<code>mypack</code>，在该目录建立<code>person.go</code>文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span><span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"run..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main.go中，如下使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"TestGo/mypack"</span><span class="comment">// // TestGo 是 go.mod文件中定义的项目名：module TestGo</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student  mypack.Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">Study</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"study..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s := &amp;Student&#123;&#125;</span><br><span class="line">s.Study()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-不同包下的类型别名"><a href="#2-3-不同包下的类型别名" class="headerlink" title="2.3 不同包下的类型别名"></a>2.3 不同包下的类型别名</h4><p>2.2 中的案例如果将类型定义改为类型别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student = mypack.Person                <span class="comment">// 这时Student的方法就会报错：无法为 Person 添加新的方法</span></span><br></pre></td></tr></table></figure><p>使用方式：必须直接在person文件中直接使用类型别名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span><span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"run..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student = Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Student)</span> <span class="title">Study</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"study..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main中调用别名方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span><span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"run..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student = Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Student)</span> <span class="title">Study</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"study..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-Go的类型系统补充"><a href="#三-Go的类型系统补充" class="headerlink" title="三 Go的类型系统补充"></a>三 Go的类型系统补充</h3><h3 id="3-1-命名类型和未命名类型"><a href="#3-1-命名类型和未命名类型" class="headerlink" title="3.1 命名类型和未命名类型"></a>3.1 命名类型和未命名类型</h3><ul><li>命名类型：Named Type。类型通过标识符、自定义类型表示</li><li>未命名类型：Unamed Type。也称为类型字面量（Type Literal），由预声明类型、关键字、操作符等组合而成，如array、slice、channel、pointer、function、未使用type定义的struct、未使用type定义的interface。 </li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名类型，其类型是 Person</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 未命名类型，其类型是 struct &#123; name string &#125;</span></span><br><span class="line">p := <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-底层类型"><a href="#3-2-底层类型" class="headerlink" title="3.2 底层类型"></a>3.2 底层类型</h3><p>所有类型都有一个底层类型 underlying type，其规则如下：</p><ul><li>预声明类型（Pre-declared types）和类型字面量（type literals）的底层类型是他们自身</li><li>自定义类型<code>type newtype oldtype</code>中newtype的底层类型是逐层递归向下查找的，直到找到oldtype的预声明类型或字面量类型</li></ul><h3 id="3-3-Go中的类型相同"><a href="#3-3-Go中的类型相同" class="headerlink" title="3.3 Go中的类型相同"></a>3.3 Go中的类型相同</h3><p>Go中类型相同的规范：</p><ul><li>命名类型的数据类型相同：声明语句必须完全相同</li><li>未命名类型数据类型相同：类型声明字面量结构相同，且内部元素的类型相同</li><li>命名类型与未命名类型永远不同</li><li>通过类型别名语句声明的两个类型相同。类型别名语法：<code>type T1 = T2</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-数据类型转换&quot;&gt;&lt;a href=&quot;#一-数据类型转换&quot; class=&quot;headerlink&quot; title=&quot;一 数据类型转换&quot;&gt;&lt;/a&gt;一 数据类型转换&lt;/h2&gt;&lt;h4 id=&quot;1-1-显式转换&quot;&gt;&lt;a href=&quot;#1-1-显式转换&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Go学习" scheme="https://cool2feel.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Go" scheme="https://cool2feel.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言-常量</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%B8%B8%E9%87%8F/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%B8%B8%E9%87%8F/</id>
    <published>2020-06-16T07:24:57.000Z</published>
    <updated>2020-06-16T07:56:45.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-常量"><a href="#一-常量" class="headerlink" title="一 常量"></a>一 常量</h2><p>常量：在编译阶段就确定下来的值，程序运行时无法改变。   </p><p>定义方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A = <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> PI <span class="keyword">float32</span> = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span> &lt;&lt; <span class="number">3</span><span class="comment">//常量与表达式</span></span><br></pre></td></tr></table></figure><p>错误写法：常量赋值是一个编译期行为，右边的值不能出现在运行时才能得到结果的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HOME = os.GetEnv(<span class="string">"HOME"</span>)</span><br></pre></td></tr></table></figure><h2 id="二-无类型常量"><a href="#二-无类型常量" class="headerlink" title="二 无类型常量"></a>二 无类型常量</h2><p>一个常量可以有任意一个确定的基础类型，例如int或float64，但是许多常量并没有一个明确的基础类型。  </p><p>无类型常量的作用：</p><ul><li>编译器会为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算，可以认为至少有256bit的运算精度</li><li>无类型的常量可以直接用于更多的表达式而不需要显式的类型转换</li></ul><p>示例：math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float32</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">float64</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> z <span class="keyword">complex128</span> = math.Pi</span><br></pre></td></tr></table></figure><p>如果math.Pi被确定为特定类型，比如float64，那么结果精度可能会不一样，同时对于需要float32或complex128类型值的地方则会强制需要一个明确的类型转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi64 <span class="keyword">float64</span> = math.Pi</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">float32</span> = <span class="keyword">float32</span>(Pi64)</span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">float64</span> = Pi64</span><br><span class="line"><span class="keyword">var</span> z <span class="keyword">complex128</span> = <span class="keyword">complex128</span>(Pi64)</span><br></pre></td></tr></table></figure><p>对于常量面值，不同的写法可能会对应不同的类型。例如0、0.0、0i和<code>\u0000</code>虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，true和false也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。</p><p>前面说过除法运算符/会根据操作数的类型生成对应类型的结果。因此，不同写法的常量除法表达式可能对应不同的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="number">212</span></span><br><span class="line">fmt.Println((f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>)     <span class="comment">// "100"; (f - 32) * 5 is a float64</span></span><br><span class="line">fmt.Println(<span class="number">5</span> / <span class="number">9</span> * (f - <span class="number">32</span>))     <span class="comment">// "0";   5/9 is an untyped integer, 0</span></span><br><span class="line">fmt.Println(<span class="number">5.0</span> / <span class="number">9.0</span> * (f - <span class="number">32</span>)) <span class="comment">// "100"; 5.0/9.0 is an untyped float</span></span><br></pre></td></tr></table></figure><p>只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语句，或者出现在有明确类型的变量声明的右边，如下面的其余三行语句，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="number">3</span> + <span class="number">0i</span> <span class="comment">// untyped complex -&gt; float64</span></span><br><span class="line">f = <span class="number">2</span>                  <span class="comment">// untyped integer -&gt; float64</span></span><br><span class="line">f = <span class="number">1e123</span>              <span class="comment">// untyped floating-point -&gt; float64</span></span><br><span class="line">f = <span class="string">'a'</span>                <span class="comment">// untyped rune -&gt; float64</span></span><br></pre></td></tr></table></figure><p>上面的语句相当于:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="keyword">float64</span>(<span class="number">3</span> + <span class="number">0i</span>)</span><br><span class="line">f = <span class="keyword">float64</span>(<span class="number">2</span>)</span><br><span class="line">f = <span class="keyword">float64</span>(<span class="number">1e123</span>)</span><br><span class="line">f = <span class="keyword">float64</span>(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure><p>无论是隐式或显式转换，将一种类型转换为另一种类型都要求目标可以表示原始值。对于浮点数和复数，可能会有舍入处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">deadbeef = <span class="number">0xdeadbeef</span> <span class="comment">// untyped int with value 3735928559</span></span><br><span class="line">a = <span class="keyword">uint32</span>(deadbeef)  <span class="comment">// uint32 with value 3735928559</span></span><br><span class="line">b = <span class="keyword">float32</span>(deadbeef) <span class="comment">// float32 with value 3735928576 (rounded up)</span></span><br><span class="line">c = <span class="keyword">float64</span>(deadbeef) <span class="comment">// float64 with value 3735928559 (exact)</span></span><br><span class="line">d = <span class="keyword">int32</span>(deadbeef)   <span class="comment">// compile error: constant overflows int32</span></span><br><span class="line">e = <span class="keyword">float64</span>(<span class="number">1e309</span>)    <span class="comment">// compile error: constant overflows float64</span></span><br><span class="line">f = <span class="keyword">uint</span>(<span class="number">-1</span>)          <span class="comment">// compile error: constant underflows uint</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型，就像下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span>      <span class="comment">// untyped integer;        implicit int(0)</span></span><br><span class="line">r := <span class="string">'\000'</span> <span class="comment">// untyped rune;           implicit rune('\000')</span></span><br><span class="line">f := <span class="number">0.0</span>    <span class="comment">// untyped floating-point; implicit float64(0.0)</span></span><br><span class="line">c := <span class="number">0i</span>     <span class="comment">// untyped complex;        implicit complex128(0i)</span></span><br></pre></td></tr></table></figure><p>注意有一点不同：无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。<br>如果不知道浮点数类型的内存大小是很难写出正确的数值算法的，因此Go语言不存在整型类似的不确定内存大小的浮点数和复数类型。  </p><p>如果要给变量一个不同的类型，我们必须显式地将无类型的常量转化为所需的类型，或给声明的变量指定明确的类型，像下面例子这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="keyword">int8</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int8</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>当尝试将这些无类型的常量转为一个接口值时（见第7章），这些默认类型将显得尤为重要，因为要靠它们明确接口对应的动态类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, <span class="number">0</span>)      <span class="comment">// "int"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, <span class="number">0.0</span>)    <span class="comment">// "float64"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, <span class="number">0i</span>)     <span class="comment">// "complex128"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, <span class="string">'\000'</span>) <span class="comment">// "int32" (rune)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-常量&quot;&gt;&lt;a href=&quot;#一-常量&quot; class=&quot;headerlink&quot; title=&quot;一 常量&quot;&gt;&lt;/a&gt;一 常量&lt;/h2&gt;&lt;p&gt;常量：在编译阶段就确定下来的值，程序运行时无法改变。   &lt;/p&gt;
&lt;p&gt;定义方式：&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
      <category term="Go学习" scheme="https://cool2feel.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Go" scheme="https://cool2feel.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言-流程控制</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</id>
    <published>2020-06-16T07:24:57.000Z</published>
    <updated>2020-06-16T07:59:48.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-流程控制之-条件语句"><a href="#一-流程控制之-条件语句" class="headerlink" title="一 流程控制之-条件语句"></a>一 流程控制之-条件语句</h2><h4 id="1-1-判断语句-if"><a href="#1-1-判断语句-if" class="headerlink" title="1.1 判断语句 if"></a>1.1 判断语句 if</h4><p><code>if</code>判断示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化与判断写在一起： if a := 10; a == 10</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="string">'3'</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if</code>的特殊写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := Connect(); err != <span class="literal">nil</span> &#123;         <span class="comment">// 这里的 err!=nil 才是真正的if判断表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-分支语句-switch"><a href="#1-2-分支语句-switch" class="headerlink" title="1.2 分支语句 switch"></a>1.2 分支语句 switch</h4><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> num &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span>:                          <span class="comment">// case 中可以是表达式</span></span><br><span class="line">      fmt.Println(<span class="string">"111"</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      fmt.Println(<span class="string">"222"</span>)</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(<span class="string">"000"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贴士：</p><ul><li>Go保留了<code>break</code>，用来跳出switch语句，上述案例的分支中默认就书写了该关键字</li><li>Go也提供<code>fallthrough</code>，代表不跳出switch，后面的语句无条件执行</li></ul><h2 id="二-流程控制之-循环语句"><a href="#二-流程控制之-循环语句" class="headerlink" title="二 流程控制之-循环语句"></a>二 流程控制之-循环语句</h2><h4 id="2-1-for循环"><a href="#2-1-for循环" class="headerlink" title="2.1 for循环"></a>2.1 for循环</h4><p>Go只支持for一种循环语句，但是可以对应很多场景：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统的for循环</span></span><br><span class="line"><span class="keyword">for</span> init;condition;post&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环简化</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> ; ; i++ &#123;</span><br><span class="line">   <span class="keyword">if</span>(i &gt; <span class="number">10</span>)&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似while循环</span></span><br><span class="line"><span class="keyword">for</span> condition &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 死循环</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for range:一般用于遍历数组、切片、字符串、map、管道</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-跳出循环"><a href="#2-2-跳出循环" class="headerlink" title="2.2 跳出循环"></a>2.2 跳出循环</h4><p>常用的跳出循环关键字：</p><ul><li><code>break</code>用于函数内跳出当前<code>for</code>、<code>switch</code>、<code>select</code>语句的执行</li><li><code>continue</code>用于跳出<code>for</code>循环的本次迭代。  </li><li><code>goto</code>可以退出多层循环</li></ul><p>break跳出循环案例(continue同下)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OuterLoop:</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">         <span class="keyword">switch</span> j &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">               fmt.Println(i,j)</span><br><span class="line">               <span class="keyword">break</span> OuterLoop</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">               fmt.Println(i,j)</span><br><span class="line">               <span class="keyword">break</span> OuterLoop</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>goto跳出多重循环案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x:=<span class="number">0</span>; x&lt;<span class="number">10</span>; x++ &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">for</span> y:=<span class="number">0</span>; y&lt;<span class="number">10</span>; x++ &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> y==<span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> breakHere</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">breakHere:</span><br><span class="line">   fmt.Println(<span class="string">"break"</span>)</span><br></pre></td></tr></table></figure><p>贴士：goto也可以用来统一错误处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">goto</span> onExit</span><br><span class="line">&#125;</span><br><span class="line">onExit:</span><br><span class="line">   fmt.Pritln(err)</span><br><span class="line">   exitProcess()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-流程控制之-条件语句&quot;&gt;&lt;a href=&quot;#一-流程控制之-条件语句&quot; class=&quot;headerlink&quot; title=&quot;一 流程控制之-条件语句&quot;&gt;&lt;/a&gt;一 流程控制之-条件语句&lt;/h2&gt;&lt;h4 id=&quot;1-1-判断语句-if&quot;&gt;&lt;a href=&quot;#1-
      
    
    </summary>
    
    
      <category term="Go学习" scheme="https://cool2feel.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Go" scheme="https://cool2feel.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言-标识符与变量</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E6%A0%87%E8%AF%86%E7%AC%A6%E4%B8%8E%E5%8F%98%E9%87%8F/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E6%A0%87%E8%AF%86%E7%AC%A6%E4%B8%8E%E5%8F%98%E9%87%8F/</id>
    <published>2020-06-16T07:24:57.000Z</published>
    <updated>2020-06-16T07:56:31.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-标识符"><a href="#一-标识符" class="headerlink" title="一 标识符"></a>一 标识符</h2><h4 id="1-1-关键字"><a href="#1-1-关键字" class="headerlink" title="1.1 关键字"></a>1.1 关键字</h4><p>Go现在拥有25个关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if      for     func    case        struct      import               </span><br><span class="line">go      type    chan    defer       default     package</span><br><span class="line">map     const   else    break       select      interface</span><br><span class="line">var     goto    range   return      switch      continue     fallthrough</span><br></pre></td></tr></table></figure><h4 id="1-2-保留字"><a href="#1-2-保留字" class="headerlink" title="1.2 保留字"></a>1.2 保留字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">内建常量：  </span><br><span class="line">        true        false       iota        nil</span><br><span class="line">内建类型：  </span><br><span class="line">        int         int8        int16       int32       int64</span><br><span class="line">        uint        uint8       uint16      uint32      uint64      uintptr</span><br><span class="line">        float32     float64 </span><br><span class="line">        complex128  complex64</span><br><span class="line">bool：      </span><br><span class="line">        byte        rune        string     error</span><br><span class="line">内建函数：   </span><br><span class="line">        make        delete      complex     panic       append      copy    </span><br><span class="line">        close       len         cap        real        imag        new       recover</span><br></pre></td></tr></table></figure><h2 id="二-变量"><a href="#二-变量" class="headerlink" title="二 变量"></a>二 变量</h2><h4 id="2-1-变量声明"><a href="#2-1-变量声明" class="headerlink" title="2.1 变量声明"></a>2.1 变量声明</h4><p>Go变量声明的三种方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span>    <span class="comment">// 声明一个变量，默认为0</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>    <span class="comment">// 声明并初始化，且自动推导类型</span></span><br><span class="line">c := <span class="number">20</span>    <span class="comment">// 初始化，且自动推导</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>:=</code>定义变量只能在函数内部使用，所以经常用var定义全局变量</li><li>Go对已经声明但未使用的变量会在编译阶段报错：<code>** not used</code></li><li>Go中的标识符以字母或者下划线开头，大小写敏感</li><li>Go推荐使用驼峰命名 </li></ul><h4 id="2-2-多变量声明"><a href="#2-2-多变量声明" class="headerlink" title="2.2 多变量声明"></a>2.2 多变量声明</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> a1,b1 <span class="keyword">string</span> = <span class="string">"哼"</span>,<span class="string">"哈"</span></span><br><span class="line"><span class="keyword">var</span> a2,b2 <span class="keyword">int</span> = <span class="number">1</span>,<span class="number">2</span>                             <span class="comment">//类型可以直接省略</span></span><br><span class="line">c,d := <span class="number">1</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">e <span class="keyword">int</span></span><br><span class="line">f <span class="keyword">bool</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="2-3-变量值互换"><a href="#2-3-变量值互换" class="headerlink" title="2.3 变量值互换"></a>2.3 变量值互换</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m,n = n,m<span class="comment">//变量值互换</span></span><br><span class="line">temp,_ = m,n<span class="comment">//匿名变量：变量值互换，且丢弃变量n</span></span><br></pre></td></tr></table></figure><h4 id="2-4-丢弃变量"><a href="#2-4-丢弃变量" class="headerlink" title="2.4 _丢弃变量"></a>2.4 _丢弃变量</h4><p><code>_</code>是个特殊的变量名，任何赋予它的值都会被丢弃。该变量不占用命名空间，也不会分配内存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, b := <span class="number">34</span>, <span class="number">35</span>      <span class="comment">//将值`35`赋予`b`，并同时丢弃`34`：</span></span><br></pre></td></tr></table></figure><h4 id="2-5-声明的注意事项"><a href="#2-5-声明的注意事项" class="headerlink" title="2.5 := 声明的注意事项"></a>2.5 := 声明的注意事项</h4><p>下面是正确的代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in, err := os.Open(file)</span><br><span class="line">out, err := os.Create(file)     <span class="comment">// err已经在上方定义，此处的 err其实是赋值</span></span><br></pre></td></tr></table></figure><p>但是如果在第二行赋值的变量名全部和第一行一致，则编译不通过：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in, err := os.Open(file)</span><br><span class="line">in, err := os.Create(file)     <span class="comment">// 即 := 必须确保至少有一个变量是用于声明</span></span><br></pre></td></tr></table></figure><p><code>:=</code>只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么<code>:=</code>将会在当前词法域重新声明一个新的变量。</p><h4 id="2-6-多数据分组书写"><a href="#2-6-多数据分组书写" class="headerlink" title="2.6 多数据分组书写"></a>2.6 多数据分组书写</h4><p>Go可以使用该方式声明多个数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    i = <span class="number">100</span></span><br><span class="line">    pi = <span class="number">3.1415</span></span><br><span class="line">    prefix = <span class="string">"Go_"</span></span><br><span class="line">)</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">var</span>(</span><br><span class="line">    i <span class="keyword">int</span></span><br><span class="line">    pi <span class="keyword">float32</span></span><br><span class="line">    prefix <span class="keyword">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="三-关键字iota"><a href="#三-关键字iota" class="headerlink" title="三 关键字iota"></a>三 关键字iota</h2><p>关键字iota声明初始值为0，每行递增1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span>            <span class="comment">// 0</span></span><br><span class="line">    b =<span class="literal">iota</span>         <span class="comment">// 1        </span></span><br><span class="line">    c = <span class="literal">iota</span>         <span class="comment">// 2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    d = <span class="literal">iota</span>            <span class="comment">//  0</span></span><br><span class="line">    e <span class="comment">// 1        </span></span><br><span class="line">    f <span class="comment">// 2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果iota在同一行，则值都一样</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    g = <span class="literal">iota</span>            <span class="comment">//0</span></span><br><span class="line">    h,i,j = <span class="literal">iota</span>,<span class="literal">iota</span>,<span class="literal">iota</span>      <span class="comment">// 1,1,1</span></span><br><span class="line">    <span class="comment">// k = 3                    // 此处不能定义缺省常量，会编译错误</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-标识符&quot;&gt;&lt;a href=&quot;#一-标识符&quot; class=&quot;headerlink&quot; title=&quot;一 标识符&quot;&gt;&lt;/a&gt;一 标识符&lt;/h2&gt;&lt;h4 id=&quot;1-1-关键字&quot;&gt;&lt;a href=&quot;#1-1-关键字&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="Go学习" scheme="https://cool2feel.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Go" scheme="https://cool2feel.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言-反射2</title>
    <link href="https://cool2feel.github.io/2020/05/09/%E5%8F%8D%E5%B0%84-2-%E5%BA%94%E7%94%A8/"/>
    <id>https://cool2feel.github.io/2020/05/09/%E5%8F%8D%E5%B0%84-2-%E5%BA%94%E7%94%A8/</id>
    <published>2020-05-09T02:24:27.000Z</published>
    <updated>2020-06-16T07:57:36.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-反射的使用"><a href="#一-反射的使用" class="headerlink" title="一 反射的使用"></a>一 反射的使用</h2><h4 id="1-1-反射操作简单数据类型"><a href="#1-1-反射操作简单数据类型" class="headerlink" title="1.1 反射操作简单数据类型"></a>1.1 反射操作简单数据类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="keyword">int64</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置值：指针传递</span></span><br><span class="line">ptrValue := reflect.ValueOf(&amp;num)</span><br><span class="line">newValue := ptrValue.Elem()                         <span class="comment">// Elem()用于获取原始值的反射对象</span></span><br><span class="line">fmt.Println(<span class="string">"type："</span>, newValue.Type())<span class="comment">// int64</span></span><br><span class="line">fmt.Println(<span class="string">" can set："</span>, newValue.CanSet())<span class="comment">// true</span></span><br><span class="line">newValue.SetInt(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取值：值传递</span></span><br><span class="line">rValue := reflect.ValueOf(num)</span><br><span class="line">fmt.Println(rValue.Int())<span class="comment">// 方式一：200</span></span><br><span class="line">fmt.Println(rValue.Interface().(<span class="keyword">int64</span>))<span class="comment">// 方式二：200</span></span><br></pre></td></tr></table></figure><h4 id="1-2-反射进行类型推断"><a href="#1-2-反射进行类型推断" class="headerlink" title="1.2 反射进行类型推断"></a>1.2 反射进行类型推断</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u := &amp;user&#123;</span><br><span class="line">Name: <span class="string">"Ruyue"</span>,</span><br><span class="line">Age:  <span class="number">100</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(reflect.TypeOf(u))<span class="comment">// *main.user</span></span><br><span class="line">fmt.Println(reflect.TypeOf(*u))<span class="comment">// main.user</span></span><br><span class="line">fmt.Println(reflect.TypeOf(*u).Name())<span class="comment">// user</span></span><br><span class="line">fmt.Println(reflect.TypeOf(*u).Kind())<span class="comment">// struct</span></span><br></pre></td></tr></table></figure><h4 id="1-3-反射操作指针"><a href="#1-3-反射操作指针" class="headerlink" title="1.3 反射操作指针"></a>1.3 反射操作指针</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u := &amp;user&#123;</span><br><span class="line">Name: <span class="string">"Ruyue"</span>,</span><br><span class="line">Age:  <span class="number">100</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typeOfUser = reflect.TypeOf(u).Elem()</span><br><span class="line">fmt.Println(<span class="string">"element name: "</span>, typeOfUser.Name())<span class="comment">// user</span></span><br><span class="line">fmt.Println(<span class="string">"element kind: "</span>, typeOfUser.Kind())<span class="comment">// struct</span></span><br></pre></td></tr></table></figure><h4 id="1-4-反射操作结构体"><a href="#1-4-反射操作结构体" class="headerlink" title="1.4 反射操作结构体"></a>1.4 反射操作结构体</h4><p>反射可以获取结构体的详细信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age  <span class="keyword">int</span> <span class="string">`json:"age" id:"100"`</span> <span class="comment">// 结构体标签</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s := user&#123;</span><br><span class="line">Name: <span class="string">"zs"</span>,</span><br><span class="line">Age:  <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typeOfUser := reflect.TypeOf(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字段用法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; typeOfUser.NumField(); i++ &#123;        <span class="comment">// NumField 当前结构体有多少个字段</span></span><br><span class="line">fieldType := typeOfUser.Field(i)                <span class="comment">// 获取每个字段</span></span><br><span class="line">fmt.Println(fieldType.Name, fieldType.Tag)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> userAge, ok := typeOfUser.FieldByName(<span class="string">"Age"</span>); ok &#123;</span><br><span class="line">fmt.Println(userAge)<span class="comment">// &#123;Age  int json:"age" id:"100" 16 [1] false&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法用法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; typeOfUser.NumMethod(); i++ &#123;</span><br><span class="line">fieldType := typeOfUser.Method(i)                <span class="comment">// 获取每个字段</span></span><br><span class="line">fmt.Println(fieldType.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-反射调用函数与方法"><a href="#二-反射调用函数与方法" class="headerlink" title="二 反射调用函数与方法"></a>二 反射调用函数与方法</h2><h4 id="2-1-使用反射调用函数"><a href="#2-1-使用反射调用函数" class="headerlink" title="2.1 使用反射调用函数"></a>2.1 使用反射调用函数</h4><p>如果反射值对象(reflect.Value)中值的类型为函数时，可以通过 reflect.Value调用该 函数。使用反射调用函数时，需要将参数使用反射值对象的切片 口reflect.Value 构造后传入 Call()方法中 ， 调用完成时，函数的返回值通过 []reflect.Value 返回 。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"name is %s, age is %d \n"</span>, name, age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">funcValue := reflect.ValueOf(add)</span><br><span class="line">params := []reflect.Value&#123;reflect.ValueOf(<span class="string">"lisi"</span>), reflect.ValueOf(<span class="number">20</span>)&#125;</span><br><span class="line"></span><br><span class="line">reList := funcValue.Call(params)</span><br><span class="line">fmt.Println(reList)<span class="comment">// 函数返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-反射调用方法"><a href="#2-2-反射调用方法" class="headerlink" title="2.2 反射调用方法"></a>2.2 反射调用方法</h3><p>方法的调用是需要接收者的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">ShowName</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(u.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">AddAge</span><span class="params">(addNum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"age add result:"</span>, u.Age + addNum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">u := &amp;user&#123;<span class="string">"lisi"</span>, <span class="number">20</span>&#125;</span><br><span class="line">v := reflect.ValueOf(u)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用无参方法</span></span><br><span class="line">methodV := v.MethodByName(<span class="string">"ShowName"</span>)</span><br><span class="line">methodV.Call(<span class="literal">nil</span>)<span class="comment">// 或者传递一个空切片也可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用有参方法</span></span><br><span class="line">methodV2 := v.MethodByName(<span class="string">"AddAge"</span>)</span><br><span class="line">args := []reflect.Value&#123;reflect.ValueOf(<span class="number">30</span>)&#125;<span class="comment">//</span></span><br><span class="line">methodV2.Call(args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-反射的使用&quot;&gt;&lt;a href=&quot;#一-反射的使用&quot; class=&quot;headerlink&quot; title=&quot;一 反射的使用&quot;&gt;&lt;/a&gt;一 反射的使用&lt;/h2&gt;&lt;h4 id=&quot;1-1-反射操作简单数据类型&quot;&gt;&lt;a href=&quot;#1-1-反射操作简单数据类型&quot; cla
      
    
    </summary>
    
    
      <category term="Go学习" scheme="https://cool2feel.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Go" scheme="https://cool2feel.github.io/tags/Go/"/>
    
  </entry>
  
</feed>

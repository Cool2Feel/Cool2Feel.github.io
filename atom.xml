<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dwl&#39;s blog</title>
  
  <subtitle>记录生活中的点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cool2feel.github.io/"/>
  <updated>2020-06-16T07:25:21.937Z</updated>
  <id>https://cool2feel.github.io/</id>
  
  <author>
    <name>Dwesome</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言介绍</title>
    <link href="https://cool2feel.github.io/2020/06/16/Go%E7%AE%80%E4%BB%8B/"/>
    <id>https://cool2feel.github.io/2020/06/16/Go%E7%AE%80%E4%BB%8B/</id>
    <published>2020-06-16T07:24:57.000Z</published>
    <updated>2020-06-16T07:25:21.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-Go语言介绍"><a href="#一-Go语言介绍" class="headerlink" title="一 Go语言介绍"></a>一 Go语言介绍</h2><p>Go语言是Google公司开发的一种静态、编译型语言，具备自动垃圾回收功能，原生支持并发开发。   </p><p>Go的诞生是为了解决当下编程语言对并发支持不友好、编译速度慢、编程复杂这三个主要问题。   </p><p>Go既拥有接近静态编译语言（如C）的安全和性能，又有接近脚本语言（如python）的开发效率，其主要特点有：   </p><ul><li>天然并发：语言层面支持并发，包括gorotuine、channel</li><li>语法优势：没有历史包袱，包含多返回值、匿名函数、defer</li><li>语言层面支持多核CPU利用</li></ul><p>与Java相比的不同：</p><ul><li>没有Java支持的一些面向对象思想：重载、构造函数、继承等</li><li>代码规范严格：花括号位置固定，变量名大小写代表公有私有等</li><li>支持函数式编程：匿名函数，闭包</li><li>接口非侵入式：不需要显式声明对接口的继承，实现了接口的方法即为实现了该接口类型</li></ul><h2 id="二-Go安装"><a href="#二-Go安装" class="headerlink" title="二 Go安装"></a>二 Go安装</h2><p>推荐使用官方的安装包直接安装，下载地址：<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a>   </p><p>贴士：本笔记都是基于go1.13    </p><p><strong>Win安装Go</strong>：<br>打开Win安装包下一步下一步即可，默认安装在目录：c:\Go  </p><p><strong>Mac安装Go</strong>：<br>打开Mac安装包下一步下一步即可，需要预装Xcode。安装完毕后需配置环境变量即可使用，但是如果要使用一些<code>go mod</code>功能推荐如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.bash_profile</span><br><span class="line"></span><br><span class="line">export GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go                 # golang本身的安装位置</span><br><span class="line">export GOPATH&#x3D;~&#x2F;go&#x2F;                         # golang包的本地安装位置</span><br><span class="line">export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.io           # golang包的下载代理</span><br><span class="line">export GO111MODULE&#x3D;on                       # 开启go mod模式</span><br><span class="line">export PATH&#x3D;$PATH:$GOROOT&#x2F;bin               # go本身二进制文件的环境变量</span><br><span class="line">export PATH&#x3D;$PATH:$GOPATH&#x2F;bin               # go第三方二进制文件的环境便令</span><br><span class="line"></span><br><span class="line"># 重启环境</span><br><span class="line">source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure><p><strong>Linux安装Go</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 下载解压</span><br><span class="line">wget https:&#x2F;&#x2F;dl.google.com&#x2F;go&#x2F;go1.13.1.linux-amd64.tar.gz</span><br><span class="line">tar zxvf go*.tar.gz -C &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line"></span><br><span class="line"># 配置环境：注意该环境必须是go1.11版本及以上且项目要求使用go mod才可以开启</span><br><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line">export GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go                 # golang本身的安装位置</span><br><span class="line">export GOPATH&#x3D;~&#x2F;go                          # golang包的本地安装位置</span><br><span class="line">export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.io,direct    # golang包的下载代理,回源地址获取</span><br><span class="line">export GO111MODULE&#x3D;on                       # 开启go mod模式</span><br><span class="line">export PATH&#x3D;$PATH:$GOROOT&#x2F;bin               # go本身二进制文件的环境变量</span><br><span class="line">export PATH&#x3D;$PATH:$GOPATH&#x2F;bin               # go第三方二进制文件的环境便令</span><br><span class="line"></span><br><span class="line"># 重启环境</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>测试安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看go版本</span><br><span class="line">go version</span><br><span class="line"></span><br><span class="line"># 查看go环境配置</span><br><span class="line">go env</span><br></pre></td></tr></table></figure><p>关于<code>go modules</code>的详细讲解位于本章12节。</p><h2 id="三-HelloWorld"><a href="#三-HelloWorld" class="headerlink" title="三 HelloWorld"></a>三 HelloWorld</h2><p>新建文件<code>hello.go</code>，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main                        <span class="comment">//每个程序都有且仅有一个main包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span>    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;                       <span class="comment">//主函数main只有一个</span></span><br><span class="line">    fmt.Println(<span class="string">"Hello World!"</span>)     <span class="comment">//函数调用：包名.函数名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 执行方式一：先编译，再运行</span><br><span class="line">go build hello.go        # 编译。在同级目录下生成文件&#96;hello&#96;，添加参数&#96;-o 名称&#96; 则可指定生成的文件名 </span><br><span class="line">.&#x2F;hello                  # 运行。贴士：win下生成的是.exe文件，直接双击执行即可</span><br><span class="line"></span><br><span class="line"># 执行方式二：直接运行</span><br><span class="line">go run hello.go</span><br></pre></td></tr></table></figure><p>两种执行流程的区别：  </p><ul><li>先编译方式：可执行文件可以在任意没有go环境的机器上运行，（因为go依赖被打包进了可执行文件）</li><li>直接执行方式：源码执行时，依赖于机器上的go环境，没有go环境无法直接运行</li></ul><h2 id="四-Go语法注意"><a href="#四-Go语法注意" class="headerlink" title="四 Go语法注意"></a>四 Go语法注意</h2><ul><li>Go源文件以 “go” 为扩展名</li><li>与Java、C语言类似，Go应用程序的执行入口也是main()函数</li><li>Go语言严格区分大小写</li><li>Go不需要分号结尾</li><li>Go编译是一行一行执行，所以不能将类似两个 Print 函数写在一行</li><li>Go语言定义的变量或者import的包如果没有使用到，代码不能编译通过</li><li>Go的注释使用 // 或者 /*  */</li></ul><h2 id="五-开发工具推荐"><a href="#五-开发工具推荐" class="headerlink" title="五 开发工具推荐"></a>五 开发工具推荐</h2><p>笔者推荐的go开发工具：</p><ul><li>goland</li><li>vscode</li></ul><p>vscode的相关go插件会出现无法下载情况，解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 如果开启了go mod，则</span><br><span class="line">    go get -u -v github.com&#x2F;ramya-rao-a&#x2F;go-outline</span><br><span class="line">    go get -u -v github.com&#x2F;acroca&#x2F;go-symbols</span><br><span class="line">    go get -u -v golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;guru</span><br><span class="line">    go get -u -v golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;gorename</span><br><span class="line">    go get -u -v github.com&#x2F;rogpeppe&#x2F;godef</span><br><span class="line">    go get -u -v github.com&#x2F;sqs&#x2F;goreturns</span><br><span class="line">    go get -u -v github.com&#x2F;cweill&#x2F;gotests&#x2F;gotests</span><br><span class="line">    go get -u -v golang.org&#x2F;x&#x2F;lint&#x2F;golint</span><br><span class="line"></span><br><span class="line"># 如果未开启go mod，则需要进入cd $GOPATH&#x2F;src ，使用 git clone 下载上述文件        </span><br><span class="line"></span><br><span class="line"># 安装</span><br><span class="line">cd $GOPATH</span><br><span class="line">    go install github.com&#x2F;ramya-rao-a&#x2F;go-outline</span><br><span class="line">    go install github.com&#x2F;acroca&#x2F;go-symbols</span><br><span class="line">    go install golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;guru</span><br><span class="line">    go install golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;gorename</span><br><span class="line">    go install github.com&#x2F;rogpeppe&#x2F;godef</span><br><span class="line">    go install github.com&#x2F;sqs&#x2F;goreturns</span><br><span class="line">    go install github.com&#x2F;cweill&#x2F;gotests&#x2F;gotests</span><br><span class="line">    go install golang.org&#x2F;x&#x2F;lint&#x2F;golint</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-Go语言介绍&quot;&gt;&lt;a href=&quot;#一-Go语言介绍&quot; class=&quot;headerlink&quot; title=&quot;一 Go语言介绍&quot;&gt;&lt;/a&gt;一 Go语言介绍&lt;/h2&gt;&lt;p&gt;Go语言是Google公司开发的一种静态、编译型语言，具备自动垃圾回收功能，原生支持并发开发
      
    
    </summary>
    
    
      <category term="Go学习" scheme="https://cool2feel.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Go" scheme="https://cool2feel.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>反射-1-概述</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%8F%8D%E5%B0%84-1-%E6%A6%82%E8%BF%B0/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%8F%8D%E5%B0%84-1-%E6%A6%82%E8%BF%B0/</id>
    <published>2020-06-16T07:16:24.742Z</published>
    <updated>2020-04-21T01:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-反射简介"><a href="#一-反射简介" class="headerlink" title="一 反射简介"></a>一 反射简介</h2><p>反射是指在程序运行期对程序本身进行访问和修改的能力，即可以在运行时动态获取变量的各种信息，比如变量的类型（type），类别（kind），如果是结构体变量，还可以获取到结构体本身的信息（字段与方法），通过反射，还可以修改变量的值，可以调用关联的方法。  </p><p>反射常用在框架的开发上，一些常见的案例，如JSON序列化时候tag标签的产生，适配器函数的制作等，都需要用到反射。反射的两个使用常见使用场景：</p><ul><li>不知道函数的参数类型：没有约定好参数、传入类型很多，此时类型不能统一表示，需要反射</li><li>不知道调用哪个函数：比如根据用户的输入来决定调用特定函数，此时需要依据函数、函数参数进行反射，在运行期间动态执行函数</li></ul><p>Go程序的反射系统无法获取到一个可执行文件空间中或者是一个包中的所有类型信息，需要配合使用标准库中对应的词法、语法解析器和抽象语法树( AST) 对源码进行扫描后获得这些信息。  </p><p>贴士：</p><ul><li>C，C++没有支持反射功能，只能通过 typeid 提供非常弱化的程序运行时类型信息。</li><li>Java、 C#等语言都支持完整的反射功能。</li><li>Lua、JavaScript类动态语言，由于其本身的语法特性就可以让代码在运行期访问程序自身的值和类型信息，因此不需要反射系统。    </li></ul><p>注意：</p><ul><li>在编译期间，无法对反射代码进行一些错误提示。</li><li>反射影响性能</li></ul><h2 id="二-反射是如何实现的"><a href="#二-反射是如何实现的" class="headerlink" title="二 反射是如何实现的"></a>二 反射是如何实现的</h2><p>反射是通过接口的类型信息实现的，即反射建立在类型的基础上：当向接口变量赋予一个实体类型的时候，接口会存储实体的类型信息。  </p><p>Go中反射相关的包是<code>reflect</code>，在该包中，定义了各种类型，实现了反射的各种函数，通过它们可以在运行时检测类型的信息、改变类型的值。  </p><p>变量包括type、value两个部分（所以 <code>nil != nil</code> ），type包括两部分：</p><ul><li>static type：在开发时使用的类型，如int、string</li><li>concrete type：是runtime系统使用的类型</li></ul><p>类型能够断言成功，取决于 concrete type ，如果一个reader变量，如果 concrete type 实现了 write 方法，那么它可以被类型断言为writer。  </p><p>Go中，反射与interface类型相关，其type是 concrete type，只有interface才有反射！每个interface变量都有一个对应的pair，pair中记录了变量的实际值和类型（value, type）。即一个接口类型变量包含2个指针，一个指向对应的 concrete type ，另一个指向实际的值 value。  </p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r io.Reader<span class="comment">// 定义了一个接口类型</span></span><br><span class="line">r, err := os.OpenFile()<span class="comment">// 记录接口的实际类型、实际值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w io.Writer<span class="comment">// 定义一个接口类型</span></span><br><span class="line">w = r.(io.Writer)<span class="comment">// 赋值时，接口内部的pair不变，所以 w 和 r 是同一类型</span></span><br></pre></td></tr></table></figure><h2 id="三-Go中反射初识"><a href="#三-Go中反射初识" class="headerlink" title="三 Go中反射初识"></a>三 Go中反射初识</h2><h3 id="3-1-reflect包的两个函数"><a href="#3-1-reflect包的两个函数" class="headerlink" title="3.1 reflect包的两个函数"></a>3.1 reflect包的两个函数</h3><p>reflect 提供了2个重要函数：</p><ul><li>ValueOf()：获取变量的值，即pair中的 value</li><li>TypeOf()：获取变量的类型，即pair中的  concrete type</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">p := Person&#123; <span class="string">"lisi"</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(reflect.ValueOf(p))<span class="comment">// &#123;lisi 13&#125;  变量的值</span></span><br><span class="line">fmt.Println(reflect.ValueOf(p).Type())<span class="comment">// main.Person 变量类型的对象名</span></span><br><span class="line"></span><br><span class="line">fmt.Println(reflect.TypeOf(p))<span class="comment">//  main.Person变量类型的对象名</span></span><br><span class="line"></span><br><span class="line">fmt.Println(reflect.TypeOf(p).Name())<span class="comment">// Person:变量类型对象的类型名</span></span><br><span class="line">fmt.Println(reflect.TypeOf(p).Kind())<span class="comment">// struct:变量类型对象的种类名</span></span><br><span class="line"></span><br><span class="line">fmt.Println(reflect.TypeOf(p).Name() == <span class="string">"Person"</span>)<span class="comment">// true</span></span><br><span class="line">fmt.Println(reflect.TypeOf(p).Kind() == reflect.Struct)<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>类型与种类的区别：</p><ul><li>Type是原生数据类型： int、string、bool、float32 ，以及 type 定义的类型，对应的反射获取方法是 reflect.Type 中 的 Name()</li><li>Kind是对象归属的品种：Int、Bool、Float32、Chan、String、Struct、Ptr（指针）、Map、Interface、Fune、Array、Slice、Unsafe Pointer等</li></ul><h3 id="3-2-静态类型与动态类型"><a href="#3-2-静态类型与动态类型" class="headerlink" title="3.2 静态类型与动态类型"></a>3.2 静态类型与动态类型</h3><p>静态类型：变量声明时候赋予的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span><span class="comment">// int 是静态类型</span></span><br><span class="line"><span class="keyword">var</span> i *<span class="keyword">int</span><span class="comment">// *int 是静态类型</span></span><br></pre></td></tr></table></figure><p>动态类型：运行时给这个变量赋值时，这个值的类型即为动态类型（为nil时没有动态类型）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A <span class="keyword">interface</span>&#123;&#125;<span class="comment">// 空接口 是静态类型，必须是接口类型才能实现类型动态变化</span></span><br><span class="line">A = <span class="number">10</span><span class="comment">// 此时静态类型为 interface&#123;&#125; 动态为int</span></span><br><span class="line">A = <span class="string">"hello"</span><span class="comment">// 此时静态类型为 interface&#123;&#125; 动态为string</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-反射简介&quot;&gt;&lt;a href=&quot;#一-反射简介&quot; class=&quot;headerlink&quot; title=&quot;一 反射简介&quot;&gt;&lt;/a&gt;一 反射简介&lt;/h2&gt;&lt;p&gt;反射是指在程序运行期对程序本身进行访问和修改的能力，即可以在运行时动态获取变量的各种信息，比如变量的类型（t
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>时间操作</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C/</id>
    <published>2020-06-16T07:16:24.741Z</published>
    <updated>2020-04-21T01:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-时间操作"><a href="#一-时间操作" class="headerlink" title="一 时间操作"></a>一 时间操作</h2><h3 id="1-1-创建时间"><a href="#1-1-创建时间" class="headerlink" title="1.1 创建时间"></a>1.1 创建时间</h3><p>Golang中时间操作位于 time 包中，常见操作有：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前时间</span></span><br><span class="line">nowTime := time.Now()</span><br><span class="line">fmt.Printf(<span class="string">"当前时间为：%T\n"</span>, nowTime)<span class="comment">// 其类型是 time.Time</span></span><br><span class="line">fmt.Println(nowTime)<span class="comment">// 2019-01-01 13:50:07.522712 +0800 CST m=+0.000138178</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义时间</span></span><br><span class="line">customTime := time.Date(<span class="number">2008</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">30</span>,<span class="number">0</span>,<span class="number">0</span>, time.Local)</span><br><span class="line">fmt.Println(customTime)<span class="comment">// 2008-07-15 13:30:00 +0800 CST</span></span><br></pre></td></tr></table></figure><h3 id="1-2-时间格式化与解析"><a href="#1-2-时间格式化与解析" class="headerlink" title="1.2 时间格式化与解析"></a>1.2 时间格式化与解析</h3><p>Go的时间格式化必须传入Go的生日：<code>Mon Jan 2 15:04:05 -0700 MST 2006</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nowTime := time.Now()</span><br><span class="line">stringTime := nowTime.Format(<span class="string">"2006年1月2日 15:04:05"</span>)</span><br><span class="line">fmt.Println(stringTime)<span class="comment">// 2019年01月01日 13:55:30</span></span><br></pre></td></tr></table></figure><p>Go的时间解析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   stringTime := <span class="string">"2019-01-01 15:03:01"</span></span><br><span class="line">objTime,_ := time.Parse(<span class="string">"2006-01-02 15:04:05"</span>,stringTime)</span><br><span class="line">fmt.Println(objTime)<span class="comment">// 2019-01-01 15:03:01 +0000 UTC</span></span><br></pre></td></tr></table></figure><p>注意：这些方法的参数模板必须与时间一一对应，否则报错！</p><h3 id="1-3-获取-年-月-日"><a href="#1-3-获取-年-月-日" class="headerlink" title="1.3 获取 年 月 日"></a>1.3 获取 年 月 日</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   nowTime := time.Now()</span><br><span class="line"></span><br><span class="line">year, month, day := nowTime.Date()</span><br><span class="line">fmt.Println(year, month, day)<span class="comment">// 2019 November 01</span></span><br><span class="line"></span><br><span class="line">hour, min, sec := nowTime.Clock()</span><br><span class="line">fmt.Println(hour, min, sec)</span><br><span class="line"></span><br><span class="line">fmt.Println(nowTime.Year())</span><br><span class="line">fmt.Println(nowTime.Month())</span><br><span class="line">fmt.Println(nowTime.Hour())</span><br><span class="line"></span><br><span class="line">fmt.Println(nowTime.YearDay())<span class="comment">// 指今年一共过了多少天</span></span><br></pre></td></tr></table></figure><h3 id="1-4-时间戳"><a href="#1-4-时间戳" class="headerlink" title="1.4 时间戳"></a>1.4 时间戳</h3><p>时间戳是指计算时间距离 1970年1月1日的秒数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nowTime := time.Now()</span><br><span class="line">fmt.Println(nowTime.Unix())</span><br></pre></td></tr></table></figure><h3 id="1-5-时间间隔"><a href="#1-5-时间间隔" class="headerlink" title="1.5 时间间隔"></a>1.5 时间间隔</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nowTime := time.Now()</span><br><span class="line">fmt.Println(nowTime.Add(time.Second * <span class="number">10</span>))  <span class="comment">// 10秒后</span></span><br><span class="line">   fmt.Println(nowTime.AddDate(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>))<span class="comment">// 1年后</span></span><br></pre></td></tr></table></figure><p>贴士：</p><ul><li>传入负数则是往前计算</li><li>Sub()函数可以用来计算两个时间的差值</li></ul><h3 id="1-6-时间睡眠"><a href="#1-6-时间睡眠" class="headerlink" title="1.6 时间睡眠"></a>1.6 时间睡眠</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.Sleep(time.Second * <span class="number">3</span>)<span class="comment">// 程序睡眠三秒钟</span></span><br></pre></td></tr></table></figure><h2 id="二-时间中的通道操作（定时器）"><a href="#二-时间中的通道操作（定时器）" class="headerlink" title="二 时间中的通道操作（定时器）"></a>二 时间中的通道操作（定时器）</h2><p>标准库中的Timer可以让用户自定义一个定时器，在用对select处理多个channel的超时、单channel读写的超时等情形时很方便：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timer := time.NewTimer(time.Second * <span class="number">3</span>)<span class="comment">// 类型为 *time.Timer</span></span><br><span class="line">ch := timer.C<span class="comment">// timer内部包含一个通道</span></span><br><span class="line">fmt.Println(&lt;-ch)<span class="comment">// 3秒后，通道内有了数据，可以取出</span></span><br></pre></td></tr></table></figure><p>配合协程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">timer := time.NewTimer(time.Second * <span class="number">3</span>)<span class="comment">// 类型为 *time.Timer</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;- timer.C</span><br><span class="line">fmt.Println(<span class="string">"timer 结束"</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">flag := timer.Stop()<span class="comment">// 取消定时器</span></span><br><span class="line">   fmt.Println(flag)<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>time.After函数的使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch := time.After(time.Second * <span class="number">3</span>)<span class="comment">// 底层其实是 new Timer(d).C</span></span><br><span class="line">newTime := &lt;-ch<span class="comment">// 阻塞3秒</span></span><br><span class="line">fmt.Println(newTime)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-时间操作&quot;&gt;&lt;a href=&quot;#一-时间操作&quot; class=&quot;headerlink&quot; title=&quot;一 时间操作&quot;&gt;&lt;/a&gt;一 时间操作&lt;/h2&gt;&lt;h3 id=&quot;1-1-创建时间&quot;&gt;&lt;a href=&quot;#1-1-创建时间&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>文件操作-2-读操作</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-2-%E8%AF%BB%E6%93%8D%E4%BD%9C/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-2-%E8%AF%BB%E6%93%8D%E4%BD%9C/</id>
    <published>2020-06-16T07:16:24.740Z</published>
    <updated>2020-04-21T01:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-文件读取"><a href="#一-文件读取" class="headerlink" title="一 文件读取"></a>一 文件读取</h2><p>文件读写的接口位于io包，file文件类是这些接口的实现类。</p><h3 id="1-1-直接读取-read"><a href="#1-1-直接读取-read" class="headerlink" title="1.1 直接读取 read()"></a>1.1 直接读取 read()</h3><p>read() 实现的是按字节数读取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">readByte := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">128</span>)<span class="comment">// 指定要读取的长度</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := f.Read(readByte)<span class="comment">// 将数据读取如切片，返回值 n 是实际读取到的字节数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF&#123;<span class="comment">// 如果读到了文件末尾：EOF 即 end of file</span></span><br><span class="line">fmt.Println(<span class="string">"read file : "</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"read: "</span>, <span class="keyword">string</span>(readByte[:n]))</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">128</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read end"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-bufio的写操作"><a href="#1-2-bufio的写操作" class="headerlink" title="1.2 bufio的写操作"></a>1.2 bufio的写操作</h3><p>bufio封装了io.Reader、io.Writer接口对象，并创建了另一个也实现了该接口的对象：bufio.Reader、bufio.Writer。通过该实现，bufio实现了文件的缓冲区设计，可以大大提高文件I/O的效率。  </p><p>使用bufio读取文件时，先将数据读入内存的缓冲区（缓冲区一般比要比程序中设置的文件接收对象要大），这样就可以有效降低直接I/O的次数。  </p><p><code>bufio.Read([]byte)</code>相当于读取大小<code>len(p)</code>的内容：</p><ul><li>当缓冲区有内容时，将缓冲区内容全部填入p并清空缓冲区</li><li>当缓冲区没有内容且<code>len(p)&gt;len(buf)</code>，即要读取的内容比缓冲区还要大，直接去文件读取即可</li><li>当缓冲区没有内容且<code>len(p)&lt;len(buf)</code>，即要读取的内容比缓冲区小，读取文件内容并填满缓冲区，并将p填满</li><li>以后再次读取时，缓冲区有内容，将缓冲区内容全部填入p并清空缓冲区（和第一步一致）</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建读对象</span></span><br><span class="line">reader := bufio.NewReader(f)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读一行数据</span></span><br><span class="line">byt, _ := reader.ReadBytes(<span class="string">'\n'</span>)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(byt))</span><br></pre></td></tr></table></figure><p>ReadString() 函数也具有同样的功能，且能直接读取到字符串数据，无需转换，示例：读取大文件的全部数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">reader := bufio.NewReader(f)</span><br><span class="line"><span class="keyword">for</span> &#123;<span class="comment">// 按照缓冲区读取：读取到特定字符结束</span></span><br><span class="line">str, err := reader.ReadString(<span class="string">'\n'</span>)<span class="comment">// 按行读取</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line">fmt.Println(<span class="string">"read err: "</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"str = "</span>, str)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">fmt.Print(<span class="string">"read end"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Unix设计思想中，一切皆文件，命令行输入也可以作为文件读入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line">s, _ := reader.ReadString(<span class="string">"-"</span>)<span class="comment">// 假设命令行以 - 开始</span></span><br></pre></td></tr></table></figure><p>缓冲的思想：通过bufio，数据被写入用户缓冲，再进入系统缓冲，最后由操作系统将系统缓冲区的数据写入磁盘。  </p><h3 id="1-3-io-ioutil-包文件读取"><a href="#1-3-io-ioutil-包文件读取" class="headerlink" title="1.3 io/ioutil 包文件读取"></a>1.3 io/ioutil 包文件读取</h3><p>ioutil直接读取文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ret, err := ioutil.ReadFile(<span class="string">"test.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read err :"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(ret))</span><br></pre></td></tr></table></figure><h3 id="二-文件写入"><a href="#二-文件写入" class="headerlink" title="二 文件写入"></a>二 文件写入</h3><h3 id="2-1-直接写"><a href="#2-1-直接写" class="headerlink" title="2.1 直接写"></a>2.1 直接写</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.OpenFile(<span class="string">"test.txt"</span>, os.O_CREATE | os.O_WRONLY, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">n, err := f.Write([]<span class="keyword">byte</span>(<span class="string">"hello world"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"write err:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(n)<span class="comment">// 每次都会从头开始重新写入</span></span><br></pre></td></tr></table></figure><p>上述案例中，如果我们不想每次写入都会从头开始重新写入，那么需要将打开模式修改为：<code>os.O_CREATE | os.O_WRONLY | os.O_APPEND</code></p><h3 id="2-2-bufio的写操作"><a href="#2-2-bufio的写操作" class="headerlink" title="2.2 bufio的写操作"></a>2.2 bufio的写操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">writer := bufio.NewWriter(f)</span><br><span class="line">_, err = writer.WriteString(<span class="string">"hello world!"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"write err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">writer.Flush()<span class="comment">// 必须刷新缓冲区：将缓冲区的内容写入文件中。如果不刷新，则只会在内容超出缓冲区大小时写入</span></span><br></pre></td></tr></table></figure><h3 id="2-3-io-ioutil-包文件写入"><a href="#2-3-io-ioutil-包文件写入" class="headerlink" title="2.3  io/ioutil 包文件写入"></a>2.3  io/ioutil 包文件写入</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"你好世界"</span></span><br><span class="line">err := ioutil.WriteFile(<span class="string">"test.txt"</span>, []<span class="keyword">byte</span>(s), os.ModePerm)</span><br></pre></td></tr></table></figure><h2 id="三-文件读取偏移量"><a href="#三-文件读取偏移量" class="headerlink" title="三 文件读取偏移量"></a>三 文件读取偏移量</h2><p>文件读取时，是可以控制光标位置的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.OpenFile(<span class="string">"test.txt"</span>, os.O_RDWR, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取前五个字节，假设读取的文件内容为： hello world!</span></span><br><span class="line">bs := []<span class="keyword">byte</span>&#123;<span class="number">0</span>&#125;<span class="comment">// 创建1个字节的切片</span></span><br><span class="line">_, err = f.Read(bs)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"读到的数据是："</span>, <span class="keyword">string</span>(bs))<span class="comment">// h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动光标</span></span><br><span class="line">_, err = f.Seek(<span class="number">4</span>, io.SeekStart)<span class="comment">// 光标从开始位置(h之前)，移动4位，到达o之前</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"seek err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">_, err = f.Read(bs)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"读到的数据是："</span>, <span class="keyword">string</span>(bs))<span class="comment">// o</span></span><br></pre></td></tr></table></figure><p>通过记录光标的位置，可以实现断点续传：假设已经下载了1KB文件，即本地临时文件存储了1KB，此时断电，重启后通过本地文件大小、Seek()方法获取到上次读取文件的光标位置即可实现继续下载！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-文件读取&quot;&gt;&lt;a href=&quot;#一-文件读取&quot; class=&quot;headerlink&quot; title=&quot;一 文件读取&quot;&gt;&lt;/a&gt;一 文件读取&lt;/h2&gt;&lt;p&gt;文件读写的接口位于io包，file文件类是这些接口的实现类。&lt;/p&gt;
&lt;h3 id=&quot;1-1-直接读取-re
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>文件操作-1-写操作</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-1-%E5%86%99%E6%93%8D%E4%BD%9C/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-1-%E5%86%99%E6%93%8D%E4%BD%9C/</id>
    <published>2020-06-16T07:16:24.738Z</published>
    <updated>2020-04-21T01:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-文件的基本操作"><a href="#一-文件的基本操作" class="headerlink" title="一 文件的基本操作"></a>一 文件的基本操作</h2><h3 id="1-1-创建文件"><a href="#1-1-创建文件" class="headerlink" title="1.1 创建文件"></a>1.1 创建文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Create(<span class="string">"test.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(f)<span class="comment">// 打印文件指针</span></span><br><span class="line">f.Close()<span class="comment">// 打开的资源在不使用时必须关闭</span></span><br></pre></td></tr></table></figure><p>使用Create()创建文件时：</p><ul><li>如果文件不存在，则创建文件。</li><li>如果文件存在，则清空文件内内容。  </li><li>Create创建的文件任何人都可以读写。 </li></ul><h3 id="1-2-打开文件，写入内容"><a href="#1-2-打开文件，写入内容" class="headerlink" title="1.2 打开文件，写入内容"></a>1.2 打开文件，写入内容</h3><p>打开文件有两种方式：</p><ul><li>Open()：以只读的方式打开文件，若文件不存在则会打开失败</li><li>OpenFile()：打开文件时，可以传入打开方式，该函数的三个参数：<ul><li>参数1：要打开的文件路径</li><li>参数2：文件打开模式，如 <code>O_RDONLY</code>，<code>O_WRONGLY</code>，<code>O_RDWR</code>，还可以通过管道符来指定文件不存在时创建文件</li><li>参数3：文件创建时候的权限级别，在0-7之间，常用参数为6</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.OpenFile(<span class="string">"test.txt"</span>, os.O_APPEND | os.O_RDWR, os.ModeAppend)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">f.Close()</span><br></pre></td></tr></table></figure><p>常用的文件打开模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">O_RDONLY <span class="keyword">int</span> = syscall.O_RDONLY<span class="comment">// 只读</span></span><br><span class="line">O_WRONGLY<span class="keyword">int</span> = syscall.O_WRONGLY<span class="comment">// 只写</span></span><br><span class="line">O_RDWR <span class="keyword">int</span> = syscall.O_RDWR<span class="comment">// 读写</span></span><br><span class="line">O_APPEND <span class="keyword">int</span> = syscall.O_APPEND<span class="comment">// 写操作时将数据追加到文件末尾</span></span><br><span class="line">O_CREATE <span class="keyword">int</span> = syscall.O_CREATE<span class="comment">// 如果不存在则创建一个新文件</span></span><br><span class="line">O_EXCL <span class="keyword">int</span> = syscall.O_EXCL<span class="comment">// 打开文件用于同步I/O</span></span><br><span class="line">O_TRUNC<span class="keyword">int</span> = syscall.O_TRUNC<span class="comment">// 如果可能，打开时清空文件</span></span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 1.3 写文件</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">写入字节 `</span>Write()<span class="string">`：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="comment">// 写入文件内容</span></span><br><span class="line">n, err := f.Write([]<span class="keyword">byte</span>(<span class="string">"hello"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"write err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"write number = "</span>, n)</span><br></pre></td></tr></table></figure><p>按字符串写 <code>WriteString()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入文件内容</span></span><br><span class="line">n, err := f.WriteString([<span class="string">"hello"</span>)<span class="comment">// 会将前5个字符替换为 hello</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"write err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"write number = "</span>, n)</span><br></pre></td></tr></table></figure><p>修改文件的读写指针位置 <code>Seek()</code>，包含两个参数：</p><ul><li>参数1：偏移量，为正数时向文件尾偏移，为负数时向文件头偏移</li><li>参数2：偏移的开始位置，包括：<ul><li>io.SeekStart：从文件起始位置开始</li><li>io.SeekCurrent：从文件当前位置开始</li><li>io.SeekEnd：从文件末尾位置开始</li></ul></li></ul><p><code>Seek()</code>函数返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f, _ := os.OpenFile(<span class="string">"test.txt"</span>,os.O_RDWR, <span class="number">6</span>)</span><br><span class="line">off, _ := f.Seek(<span class="number">5</span>, io.SeekStart)</span><br><span class="line">fmt.Println(off)<span class="comment">// 5</span></span><br><span class="line">n, _ := f.WriteAt([]<span class="keyword">byte</span>(<span class="string">"111"</span>), off)</span><br><span class="line">fmt.Println(n)</span><br><span class="line">f.Close()</span><br></pre></td></tr></table></figure><h3 id="1-4-获取文件描述信息-os-Stat"><a href="#1-4-获取文件描述信息-os-Stat" class="headerlink" title="1.4 获取文件描述信息 os.Stat()"></a>1.4 获取文件描述信息 os.Stat()</h3><p>Go的os包中定义了file类，封装了文件描述信息，同时也提供了Read、Write的实现。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fileInfo, err := os.Stat(<span class="string">"./test.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"stat err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, fileInfo)<span class="comment">// *os.fileStat</span></span><br></pre></td></tr></table></figure><p>获取到的fileInfo内部包含 <code>文件名Name()</code>、<code>大小Size()</code>、<code>是否是目录IsDir()</code> 等操作。  </p><h3 id="1-5-路径、目录操作"><a href="#1-5-路径、目录操作" class="headerlink" title="1.5 路径、目录操作"></a>1.5 路径、目录操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径操作</span></span><br><span class="line">fmt.Println(filepath.IsAbs(<span class="string">"./test.txt"</span>))<span class="comment">// false：判断是否是绝对路径</span></span><br><span class="line">fmt.Println(filepath.Abs(<span class="string">"./test.txt"</span>))<span class="comment">// 转换为绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建目录</span></span><br><span class="line">err := os.Mkdir(<span class="string">"./test"</span>, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"mkdir err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多级目录</span></span><br><span class="line">err = os.MkdirAll(<span class="string">"./dd/rr"</span>, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"mkdirAll err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">贴士：Openfile()可以用于打开目录。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 1.6 删除文件</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line">err := os.Remove(<span class="string">"test.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"remove err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数也可用于删除目录（只能删除空目录）。如果要删除非空目录，需要使用 <code>RemoveAll()</code> 函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-文件的基本操作&quot;&gt;&lt;a href=&quot;#一-文件的基本操作&quot; class=&quot;headerlink&quot; title=&quot;一 文件的基本操作&quot;&gt;&lt;/a&gt;一 文件的基本操作&lt;/h2&gt;&lt;h3 id=&quot;1-1-创建文件&quot;&gt;&lt;a href=&quot;#1-1-创建文件&quot; class=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>接口类型-2-断言与多态</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B-2-%E6%96%AD%E8%A8%80%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B-2-%E6%96%AD%E8%A8%80%E4%B8%8E%E5%A4%9A%E6%80%81/</id>
    <published>2020-06-16T07:16:24.737Z</published>
    <updated>2020-04-21T01:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-断言"><a href="#一-断言" class="headerlink" title="一 断言"></a>一 断言</h2><p>接口是编程的规范，他也可以作为函数的参数，以让函数更具备适用性。在下列示例中，有三个接口动物接口、飞翔接口、游泳接口，两个实现类鸟类与鱼类：</p><ul><li>鸟类：实现了动物接口，飞翔接口</li><li>鱼类：实现了动物接口，游泳接口</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个通用接口：动物接口</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">Breath()<span class="comment">// 动物都具备 呼吸方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Flyer <span class="keyword">interface</span> &#123;</span><br><span class="line">Fly()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Swimer <span class="keyword">interface</span> &#123;</span><br><span class="line">Swim()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个鸟类：其呼吸的方式是在陆地</span></span><br><span class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Food <span class="keyword">string</span></span><br><span class="line">Kind <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bird)</span> <span class="title">Breath</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"鸟 在 陆地 呼吸"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bird)</span> <span class="title">Fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s 在 飞\n"</span>, b.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一定一个鱼类：其呼吸方式是在水下</span></span><br><span class="line"><span class="keyword">type</span> Fish <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Kind <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fish)</span> <span class="title">Breath</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"鱼 在 水下 呼吸"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fish)</span> <span class="title">Swim</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s 在游泳\n"</span>, f.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个普通函数，参数是动物接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Display</span><span class="params">(a Animal)</span></span> &#123;</span><br><span class="line"><span class="comment">// 直接调用接口中的方法</span></span><br><span class="line">a.Breath()</span><br><span class="line"><span class="comment">// 调用实现类的成员：此时会报错</span></span><br><span class="line">fmt.Println(a.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b = &amp;Bird&#123;</span><br><span class="line"><span class="string">"斑鸠"</span>,</span><br><span class="line"><span class="string">"蚂蚱"</span>,</span><br><span class="line"><span class="string">"鸟类"</span></span><br><span class="line">&#125;</span><br><span class="line">Display(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口类型无法直接访问其具体实现类的成员，需要使用断言（type assertions），对接口的类型进行判断，类型断言格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := i.(T)<span class="comment">//不安全写法：如果i没有完全实现T接口的方法，这个语句将会触发宕机</span></span><br><span class="line">t, ok := i.(T)<span class="comment">// 安全写法：如果接口未实现接口，将会把ok掷为false，t掷为T类型的0值</span></span><br></pre></td></tr></table></figure><ul><li>i代表接口变量</li><li>T代表转换的目标类型</li><li>t代表转换后的变量</li></ul><p>上述案例的Dsiplay就可以书写为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Display</span><span class="params">(a Animal)</span></span> &#123;</span><br><span class="line"><span class="comment">// 直接调用接口中的方法</span></span><br><span class="line">a.Breath()</span><br><span class="line"><span class="comment">// 调用实现类的成员：此时会报错</span></span><br><span class="line">instance, ok := a.(*Bird)<span class="comment">// 注意：这里必须是 *Bird类型，因为是*Bird实现了接口，不是Bird实现了接口</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="comment">// 得到了具体的实现类，才能访问实现类的成员</span></span><br><span class="line">fmt.Println(<span class="string">"该鸟类的名字是："</span>, instance.Name)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"该动物不是鸟类"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-接口类型转换"><a href="#二-接口类型转换" class="headerlink" title="二 接口类型转换"></a>二 接口类型转换</h2><p>在接口定义时，其类型已经确定，因为接口的本质是方法签名的集合，如果两个接口的方法签名结合相同（顺序可以不同），则这2个接口之间不需要强制类型转换就可以相互赋值，因为go编译器在校验接口是否能赋值时，比较的是二者的方法集。  </p><p>在上一节中，函数Display接收的是Animal接口类型，在断言后转换为了别的类型：*Bird(实现类指针类型)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Display</span><span class="params">(a Animal)</span></span> &#123;</span><br><span class="line">instance, ok := a.(*Bird)<span class="comment">// 动物接口转换为了 *Bird实现类</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="comment">// 得到了具体的实现类，才能访问实现类的成员</span></span><br><span class="line">fmt.Println(<span class="string">"该鸟类的名字是："</span>, instance.Name)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"该动物不是鸟类"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，断言还可以将接口转换成另外一个接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Display</span><span class="params">(a Animal)</span></span> &#123;</span><br><span class="line">instance, ok := a.(Flyer)<span class="comment">// 动物接口转换为了飞翔接口</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">instance.Fly()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"该动物不会飞"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个实现类往往实现了很多接口，为了精准类型查询，可以使用switch语句来判断对象类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 interfaceP&#123;&#125; = ...</span><br><span class="line"><span class="keyword">switch</span> v := v1.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-多态"><a href="#三-多态" class="headerlink" title="三 多态"></a>三 多态</h2><p>多态是面向对象的三大特性之一，即一个类型具备多种具体的表现形式。  </p><p>上述示例中，鸟和鱼都实现了动物接口的 Breath方法，即动物的Breath方法在鸟和鱼中具备不同的体现。我们在new出动物的具体对象实例时，这个对象实例也就实现了对应自己的接口方法。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New出Animal的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAnimal</span><span class="params">(kind <span class="keyword">string</span>)</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> kind &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"鸟类"</span>:</span><br><span class="line"><span class="keyword">return</span> &amp;Bird&#123;&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"鱼类"</span>:</span><br><span class="line"><span class="keyword">return</span> &amp;Fish&#123;&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取的是动物接口类型，但是实现类是鸟类</span></span><br><span class="line">a1 := NewAnimal(<span class="string">"鸟类"</span>)</span><br><span class="line">a1.Breath()<span class="comment">// 鸟 在 陆地 呼吸</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取的是动物接口类型，但是实现类是鱼类</span></span><br><span class="line">a2 := NewAnimal(<span class="string">"鱼类"</span>)</span><br><span class="line">a2.Breath()<span class="comment">// 鱼 在 水下 呼吸</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-断言&quot;&gt;&lt;a href=&quot;#一-断言&quot; class=&quot;headerlink&quot; title=&quot;一 断言&quot;&gt;&lt;/a&gt;一 断言&lt;/h2&gt;&lt;p&gt;接口是编程的规范，他也可以作为函数的参数，以让函数更具备适用性。在下列示例中，有三个接口动物接口、飞翔接口、游泳接口，两个实
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>接口类型-1-接口的使用</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B-1-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B-1-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-16T07:16:24.735Z</published>
    <updated>2020-04-21T01:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-接口-interface"><a href="#一-接口-interface" class="headerlink" title="一 接口 interface"></a>一 接口 interface</h2><p>接口（interface）是调用方和实现方均需要遵守的一种约束，约束开发者按照统一的方法命名、参数类型、数量来处理具体业务。实际上，接口就是一组没有实现的方法声明，到某个自定义类型要使用该方法时，根据具体情况把这些方法实现出来。接口语法：  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span> &#123;</span><br><span class="line">方法名<span class="number">1</span>(参数列表) 返回值列表</span><br><span class="line">方法名<span class="number">2</span>(参数列表) 返回值列表</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运输方式</span></span><br><span class="line"><span class="keyword">type</span> Transporter <span class="keyword">interface</span> &#123;</span><br><span class="line">BicycleTran()</span><br><span class="line">CarTran()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驾驶员</span></span><br><span class="line"><span class="keyword">type</span> Driver <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现运输方式接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">BicycleTran</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"使用自行车运输"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">CarTran</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"使用小汽车运输"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d := &amp;Driver&#123;</span><br><span class="line"><span class="string">"张三"</span>,</span><br><span class="line"><span class="number">27</span>,</span><br><span class="line">&#125;</span><br><span class="line">trans(d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要实现了 Transporter接口的类型都可以作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trans</span><span class="params">(t Transporter)</span></span> &#123;</span><br><span class="line">t.BicycleTran()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>Go语言的接口在命名时，一般会在单词后面添加er，如写操作的接口叫做Writer</li><li>当方法名首字母大写，且实现的接口首字母也是大写，则该方法可以被接口所在包之外的代码访问</li><li>方法与接口中的方法签名一致（方法名、参数列表、返回列表都必须一致）</li><li>参数列表和返回值列表中的变量名可以被忽略，如：type writer interfae{ Write([]byte) error}</li><li>接口中所有的方法都必须被实现</li><li>如果编译时发现实现接口的方法签名不一致，则会报错：<code>does not implement</code>。  </li></ul><h2 id="二-Go接口的特点"><a href="#二-Go接口的特点" class="headerlink" title="二 Go接口的特点"></a>二 Go接口的特点</h2><p>在上述示例中，Go无须像Java那样显式声明实现了哪个接口，即为非侵入式，接口编写者无需知道接口被哪些类型实现，接口实现者只需要知道实现的是什么样子的接口，但无需指明实现了哪个接口。编译器知道最终编译时使用哪个类型实现哪个接口，或者接口应该由谁来实现。  </p><p>类型和接口之间有一对多和多对一的关系，即：</p><ul><li>一个类型可以实现多个接口，接口间是彼此独立的，互相不知道对方的实现</li><li>多个类型也可以实现相同的接口。   </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;</span><br><span class="line">Start()</span><br><span class="line">Log(<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志器</span></span><br><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//日志输出方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Logger)</span> <span class="title">Log</span><span class="params">(s <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"日志："</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏服务</span></span><br><span class="line"><span class="keyword">type</span> GameService <span class="keyword">struct</span> &#123;</span><br><span class="line">Logger</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现游戏服务的Start方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GameService)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"游戏服务启动"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">new</span>(GameService)</span><br><span class="line">s.Start()</span><br><span class="line">s.Log(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述案例中，即使没有接口也能运行，但是当存在接口时，会隐式实现接口，让接口给类提供约束。</p><p>使用接口调用了结构体中的方法，也可以理解为实现了面向对象中的多态。  </p><h2 id="三-接口嵌套"><a href="#三-接口嵌套" class="headerlink" title="三 接口嵌套"></a>三 接口嵌套</h2><p>Go中不仅结构体之间可以嵌套，接口之间也可以嵌套。接口与接口嵌套形成了新的接口，只要接口的所有方法被实现，则这个接口中所有嵌套接口的方法均可以被调用。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个 写 接口</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, e error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 读 接口</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">Read() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 嵌套接口</span></span><br><span class="line"><span class="keyword">type</span> IO <span class="keyword">interface</span> &#123;</span><br><span class="line">Writer</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-空接口"><a href="#四-空接口" class="headerlink" title="四 空接口"></a>四 空接口</h2><h4 id="4-1-空接口定义"><a href="#4-1-空接口定义" class="headerlink" title="4.1 空接口定义"></a>4.1 空接口定义</h4><p>空接口是接口的特殊形式，没有任何方法，因此任何具体的类型都可以认为实现了空接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">any = <span class="number">1</span></span><br><span class="line">fmt.Println(any)</span><br><span class="line"></span><br><span class="line">any = <span class="string">"hello"</span></span><br><span class="line">fmt.Println(any)</span><br></pre></td></tr></table></figure><p>空接口作为函数参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Test(<span class="number">3</span>)<span class="comment">// int</span></span><br><span class="line">Test(<span class="string">"hello"</span>)<span class="comment">// sting</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用空接口，可以实现任意类型的存储：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">m[<span class="string">"name"</span>] = <span class="string">"李四"</span></span><br><span class="line">m[<span class="string">"age"</span>] = <span class="number">30</span></span><br></pre></td></tr></table></figure><h4 id="4-2-从空接口获取值"><a href="#4-2-从空接口获取值" class="headerlink" title="4.2 从空接口获取值"></a>4.2 从空接口获取值</h4><p>保存到空接口的值，如果直接取出指定类型的值时，会发生编译错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = a</span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = i<span class="comment">//这里编译报错（类型不一致），可以这样做：b := i</span></span><br></pre></td></tr></table></figure><h4 id="4-3-空接口值比较"><a href="#4-3-空接口值比较" class="headerlink" title="4.3 空接口值比较"></a>4.3 空接口值比较</h4><p>类型不同的空接口比较：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = <span class="string">"hi"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a == b)<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>不能比较空接口中的动态值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c <span class="keyword">interface</span>&#123;&#125; = []<span class="keyword">int</span>&#123;<span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">interface</span>&#123;&#125; = []<span class="keyword">int</span>&#123;<span class="number">20</span>&#125;</span><br><span class="line">fmt.Println(c == d)<span class="comment">//运行报错</span></span><br></pre></td></tr></table></figure><p>空接口的类型和可比较性：</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>map</td><td>不可比较，会发生宕机错误</td></tr><tr><td>切片</td><td>不可比较，会发生宕机错误</td></tr><tr><td>通道</td><td>可比较，必须由同一个make生成，即同一个通道才是true</td></tr><tr><td>数组</td><td>可比较，编译期即可知道是否一致</td></tr><tr><td>结构体</td><td>可比较，可诸葛比较结构体的值</td></tr><tr><td>函数</td><td>可比较</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-接口-interface&quot;&gt;&lt;a href=&quot;#一-接口-interface&quot; class=&quot;headerlink&quot; title=&quot;一 接口 interface&quot;&gt;&lt;/a&gt;一 接口 interface&lt;/h2&gt;&lt;p&gt;接口（interface）是调用方和实现方均
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>面向对象-2-三大特性</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-2-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-2-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</id>
    <published>2020-06-16T07:16:24.733Z</published>
    <updated>2020-04-21T01:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-面向对象三大特性"><a href="#一-面向对象三大特性" class="headerlink" title="一 面向对象三大特性"></a>一 面向对象三大特性</h2><h4 id="1-1-封装"><a href="#1-1-封装" class="headerlink" title="1.1 封装"></a>1.1 封装</h4><p>封装：把抽象出的字段和对字段的操作封装在一起,数据被保护在内部,程序的其它包只有通过被授权的操作(方法),才能对字段进行修改，其作用有：</p><ul><li>隐藏实现细节</li><li>可以对数据进行验证，保证安全合理  </li></ul><p>Golang对面向对象做了极大简化，并不强调封装特性，下列示例进行模拟实现：</p><p>在<code>person</code>包下新建<code>person.go</code>文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> person</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span><span class="comment">//年龄是隐私，不允许其他包访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂函数（类似构造函数）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">person</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">Name: name,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">SetAge</span><span class="params">(age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> age &gt; <span class="number">0</span> &amp;&amp; age &lt; <span class="number">150</span> &#123;<span class="comment">//校验</span></span><br><span class="line">p.age = age</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"年龄不合法"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">GetAge</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> p.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.go</code>文件操作person：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"demo/person"</span><span class="comment">// demo是go mod模式下，整体项目名</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := person.NewPerson(<span class="string">"Tom"</span>)</span><br><span class="line">p.SetAge(<span class="number">18</span>)</span><br><span class="line">fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-继承"><a href="#1-2-继承" class="headerlink" title="1.2 继承"></a>1.2 继承</h4><p>在 Golang 中，如果一个 struct 嵌套了另一个匿名结构体，那么这个结构体可以直接访 问匿名结构体的字段和方法，从而实现了继承特性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Father <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Father)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f.Name + <span class="string">" like running..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Son <span class="keyword">struct</span> &#123;</span><br><span class="line">Father              <span class="comment">//嵌套匿名结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s Son</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.Father.Name = "Tom"</span></span><br><span class="line"><span class="comment">//s.Father.age = 10     //可以访问未导出属性</span></span><br><span class="line"><span class="comment">//s.Father.run()          //可以访问未导出方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上述可以简写为：</span></span><br><span class="line">s.Name = <span class="string">"Tom"</span></span><br><span class="line">s.age = <span class="number">10</span></span><br><span class="line">s.run()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>当结构体和匿名结构体有相同的字段或者方法时，编译器采用就近访问原则访问，如果希望访问匿名结构体的字段和方法，可以通过匿名结构体名来区分。</li><li>结构体嵌入多个匿名结构体，如果两个匿名结构体有相同的字段和方法(同时结构体本身没有同名的字段和方法)，访问时必须明确指定匿名结构体名字，否则编译报错。</li><li>如果一个 struct 嵌套了一个有名结构体，这种模式就是组合，如果是组合关系，那么在访问组合的结构体的字段或方法时，必须带上结构体的名字。  </li></ul><p>关于多重继承：如果一个 struct 嵌套了多个匿名结构体，那么该结构体可以直接访问嵌套的匿名结构体的字段和方法，从而实现多重继承。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Father1 <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Father1)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f.Name + <span class="string">" like running..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Father2 <span class="keyword">struct</span> &#123;</span><br><span class="line">Like <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Son1 <span class="keyword">struct</span> &#123;</span><br><span class="line">Father1</span><br><span class="line">Father2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Son2 <span class="keyword">struct</span> &#123;</span><br><span class="line">*Father1</span><br><span class="line">*Father2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s1 := &amp;Son1 &#123;</span><br><span class="line">Father1&#123;</span><br><span class="line">Name: <span class="string">"Tom"</span>,</span><br><span class="line">age: <span class="number">10</span>,</span><br><span class="line">&#125;,</span><br><span class="line">Father2&#123;</span><br><span class="line">Like: <span class="string">"伏特加"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(s1)</span><br><span class="line"></span><br><span class="line">s2 := &amp;Son2&#123;</span><br><span class="line">&amp;Father1&#123;</span><br><span class="line">Name: <span class="string">"Tom"</span>,</span><br><span class="line">age: <span class="number">10</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&amp;Father2&#123;</span><br><span class="line"> Like: <span class="string">"伏特加"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s2.Father1)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#123;&#123;Tom 10&#125; &#123;伏特加&#125;&#125;</span><br><span class="line">&amp;&#123;Tom 10&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-多态"><a href="#1-3-多态" class="headerlink" title="1.3 多态"></a>1.3 多态</h4><p>多态与接口（interface）有关联，参见接口章节</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-面向对象三大特性&quot;&gt;&lt;a href=&quot;#一-面向对象三大特性&quot; class=&quot;headerlink&quot; title=&quot;一 面向对象三大特性&quot;&gt;&lt;/a&gt;一 面向对象三大特性&lt;/h2&gt;&lt;h4 id=&quot;1-1-封装&quot;&gt;&lt;a href=&quot;#1-1-封装&quot; class=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>面向对象-1-构造函数与方法</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95/</id>
    <published>2020-06-16T07:16:24.732Z</published>
    <updated>2020-04-21T01:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-面向对象初识"><a href="#一-面向对象初识" class="headerlink" title="一 面向对象初识"></a>一 面向对象初识</h2><h4 id="1-1-模拟构造函数"><a href="#1-1-模拟构造函数" class="headerlink" title="1.1 模拟构造函数"></a>1.1 模拟构造函数</h4><p>Go和传统的面向对象语言如Java有着很大区别。结构体没有构造函数初始化功能，可以通过以下方式模拟：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPersonByName</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">Name: name,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPersonByAge</span><span class="params">(age <span class="keyword">int</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">Age: age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">p := NewPersonByName(<span class="string">"zs"</span>)</span><br><span class="line">fmt.Println(p)<span class="comment">// &#123;zs 0&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贴士：因为Go没有函数重载，为了避免函数名字冲突，使用了<code>NewPersonByName</code>和<code>NewPersonByAge</code>两个不同的函数表示不同的<code>Person</code>构造过程。</p><h4 id="1-2-父子关系结构体初始化"><a href="#1-2-父子关系结构体初始化" class="headerlink" title="1.2 父子关系结构体初始化"></a>1.2 父子关系结构体初始化</h4><p>Person可以看做父类，Student是子类，子类需要继承父类的成员：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Person</span><br><span class="line">ClassName <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造父类</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">Name: name,</span><br><span class="line">Age: age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造子类</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(classname <span class="keyword">string</span>)</span> *<span class="title">Student</span></span> &#123;</span><br><span class="line">p := &amp;Student&#123;&#125;</span><br><span class="line">p.ClassName = classname</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s := NewStudent(<span class="string">"一班"</span>)</span><br><span class="line">fmt.Println(s)<span class="comment">// &amp;&#123;&#123; 0&#125; 一班&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-Go中的面向对象初识"><a href="#1-3-Go中的面向对象初识" class="headerlink" title="1.3 Go中的面向对象初识"></a>1.3 Go中的面向对象初识</h4><p>在Go中，可以给任意类型（除了指针）添加相应方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interger <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Interger)</span> <span class="title">Less</span> <span class="params">(j Interger)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> i &lt; j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i Interger = <span class="number">1</span></span><br><span class="line">fmt.Print(i.Less(<span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-方法"><a href="#二-方法" class="headerlink" title="二 方法"></a>二 方法</h2><h4 id="2-1-方法"><a href="#2-1-方法" class="headerlink" title="2.1 方法"></a>2.1 方法</h4><p>Golang 中的方法是作用在指定的数据类型上的(即:和指定的数据类型绑定)，因此自定义类型，都可以有方法，而不仅仅是 struct。  </p><p>方法的声明和调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recevier <span class="keyword">type</span>)</span> <span class="title">methodName</span><span class="params">(参数列表)</span> <span class="params">(返回值列表)</span></span>&#123; </span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法与函数的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个run函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(p *Person, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">p.Name = name</span><br><span class="line">fmt.Println(<span class="string">"函数 run..."</span>, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个run方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span><span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"方法 run..."</span>, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个对象（结构体）</span></span><br><span class="line">p1 := &amp;Person&#123;</span><br><span class="line"><span class="string">"ruyue"</span>,</span><br><span class="line"><span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行一个普通方法</span></span><br><span class="line">run(p1, <span class="string">"张三"</span>)<span class="comment">// 输出 函数 run... 张三</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行方法</span></span><br><span class="line">p1.run()<span class="comment">// 输出 方法 run... 张三</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-Go方法本质"><a href="#2-2-Go方法本质" class="headerlink" title="2.2 Go方法本质"></a>2.2 Go方法本质</h4><p>Go的方法是一种作用于特定类型变量的函数，这种特定类型的变量叫做接收器（Receiver）。如果特定类型理解为结构体或者“类”时，接收器就类似于其他语言的this或者self。  </p><p>在Go中，接收器可以是任何类型，不仅仅是结构体，依此我们看出，Go中的方法和其他语言的方法类似，但是Go语言的接收器强调方法的作用对象是实例。</p><p>方法与函数的区别就是：函数没有作用对象。</p><p>上述Person案例中，接收器类型是<code>*Person</code>，属于指针类型，非常接近Java中的<code>this</code>，由于指针的特性，调用方法时，修改接收器指针的任意长远变量，在方法结束后，修改都是有效的。  </p><p>当方法作用于非指针接收器时，Go语言会在代码运行时将接收器的值复制一份，在非指针接收器的方法中可以获取接收器的成员值，但修改后无效，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个表示点的结构体</span></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="keyword">int</span></span><br><span class="line">Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非指针接收器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">Add</span><span class="params">(otherP Point)</span> <span class="title">Point</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Point&#123;</span><br><span class="line">p.X + otherP.X,</span><br><span class="line">p.Y + otherP.Y,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">p1 := Point&#123;<span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">p2 := Point&#123;<span class="number">2</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">result := p1.Add(p2)</span><br><span class="line"></span><br><span class="line">fmt.Println(result)<span class="comment">// &#123;3 3&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，小对象由于复制时速度较快，适合使用非指针接收器，大对象因为复制性能较低，适合使用指针接收器，此时再接收器和参数之间传递时不进行复制，只传递指针。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-面向对象初识&quot;&gt;&lt;a href=&quot;#一-面向对象初识&quot; class=&quot;headerlink&quot; title=&quot;一 面向对象初识&quot;&gt;&lt;/a&gt;一 面向对象初识&lt;/h2&gt;&lt;h4 id=&quot;1-1-模拟构造函数&quot;&gt;&lt;a href=&quot;#1-1-模拟构造函数&quot; class=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>函数-2-闭包</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%87%BD%E6%95%B0-2-%E9%97%AD%E5%8C%85/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%87%BD%E6%95%B0-2-%E9%97%AD%E5%8C%85/</id>
    <published>2020-06-16T07:16:24.731Z</published>
    <updated>2020-04-21T01:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-闭包"><a href="#一-闭包" class="headerlink" title="一 闭包"></a>一 闭包</h2><h4 id="1-1-闭包概念"><a href="#1-1-闭包概念" class="headerlink" title="1.1 闭包概念"></a>1.1 闭包概念</h4><p>闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使己经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量。  </p><p>简单的说 : 函数+引用环境=闭包  </p><p>贴士：闭包( Closure)在某些编程语言中也被称为 Lambda表达式（如Java）</p><p>在闭包中可以修改引用的变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello"</span></span><br><span class="line">foo := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;<span class="comment">// 声明一个匿名函数</span></span><br><span class="line">str = <span class="string">"world"</span></span><br><span class="line">&#125;</span><br><span class="line">foo()<span class="comment">//  调用匿名函数，修改str值</span></span><br><span class="line">fmt.Print(str)<span class="comment">// world</span></span><br></pre></td></tr></table></figure><h4 id="1-2-闭包案例一-简单示例"><a href="#1-2-闭包案例一-简单示例" class="headerlink" title="1.2 闭包案例一  简单示例"></a>1.2 闭包案例一  简单示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn1</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="built_in">print</span>(&amp;a, a)</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">f := fn1(<span class="number">1</span>)<span class="comment">//输出地址</span></span><br><span class="line">g := fn1(<span class="number">2</span>)<span class="comment">//输出地址</span></span><br><span class="line"></span><br><span class="line">fmt.Println(f(<span class="number">1</span>))<span class="comment">//输出1</span></span><br><span class="line">fmt.Println(f(<span class="number">1</span>))<span class="comment">//输出1</span></span><br><span class="line"></span><br><span class="line">fmt.Println(g(<span class="number">2</span>))<span class="comment">//输出2</span></span><br><span class="line">fmt.Println(g(<span class="number">2</span>))<span class="comment">//输出2</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-闭包案例二-实现累加器"><a href="#1-3-闭包案例二-实现累加器" class="headerlink" title="1.3 闭包案例二 实现累加器"></a>1.3 闭包案例二 实现累加器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Accumulate</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;<span class="comment">// 返回一个闭包</span></span><br><span class="line">value++</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">accAdd := Accumulate(<span class="number">1</span>)</span><br><span class="line">fmt.Println(accAdd())<span class="comment">// 2</span></span><br><span class="line">fmt.Println(accAdd())<span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-闭包&quot;&gt;&lt;a href=&quot;#一-闭包&quot; class=&quot;headerlink&quot; title=&quot;一 闭包&quot;&gt;&lt;/a&gt;一 闭包&lt;/h2&gt;&lt;h4 id=&quot;1-1-闭包概念&quot;&gt;&lt;a href=&quot;#1-1-闭包概念&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>函数-1-函数简介</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%87%BD%E6%95%B0-1-%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%87%BD%E6%95%B0-1-%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B/</id>
    <published>2020-06-16T07:16:24.729Z</published>
    <updated>2020-04-21T01:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-函数"><a href="#一-函数" class="headerlink" title="一 函数"></a>一 函数</h2><h4 id="1-1-函数声明"><a href="#1-1-函数声明" class="headerlink" title="1.1 函数声明"></a>1.1 函数声明</h4><p>函数声明格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名字 <span class="params">(参数列表)</span> <span class="params">(返回值列表）&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">// 函数体</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">return</span> 返回值列表</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>函数名首字母小写为私有，大写为公有；</li><li>参数列表可以有0-多个，多参数使用逗号分隔，不支持默认参数；</li><li>返回值列表返回值类型可以不用写变量名</li><li>如果只有一个返回值且不声明类型，可以省略返回值列表与括号</li><li>如果有返回值，函数内必须有return</li></ul><p>Go中函数常见写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无返回值，默认返回0，所以也可以写为 func fn() int &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn</span><span class="params">()</span></span>&#123;&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Go推荐给函数返回值起一个变量名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn1</span><span class="params">()</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种返回值写法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn2</span><span class="params">()</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">result = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多返回值情</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn3</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Go返回值推荐多返回值写法：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn4</span><span class="params">()</span> <span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>, c <span class="keyword">int</span>)</span></span> &#123;多个参数类型如果相同，可以简写为： a,b <span class="keyword">int</span></span><br><span class="line">   a , b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">   <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-值传递和引用传递"><a href="#1-2-值传递和引用传递" class="headerlink" title="1.2 值传递和引用传递"></a>1.2 值传递和引用传递</h4><p>不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝决定拷贝的 数据大小，数据越大，效率越低。  </p><p>如果希望函数内的变量能修改函数外的变量，可以传入变量的地址&amp;，函数内以指针的方式操作变量。</p><h4 id="1-3-可变参数"><a href="#1-3-可变参数" class="headerlink" title="1.3 可变参数"></a>1.3 可变参数</h4><p>可变参数变量是一个包含所有参数的切片。如果要在多个可变参数中传递参数 ，可以在传递时在可变参数变量中默认添 加“ …”，将切片中的元素进行传递，而不是传递可变参数变量本身。</p><p>示例：对可变参数列表进行遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">joinStrings</span><span class="params">(slist ...<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> slist &#123;</span><br><span class="line">buf.WriteString(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(joinStrings(<span class="string">"pig"</span>, <span class="string">" and"</span>, <span class="string">" bird"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：参数传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际打印函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rawPrint</span><span class="params">(rawList ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> rawList &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装打印函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(slist ...<span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line"><span class="comment">// 将slist可变参数切片完整传递给下一个函数</span></span><br><span class="line">rawPrint(slist...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-匿名函数"><a href="#1-4-匿名函数" class="headerlink" title="1.4 匿名函数"></a>1.4 匿名函数</h4><p>匿名函数可以看做函数字面量，所有直接使用函数类型变量的地方都可以由匿名函数代替。匿名函数可以直接赋值给函数变量，可以当做实参，也可以作为返回值使用，还可以直接被调用。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">   a := <span class="number">3</span></span><br><span class="line">   f1 := <span class="function"><span class="keyword">func</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;    <span class="comment">// f1 即为匿名函数</span></span><br><span class="line">      fmt.Println(num) <span class="comment">// 匿名函数访问外部变量</span></span><br><span class="line">   &#125;</span><br><span class="line">   f1(a)</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;         <span class="comment">// 匿名函数自调</span></span><br><span class="line">      fmt.Println(a)</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名函数实战：取最大值,最小值</span></span><br><span class="line">x, y := <span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="params">(max,min <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> i &gt; j &#123;</span><br><span class="line">      max = i</span><br><span class="line">      min = j</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      max = j</span><br><span class="line">      min = i</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">fmt.Println(x + <span class="string">' '</span> + y)</span><br></pre></td></tr></table></figure><h4 id="1-5-函数类型"><a href="#1-5-函数类型" class="headerlink" title="1.5 函数类型"></a>1.5 函数类型</h4><p>函数去掉函数名、参数名和{}后的结果即是函数类型，可以使用%T打印该结果。  </p><p>两个函数类型相同的前提是：拥有相同的形参列表和返回值列表，且列表元素的次序、类型都相同，形参名可以不同。  </p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mathSum</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mathSub</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个函数类型</span></span><br><span class="line"><span class="keyword">type</span> MyMath <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义的函数类型作为参数使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(f MyMath, a , b <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> f(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常可以把函数类型当做一种引用类型，实际函数类型变量和函数名都可以当做指针变量，只想函数代码开始的位置，没有初始化的函数默认值是nil。</p><h2 id="二-Go函数特性总结"><a href="#二-Go函数特性总结" class="headerlink" title="二 Go函数特性总结"></a>二 Go函数特性总结</h2><ul><li>支持有名称的返回值；</li><li>不支持默认值参数；</li><li>不支持重载；</li><li>不支持命名函数嵌套，匿名函数可以嵌套；</li><li>Go函数从实参到形参的传递永远是值拷贝，有时函数调用后实参指向的值发生了变化，是因为参数传递的是指针的拷贝，实参是一个指针变量，传递给形参的是这个指针变量的副本，实质上仍然是值拷贝；</li><li>Go函数支持不定参数；</li></ul><h2 id="三-两个特殊函数"><a href="#三-两个特殊函数" class="headerlink" title="三 两个特殊函数"></a>三 两个特殊函数</h2><h4 id="3-1-init函数"><a href="#3-1-init函数" class="headerlink" title="3.1 init函数"></a>3.1 init函数</h4><p>Go语言中，除了可以在全局声明中初始化实体，也可以在init函数中初始化。init函数是一个特殊的函数，它会在包完成初始化后自动执行，执行优先级高于main函数，并且不能手动调用init函数，每一个文件有且仅有一个init函数，初始化过程会根据包的以来关系顺序单线程执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//在这里可以书写一些初始化操作</span></span><br><span class="line">fmt.Println(<span class="string">"init..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"main..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-new函数"><a href="#3-2-new函数" class="headerlink" title="3.2 new函数"></a>3.2 new函数</h4><p>new函数可以用来创建变量。表达式<code>new(T)</code>将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为<code>*T</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="keyword">int</span>)<span class="comment">// p 为 *int类型，只想匿名的int变量</span></span><br><span class="line">fmt.Println(*p)<span class="comment">// "0"</span></span><br><span class="line">*p = <span class="number">2</span><span class="comment">// 设置 int匿名变量值为2</span></span><br><span class="line">fmt.Println(*p)</span><br></pre></td></tr></table></figure><p>new函数还可以用来为结构体创建实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">f := <span class="built_in">new</span>(file)</span><br></pre></td></tr></table></figure><p>贴士：new函数其实是语法糖，不是新概念，如下所示的两个函数其实拥有相同的行为。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInt1</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInt2</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> dummy <span class="keyword">int</span></span><br><span class="line"><span class="keyword">return</span> &amp;dummy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>new</code>只是一个预定义函数，并不是一个关键字，所以<code>new</code>也有可能会被项目定义为别的类型。</p><h4 id="3-3-make函数"><a href="#3-3-make函数" class="headerlink" title="3.3 make函数"></a>3.3 make函数</h4><p>make函数经常用来创建切片、Map、管道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>上面展示了两种map的创建方式，其不同点是第一种创建方式无法预估长度，当长度超过了当前长度时，会引起内存的拷贝！！第二种创建方式直接限定了长度，这样能有效提升性能！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-函数&quot;&gt;&lt;a href=&quot;#一-函数&quot; class=&quot;headerlink&quot; title=&quot;一 函数&quot;&gt;&lt;/a&gt;一 函数&lt;/h2&gt;&lt;h4 id=&quot;1-1-函数声明&quot;&gt;&lt;a href=&quot;#1-1-函数声明&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>引用类型-3-指针</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-3-%E6%8C%87%E9%92%88/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-3-%E6%8C%87%E9%92%88/</id>
    <published>2020-06-16T07:16:24.728Z</published>
    <updated>2020-04-21T01:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-指针"><a href="#一-指针" class="headerlink" title="一 指针"></a>一 指针</h2><h3 id="1-1-指针的创建"><a href="#1-1-指针的创建" class="headerlink" title="1.1 指针的创建"></a>1.1 指针的创建</h3><p>Go保留了指针，代表某个内存地址，默认值为 <code>nil</code> ，使用 <code>&amp;</code> 取变量地址，通过 <code>*</code> 访问目标对象。  </p><p>简单示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">"&amp;a="</span>, &amp;a)<span class="comment">// 0xc000096008 一个十六进制数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = &amp;a</span><br><span class="line">fmt.Println(<span class="string">"*p="</span>, *p)<span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>Go同样支持多级指针，如 <code>**T</code></li><li>空指针：声明但未初始化的指针  </li><li>野指针：引用了无效地址的指针，如：<code>var p *int = 0</code>，<code>var p *int = 0xff00</code>(超出范围)</li><li>Go中直接使用<code>.</code>访问目标成员</li></ul><h3 id="1-2-指针使用示例：实现变量值交换"><a href="#1-2-指针使用示例：实现变量值交换" class="headerlink" title="1.2 指针使用示例：实现变量值交换"></a>1.2 指针使用示例：实现变量值交换</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(p1,p2 *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">*p1,*p2 = *p2,*p1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-结构体指针"><a href="#1-3-结构体指针" class="headerlink" title="1.3 结构体指针"></a>1.3 结构体指针</h3><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> u = User&#123;</span><br><span class="line">name:<span class="string">"lisi"</span>,</span><br><span class="line">age: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">p := &amp;u</span><br><span class="line">fmt.Println(u.name)<span class="comment">//输出李四</span></span><br><span class="line">fmt.Println(p.name)<span class="comment">//输出李四</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-Go不支持指针运算"><a href="#1-4-Go不支持指针运算" class="headerlink" title="1.4 Go不支持指针运算"></a>1.4 Go不支持指针运算</h3><p>由于垃圾回收机制的存在，指针运算造成许多困扰，所以Go直接禁止了指针运算</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">1</span></span><br><span class="line">p := &amp;a</span><br><span class="line">p++        <span class="comment">//报错：non-numeric type *int</span></span><br></pre></td></tr></table></figure><h3 id="1-5-new-函数使用"><a href="#1-5-new-函数使用" class="headerlink" title="1.5 new()函数使用"></a>1.5 new()函数使用</h3><p>new()函数可以在 heap堆 区申请一片内存地址空间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">bool</span></span><br><span class="line">p = <span class="built_in">new</span>(<span class="keyword">bool</span>)</span><br><span class="line">fmt.Println(*p)<span class="comment">// false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-指针&quot;&gt;&lt;a href=&quot;#一-指针&quot; class=&quot;headerlink&quot; title=&quot;一 指针&quot;&gt;&lt;/a&gt;一 指针&lt;/h2&gt;&lt;h3 id=&quot;1-1-指针的创建&quot;&gt;&lt;a href=&quot;#1-1-指针的创建&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>引用类型-2-集合</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-2-%E9%9B%86%E5%90%88/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-2-%E9%9B%86%E5%90%88/</id>
    <published>2020-06-16T07:16:24.726Z</published>
    <updated>2020-04-21T01:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-集合map"><a href="#一-集合map" class="headerlink" title="一 集合map"></a>一 集合map</h2><h4 id="1-1-map的创建"><a href="#1-1-map的创建" class="headerlink" title="1.1 map的创建"></a>1.1 map的创建</h4><p>Go内置了map类型，map是一个无序键值对集合（也有一些书籍翻译为字典）。  </p><p>普通创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个map类型，[]内的类型指任意可以进行比较的类型 int指值类型</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"a"</span>:<span class="number">1</span>,<span class="string">"b"</span>:<span class="number">2</span>&#125;</span><br><span class="line">fmt.Print(m[<span class="string">"a"</span>])</span><br></pre></td></tr></table></figure><p>make方式创建map：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">ID <span class="keyword">string</span></span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>] Person</span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>] Person)</span><br><span class="line">m[<span class="string">"123"</span>] = Person&#123;<span class="string">"123"</span>,<span class="string">"Tom"</span>&#125;</span><br><span class="line">p,isFind := m[<span class="string">"123"</span>]</span><br><span class="line">fmt.Println(isFind)<span class="comment">//true</span></span><br><span class="line">fmt.Println(p)<span class="comment">//&#123;123 Tom&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：golang中map的 key 通常 key 为 int 、string，但也可以是其他类型如：bool、数字、string、指针、channel，还可以是只包含前面几个类型的接口、结构体、数组。slice、map、function由于不能使用 == 来判断，不能作为map的key。  </p><h4 id="1-2-map的使用"><a href="#1-2-map的使用" class="headerlink" title="1.2 map的使用"></a>1.2 map的使用</h4><p>通过key操作元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">numbers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">numbers[<span class="string">"one"</span>] = <span class="number">1</span> <span class="comment">//赋值</span></span><br><span class="line">numbers[<span class="string">"ten"</span>] = <span class="number">10</span> <span class="comment">//赋值</span></span><br><span class="line">numbers[<span class="string">"three"</span>] = <span class="number">3</span></span><br><span class="line"><span class="built_in">delete</span>(numbers, <span class="string">"ten"</span>) <span class="comment">// 删除key为 ten 的元素</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"第三个数字是: "</span>, numbers[<span class="string">"three"</span>]) <span class="comment">// 读取数据</span></span><br></pre></td></tr></table></figure><p>map的遍历：同数组一样，使用for-range 的结构遍历  </p><p>注意：</p><ul><li>map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取；</li><li>map的长度是不固定的，也就是和slice一样，也是一种引用类型    </li><li>内置的len函数同样适用于map，返回map拥有的key的数量</li><li>go没有提供清空元素的方法，可以重新make一个新的map，不用担心垃圾回收的效率，因为go中并行垃圾回收效率比写一个清空函数高效很多</li><li>map和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制</li></ul><h4 id="1-3-并发安全的map"><a href="#1-3-并发安全的map" class="headerlink" title="1.3 并发安全的map"></a>1.3 并发安全的map</h4><p>演示并发读写map的问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;<span class="comment">//无限写入</span></span><br><span class="line">m[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;<span class="comment">//无限读取</span></span><br><span class="line">_ = m[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;&#125;<span class="comment">//无限循环，让并发程序在后台执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译会有错误提示：<code>fatal error: concurrent map read and map write</code>，即出现了并发读写，因为用两个并发程序不断的对map进行读和写，产生了竞态问题。map内部会对这种错误进行检查并提前发现。   </p><p>Go内置的map只有读是线程安全的，读写是线程不安全的。  </p><p>需要并发读写时，一般都是加锁，但是这样做性能不高，在go1.9版本中提供了更高效并发安全的sync.Map。  </p><p>sync.Map的特点：</p><ul><li>无须初始化，直接声明即可</li><li>sync.Map不能使用map的方式进行取值和设值操作，而是使用sync.Map的方法进行调用。Store表示存储，Load表示获取，Delete表示删除。 </li><li>使用Range配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，需要继续迭代时，返回true，终止迭代返回false。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scene sync.Map</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存键值对</span></span><br><span class="line">scene.Store(<span class="string">"id"</span>,<span class="number">1</span>)</span><br><span class="line">scene.Store(<span class="string">"name"</span>,<span class="string">"lisi"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据键取值</span></span><br><span class="line">fmt.Println(scene.Load(<span class="string">"name"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line">scene.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">fmt.Println(k,v)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：map没有提供获取map数量的方法，可以在遍历时手动计算。sync.Map为了并发安全。损失了一定的性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-集合map&quot;&gt;&lt;a href=&quot;#一-集合map&quot; class=&quot;headerlink&quot; title=&quot;一 集合map&quot;&gt;&lt;/a&gt;一 集合map&lt;/h2&gt;&lt;h4 id=&quot;1-1-map的创建&quot;&gt;&lt;a href=&quot;#1-1-map的创建&quot; class=&quot;head
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>引用类型-1-切片</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-1-%E5%88%87%E7%89%87/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-1-%E5%88%87%E7%89%87/</id>
    <published>2020-06-16T07:16:24.725Z</published>
    <updated>2020-04-21T01:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-切片创建"><a href="#一-切片创建" class="headerlink" title="一 切片创建"></a>一 切片创建</h2><p>切片(slice)解决了数组长度不能扩展，以及基本类型数组传递时产生副本的问题。</p><p>常用创建方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">int</span><span class="comment">// 和声明数组一样，只是没有长度，但是这样做没有意义，因为底层的数组指针为nil</span></span><br><span class="line">s2 := []<span class="keyword">byte</span> &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;</span><br><span class="line">fmt.Println(s1)<span class="comment">//输出 []</span></span><br><span class="line">fmt.Print(s2)<span class="comment">//输出 [97 98 99]</span></span><br></pre></td></tr></table></figure><p>使用make函数创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>)<span class="comment">// 创建长度为5，容量为5，初始值为0的切片</span></span><br><span class="line">slice2 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>,<span class="number">7</span>)<span class="comment">// 创建长度为5，容量为7，初始值为0的切片</span></span><br><span class="line">slice3 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;<span class="comment">// 创建长度为5，容量为5，并已经初始化的切片</span></span><br></pre></td></tr></table></figure><p>从数组创建：slice可以从一个数组再次声明。slice通过array[i:j]来获取，其中i是数组的开始位置，j是结束位置，但不包含array[j]，它的长度是j-i:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个含有10个元素元素类型为byte的数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>]<span class="keyword">byte</span> &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明两个含有byte的slice</span></span><br><span class="line">ar a, b []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a指向数组的第3个元素开始，并到第五个元素结束，现在a含有的元素: ar[2]、ar[3]和ar[4]</span></span><br><span class="line">a = arr[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">// b是数组arr的另一个slicre,b的元素是：ar[3]和ar[4]</span></span><br><span class="line">b = arr[<span class="number">3</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>注意：声明数组时，方括号内写明了数组的长度或使用…自动计算长度，而声明slice时，方括号内没有任何字符。  </p><p>从切片创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oldSlice := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">newSlice := oldSlice[:<span class="number">6</span>]<span class="comment">//基于切片前6个元素创建，没有的默认0</span></span><br></pre></td></tr></table></figure><p>注意：如果选择的旧切片长度超出了旧切片的cap()值（切片存储长度），则不合法。  </p><h2 id="二-切片常见操作"><a href="#二-切片常见操作" class="headerlink" title="二 切片常见操作"></a>二 切片常见操作</h2><h4 id="2-1-切片常见内置函数"><a href="#2-1-切片常见内置函数" class="headerlink" title="2.1 切片常见内置函数"></a>2.1 切片常见内置函数</h4><p>切片常用内置函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">len()返回切片长度</span><br><span class="line">cap()返回切片底层数组容量</span><br><span class="line">append()对切片追加元素</span><br><span class="line">func copy(dst, src []Type) int</span><br><span class="line">将src中数据拷贝到dst中，返回拷贝的元素个数</span><br></pre></td></tr></table></figure><p>切片空间与元素个数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice1))<span class="comment">// 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice1))<span class="comment">// 10</span></span><br><span class="line">fmt.Println(slice1)<span class="comment">// [0 0 0 0 0]</span></span><br></pre></td></tr></table></figure><p>切片操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切片增加</span></span><br><span class="line">slice1 = <span class="built_in">append</span>(slice1,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">fmt.Println(slice1)<span class="comment">//输出[0 0 0 0 0 1 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片增加一个新切片</span></span><br><span class="line">sliceTemp := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">slice1 = <span class="built_in">append</span>(slice1,sliceTemp...)</span><br><span class="line">fmt.Println(slice1)<span class="comment">//输出[0 0 0 0 0 1 2 0 0 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片拷贝</span></span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>&#125;</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)<span class="comment">//必须给与充足的空间</span></span><br><span class="line">num := <span class="built_in">copy</span>(s2, s1)</span><br><span class="line"></span><br><span class="line">fmt.Println(s1)<span class="comment">//[1 3 6 9]</span></span><br><span class="line">fmt.Println(s2)<span class="comment">//[1 3 6 9 0 0 0 0 0 0]</span></span><br><span class="line">fmt.Println(num)<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片中删除元素</span></span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>&#125;</span><br><span class="line">index := <span class="number">2</span><span class="comment">//删除该位置元素</span></span><br><span class="line">s1 = <span class="built_in">append</span>(s1[:index], s1[index+<span class="number">1</span>:]...)</span><br><span class="line">fmt.Println(s1)<span class="comment">//[1 3 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片拷贝</span></span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line"><span class="built_in">copy</span>(s1,s2) <span class="comment">//复制s2前三个元素到slice1前3位置</span></span><br><span class="line"><span class="built_in">copy</span>(s2,s1) <span class="comment">//复制s1前三个元素到slice2</span></span><br></pre></td></tr></table></figure><p>注意：没有…会编译错误，默认第二个参数后是元素值，传入切片需要展开。如果追加的长度超过当前已分配的存储空间，切片会自动分配更大的内存。  </p><h4 id="2-2-切片的一些简便操作"><a href="#2-2-切片的一些简便操作" class="headerlink" title="2.2 切片的一些简便操作"></a>2.2 切片的一些简便操作</h4><ul><li>slice的默认开始位置是0，ar[:n]等价于ar[0:n]</li><li>slice的第二个序列默认是数组的长度，ar[n:]等价于ar[n:len(ar)]</li><li>如果从一个数组里面直接获取slice，可以这样ar[:]，因为默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)]</li><li>切片的遍历可以使用for循环，也可以使用range函数  </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个数组</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">10</span>]<span class="keyword">byte</span>&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>&#125;</span><br><span class="line"><span class="comment">// 声明两个slice</span></span><br><span class="line"><span class="keyword">var</span> aSlice, bSlice []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示一些简便操作</span></span><br><span class="line">aSlice = array[:<span class="number">3</span>] <span class="comment">// 等价于aSlice = array[0:3] aSlice包含元素: a,b,c</span></span><br><span class="line">aSlice = array[<span class="number">5</span>:] <span class="comment">// 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,j</span></span><br><span class="line">aSlice = array[:] <span class="comment">// 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从slice中获取slice</span></span><br><span class="line">aSlice = array[<span class="number">3</span>:<span class="number">7</span>] <span class="comment">// aSlice包含元素: d,e,f,g，len=4，cap=7</span></span><br><span class="line">bSlice = aSlice[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">// bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,f</span></span><br><span class="line">bSlice = aSlice[:<span class="number">3</span>] <span class="comment">// bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,f</span></span><br><span class="line">bSlice = aSlice[<span class="number">0</span>:<span class="number">5</span>] <span class="comment">// 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,h</span></span><br><span class="line">bSlice = aSlice[:] <span class="comment">// bSlice包含所有aSlice的元素: d,e,f,g</span></span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 2.3 切片的截取</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- `</span>s[n]<span class="string">`：切片s中索引为位置为n的项</span></span><br><span class="line"><span class="string">- `</span>s[:]<span class="string">`：从切片s的索引位置0到`</span><span class="built_in">len</span>(s)<span class="number">-1</span><span class="string">`所获得的切片</span></span><br><span class="line"><span class="string">- `</span>s[low:]<span class="string">`：从切片s的索引位置low到`</span><span class="built_in">len</span>(s)<span class="number">-1</span><span class="string">`所获得的切片</span></span><br><span class="line"><span class="string">- `</span>s[:high]<span class="string">`：从切片s的索引位置0到high所获得的切片</span></span><br><span class="line"><span class="string">- `</span>s[low:high]<span class="string">`：从切片s的索引位置low到high所获得的切片</span></span><br><span class="line"><span class="string">- `</span>s[low:high:max]<span class="string">`：从low到high的切片，且容量`</span><span class="built_in">cap</span>=max-low<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 1.7 字符串转切片  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line">str := <span class="string">"hello,世界"</span></span><br><span class="line">a := []<span class="keyword">byte</span>(str)<span class="comment">//字符串转换为[]byte类型切片</span></span><br><span class="line">b := []<span class="keyword">rune</span>(str)<span class="comment">//字符串转换为[]rune类型切片</span></span><br></pre></td></tr></table></figure><h2 id="三-切片存储结构"><a href="#三-切片存储结构" class="headerlink" title="三 切片存储结构"></a>三 切片存储结构</h2><p>与数组相比，切片多了一个存储能力值的概念，即元素个数与分配空间可以是两个不同的值，其结构如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">arrary = unsafe.Pointer<span class="comment">//指向底层数组的指针</span></span><br><span class="line"><span class="built_in">len</span> <span class="keyword">int</span><span class="comment">//切片元素数量</span></span><br><span class="line"><span class="built_in">cap</span> <span class="keyword">int</span><span class="comment">//底层数组的容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以切片通过内部的指针和相关属性引用数组片段，实现了变长方案，Slice并不是真正意义上的动态数组。  </p><p>合理设置存储能力，可以大幅提升性能，比如知道最多元素个数为50，那么提前设置为50，而不是先设为30，可以明显减少重新分配内存的操作。  </p><h2 id="四-切片作为函数参数"><a href="#四-切片作为函数参数" class="headerlink" title="四 切片作为函数参数"></a>四 切片作为函数参数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"test---%p\n"</span>, s) <span class="comment">// 打印与main函数相同的地址</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Printf(<span class="string">"test---%p\n"</span>, s) <span class="comment">// 一旦append的数据超过切片长度，则会打印新地址</span></span><br><span class="line">fmt.Println(<span class="string">"test---"</span>, s)    <span class="comment">// [0 0 0 1 2 3 4 5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">test(s1)</span><br><span class="line">fmt.Printf(<span class="string">"main---%p\n"</span>, s1) <span class="comment">// 不会因为test函数内的append而改变</span></span><br><span class="line">fmt.Println(<span class="string">"main---"</span>, s1)    <span class="comment">// [ 0 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-切片创建&quot;&gt;&lt;a href=&quot;#一-切片创建&quot; class=&quot;headerlink&quot; title=&quot;一 切片创建&quot;&gt;&lt;/a&gt;一 切片创建&lt;/h2&gt;&lt;p&gt;切片(slice)解决了数组长度不能扩展，以及基本类型数组传递时产生副本的问题。&lt;/p&gt;
&lt;p&gt;常用创建方式
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>常量</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%B8%B8%E9%87%8F/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%B8%B8%E9%87%8F/</id>
    <published>2020-06-16T07:16:24.723Z</published>
    <updated>2020-04-21T01:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-常量"><a href="#一-常量" class="headerlink" title="一 常量"></a>一 常量</h2><p>常量：在编译阶段就确定下来的值，程序运行时无法改变。   </p><p>定义方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A = <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> PI <span class="keyword">float32</span> = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span> &lt;&lt; <span class="number">3</span><span class="comment">//常量与表达式</span></span><br></pre></td></tr></table></figure><p>错误写法：常量赋值是一个编译期行为，右边的值不能出现在运行时才能得到结果的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HOME = os.GetEnv(<span class="string">"HOME"</span>)</span><br></pre></td></tr></table></figure><h2 id="二-无类型常量"><a href="#二-无类型常量" class="headerlink" title="二 无类型常量"></a>二 无类型常量</h2><p>一个常量可以有任意一个确定的基础类型，例如int或float64，但是许多常量并没有一个明确的基础类型。  </p><p>无类型常量的作用：</p><ul><li>编译器会为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算，可以认为至少有256bit的运算精度</li><li>无类型的常量可以直接用于更多的表达式而不需要显式的类型转换</li></ul><p>示例：math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float32</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">float64</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> z <span class="keyword">complex128</span> = math.Pi</span><br></pre></td></tr></table></figure><p>如果math.Pi被确定为特定类型，比如float64，那么结果精度可能会不一样，同时对于需要float32或complex128类型值的地方则会强制需要一个明确的类型转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi64 <span class="keyword">float64</span> = math.Pi</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">float32</span> = <span class="keyword">float32</span>(Pi64)</span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">float64</span> = Pi64</span><br><span class="line"><span class="keyword">var</span> z <span class="keyword">complex128</span> = <span class="keyword">complex128</span>(Pi64)</span><br></pre></td></tr></table></figure><p>对于常量面值，不同的写法可能会对应不同的类型。例如0、0.0、0i和<code>\u0000</code>虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，true和false也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。</p><p>前面说过除法运算符/会根据操作数的类型生成对应类型的结果。因此，不同写法的常量除法表达式可能对应不同的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="number">212</span></span><br><span class="line">fmt.Println((f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>)     <span class="comment">// "100"; (f - 32) * 5 is a float64</span></span><br><span class="line">fmt.Println(<span class="number">5</span> / <span class="number">9</span> * (f - <span class="number">32</span>))     <span class="comment">// "0";   5/9 is an untyped integer, 0</span></span><br><span class="line">fmt.Println(<span class="number">5.0</span> / <span class="number">9.0</span> * (f - <span class="number">32</span>)) <span class="comment">// "100"; 5.0/9.0 is an untyped float</span></span><br></pre></td></tr></table></figure><p>只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语句，或者出现在有明确类型的变量声明的右边，如下面的其余三行语句，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="number">3</span> + <span class="number">0i</span> <span class="comment">// untyped complex -&gt; float64</span></span><br><span class="line">f = <span class="number">2</span>                  <span class="comment">// untyped integer -&gt; float64</span></span><br><span class="line">f = <span class="number">1e123</span>              <span class="comment">// untyped floating-point -&gt; float64</span></span><br><span class="line">f = <span class="string">'a'</span>                <span class="comment">// untyped rune -&gt; float64</span></span><br></pre></td></tr></table></figure><p>上面的语句相当于:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="keyword">float64</span>(<span class="number">3</span> + <span class="number">0i</span>)</span><br><span class="line">f = <span class="keyword">float64</span>(<span class="number">2</span>)</span><br><span class="line">f = <span class="keyword">float64</span>(<span class="number">1e123</span>)</span><br><span class="line">f = <span class="keyword">float64</span>(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure><p>无论是隐式或显式转换，将一种类型转换为另一种类型都要求目标可以表示原始值。对于浮点数和复数，可能会有舍入处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">deadbeef = <span class="number">0xdeadbeef</span> <span class="comment">// untyped int with value 3735928559</span></span><br><span class="line">a = <span class="keyword">uint32</span>(deadbeef)  <span class="comment">// uint32 with value 3735928559</span></span><br><span class="line">b = <span class="keyword">float32</span>(deadbeef) <span class="comment">// float32 with value 3735928576 (rounded up)</span></span><br><span class="line">c = <span class="keyword">float64</span>(deadbeef) <span class="comment">// float64 with value 3735928559 (exact)</span></span><br><span class="line">d = <span class="keyword">int32</span>(deadbeef)   <span class="comment">// compile error: constant overflows int32</span></span><br><span class="line">e = <span class="keyword">float64</span>(<span class="number">1e309</span>)    <span class="comment">// compile error: constant overflows float64</span></span><br><span class="line">f = <span class="keyword">uint</span>(<span class="number">-1</span>)          <span class="comment">// compile error: constant underflows uint</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型，就像下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span>      <span class="comment">// untyped integer;        implicit int(0)</span></span><br><span class="line">r := <span class="string">'\000'</span> <span class="comment">// untyped rune;           implicit rune('\000')</span></span><br><span class="line">f := <span class="number">0.0</span>    <span class="comment">// untyped floating-point; implicit float64(0.0)</span></span><br><span class="line">c := <span class="number">0i</span>     <span class="comment">// untyped complex;        implicit complex128(0i)</span></span><br></pre></td></tr></table></figure><p>注意有一点不同：无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。<br>如果不知道浮点数类型的内存大小是很难写出正确的数值算法的，因此Go语言不存在整型类似的不确定内存大小的浮点数和复数类型。  </p><p>如果要给变量一个不同的类型，我们必须显式地将无类型的常量转化为所需的类型，或给声明的变量指定明确的类型，像下面例子这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="keyword">int8</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int8</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>当尝试将这些无类型的常量转为一个接口值时（见第7章），这些默认类型将显得尤为重要，因为要靠它们明确接口对应的动态类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, <span class="number">0</span>)      <span class="comment">// "int"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, <span class="number">0.0</span>)    <span class="comment">// "float64"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, <span class="number">0i</span>)     <span class="comment">// "complex128"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, <span class="string">'\000'</span>) <span class="comment">// "int32" (rune)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-常量&quot;&gt;&lt;a href=&quot;#一-常量&quot; class=&quot;headerlink&quot; title=&quot;一 常量&quot;&gt;&lt;/a&gt;一 常量&lt;/h2&gt;&lt;p&gt;常量：在编译阶段就确定下来的值，程序运行时无法改变。   &lt;/p&gt;
&lt;p&gt;定义方式：&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>类型转换与别名</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%88%AB%E5%90%8D/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%88%AB%E5%90%8D/</id>
    <published>2020-06-16T07:16:24.722Z</published>
    <updated>2020-04-21T01:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-数据类型转换"><a href="#一-数据类型转换" class="headerlink" title="一 数据类型转换"></a>一 数据类型转换</h2><h4 id="1-1-显式转换"><a href="#1-1-显式转换" class="headerlink" title="1.1 显式转换"></a>1.1 显式转换</h4><p>Go在不同类型的变量之间赋值时需要显式转换。也就是说Golang中数据类型不能自动转换。</p><h4 id="1-2-数值类型转换"><a href="#1-2-数值类型转换" class="headerlink" title="1.2 数值类型转换"></a>1.2 数值类型转换</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int32</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> n1 <span class="keyword">float64</span> = <span class="keyword">float64</span>(i)</span><br><span class="line">fmt.Printf(<span class="string">"n1=%v"</span>, n1)<span class="comment">//输出100</span></span><br></pre></td></tr></table></figure><p>注意：在转换中，比如将<code>int64</code>转成<code>int8【-128---127】</code>，编译时不会报错，只是转换的结果是按溢出处理，和我们希望的结果不一样。 因此在转换时，需要考虑范围。</p><h4 id="1-3-基本数据类型与字符串转换"><a href="#1-3-基本数据类型与字符串转换" class="headerlink" title="1.3 基本数据类型与字符串转换"></a>1.3 基本数据类型与字符串转换</h4><p>基本数据类型转字符串：fmt.Sprintf();该函数会返回转换后的字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">str = fmt.Sprintf(<span class="string">"%t"</span>, b)</span><br><span class="line">fmt.Printf(str)<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>字符串转基本数据类型：使用包strconv</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"true"</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span></span><br><span class="line">b, _ = strconv.ParseBool(str)</span><br><span class="line">   fmt.Printf(<span class="string">"%v"</span>, b)</span><br></pre></td></tr></table></figure><p>注意：在将<code>String</code>类型转成基本数据类型时，要确保<code>String</code>类型能够转成有效的数据，比如可以把”123”,转成一个整数，但不能转换”hello”，如果这样做，Golang 直接将其转成<code>0</code>，其它类型也是一样的道理，如：<code>float =&gt; 0 bool =&gt; false</code>。</p><h2 id="二-类型别名"><a href="#二-类型别名" class="headerlink" title="二 类型别名"></a>二 类型别名</h2><h4 id="2-1-类型别名的使用"><a href="#2-1-类型别名的使用" class="headerlink" title="2.1 类型别名的使用"></a>2.1 类型别名的使用</h4><p>Go在1.9版本加入了类型别名。主要用于代码升级、迁移中类型的兼容问题（C/C++中使用宏来解决重构升级带来的问题）。  </p><p>Go1.9之前的版本内部定义了新的类型byte和rune，用于指代<code>uint8</code>和<code>int32</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> <span class="keyword">int32</span></span><br></pre></td></tr></table></figure><p>Go1.9之后<code>uint8</code>和<code>int32</code>使用了类型别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span><span class="comment">// 使用 = 号定义后，都会按照等号右边的类型打印、计算</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">类型定义是定义了一个全新的类型的类型。类型别名只是某个类型的小名，并非创造了新的类型：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span>                          <span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">type</span> AliasInt = <span class="keyword">int</span>                     <span class="comment">// 类型别名，支持使用括号，同时起多个别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1 MyInt</span><br><span class="line">fmt.Printf(<span class="string">"a1 type: %T\n"</span>, a1)<span class="comment">//main.MyInt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a2 AliasInt</span><br><span class="line">fmt.Printf(<span class="string">"a2 type: %T\n"</span>, a2)<span class="comment">//int</span></span><br></pre></td></tr></table></figure><h4 id="2-2-不同包下的类型定义"><a href="#2-2-不同包下的类型定义" class="headerlink" title="2.2 不同包下的类型定义"></a>2.2 不同包下的类型定义</h4><p>如下示例，在项目根目录新建文件夹<code>mypack</code>，在该目录建立<code>person.go</code>文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span><span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"run..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main.go中，如下使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"TestGo/mypack"</span><span class="comment">// // TestGo 是 go.mod文件中定义的项目名：module TestGo</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student  mypack.Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">Study</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"study..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s := &amp;Student&#123;&#125;</span><br><span class="line">s.Study()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-不同包下的类型别名"><a href="#2-3-不同包下的类型别名" class="headerlink" title="2.3 不同包下的类型别名"></a>2.3 不同包下的类型别名</h4><p>2.2 中的案例如果将类型定义改为类型别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student = mypack.Person                <span class="comment">// 这时Student的方法就会报错：无法为 Person 添加新的方法</span></span><br></pre></td></tr></table></figure><p>使用方式：必须直接在person文件中直接使用类型别名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span><span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"run..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student = Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Student)</span> <span class="title">Study</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"study..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main中调用别名方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span><span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"run..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student = Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Student)</span> <span class="title">Study</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"study..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-Go的类型系统补充"><a href="#三-Go的类型系统补充" class="headerlink" title="三 Go的类型系统补充"></a>三 Go的类型系统补充</h3><h3 id="3-1-命名类型和未命名类型"><a href="#3-1-命名类型和未命名类型" class="headerlink" title="3.1 命名类型和未命名类型"></a>3.1 命名类型和未命名类型</h3><ul><li>命名类型：Named Type。类型通过标识符、自定义类型表示</li><li>未命名类型：Unamed Type。也称为类型字面量（Type Literal），由预声明类型、关键字、操作符等组合而成，如array、slice、channel、pointer、function、未使用type定义的struct、未使用type定义的interface。 </li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名类型，其类型是 Person</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 未命名类型，其类型是 struct &#123; name string &#125;</span></span><br><span class="line">p := <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-底层类型"><a href="#3-2-底层类型" class="headerlink" title="3.2 底层类型"></a>3.2 底层类型</h3><p>所有类型都有一个底层类型 underlying type，其规则如下：</p><ul><li>预声明类型（Pre-declared types）和类型字面量（type literals）的底层类型是他们自身</li><li>自定义类型<code>type newtype oldtype</code>中newtype的底层类型是逐层递归向下查找的，直到找到oldtype的预声明类型或字面量类型</li></ul><h3 id="3-3-Go中的类型相同"><a href="#3-3-Go中的类型相同" class="headerlink" title="3.3 Go中的类型相同"></a>3.3 Go中的类型相同</h3><p>Go中类型相同的规范：</p><ul><li>命名类型的数据类型相同：声明语句必须完全相同</li><li>未命名类型数据类型相同：类型声明字面量结构相同，且内部元素的类型相同</li><li>命名类型与未命名类型永远不同</li><li>通过类型别名语句声明的两个类型相同。类型别名语法：<code>type T1 = T2</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-数据类型转换&quot;&gt;&lt;a href=&quot;#一-数据类型转换&quot; class=&quot;headerlink&quot; title=&quot;一 数据类型转换&quot;&gt;&lt;/a&gt;一 数据类型转换&lt;/h2&gt;&lt;h4 id=&quot;1-1-显式转换&quot;&gt;&lt;a href=&quot;#1-1-显式转换&quot; class=&quot;head
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>值类型-4-结构体</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-4-%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-4-%E7%BB%93%E6%9E%84%E4%BD%93/</id>
    <published>2020-06-16T07:16:24.720Z</published>
    <updated>2020-04-21T01:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-结构体的基本使用"><a href="#一-结构体的基本使用" class="headerlink" title="一 结构体的基本使用"></a>一 结构体的基本使用</h2><p>结构体可以用来声明新的类型，作为其他类型的属性/字段的容器，如下定义一个学生结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按顺序初始化：每个成员都必须初始化</span></span><br><span class="line"><span class="keyword">var</span> p1 Person = Person&#123;<span class="string">"lisi"</span>, <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制定成员初始化：没有被初始化的，自动赋零值</span></span><br><span class="line">p2 := Person&#123;age:<span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 申请结构体</span></span><br><span class="line">p3 := <span class="built_in">new</span>(Person)      <span class="comment">//被new生成的结构体实例其实是指针类型</span></span><br><span class="line">p3.name = <span class="string">"zs"</span>          <span class="comment">//这里的.语法只是语法糖，将p3.name转换成了(*p3).name</span></span><br><span class="line">p3.age = <span class="number">27</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接声明</span></span><br><span class="line"><span class="keyword">var</span> s4 Person</span><br><span class="line">p4.name = <span class="string">"ww"</span></span><br><span class="line">p4.age = <span class="number">30</span></span><br></pre></td></tr></table></figure><p>贴士：</p><ul><li>struct的结构中的类型可以是任意类型，且存储空间是连续的，其字段按照声明时的顺序存放  </li><li>如果结构体的所有的成员都是可以比较的，那么结构体本身也是可以比较的，使用 == != ，不支持 &gt; 和 &lt;</li><li>如果结构体的成员要被包外调用，需要大写首字母。</li></ul><h2 id="二-结构体地址与实例化"><a href="#二-结构体地址与实例化" class="headerlink" title="二 结构体地址与实例化"></a>二 结构体地址与实例化</h2><p>前面说过，对结构体的new其实是生成了一个指针类型。其实对结构体进行<code>&amp;</code>取地址操作时，也可以视为对该类型进行一次<code>new</code>的实例化操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ins := &amp;T&#123;&#125;</span><br><span class="line"></span><br><span class="line"># T是结构体类型</span><br><span class="line"># ins为结构体的实例，类型为*T，是指针类型</span><br></pre></td></tr></table></figure><h2 id="四-内嵌结构体"><a href="#四-内嵌结构体" class="headerlink" title="四 内嵌结构体"></a>四 内嵌结构体</h2><p>当前结构体可以直接访问其内嵌结构体的内部字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Animal</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Person</span><br><span class="line">ClassName <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方式1</span></span><br><span class="line">s1 := Student&#123;</span><br><span class="line">Person&#123;</span><br><span class="line">Animal: Animal &#123;</span><br><span class="line">Age: <span class="number">15</span>,</span><br><span class="line">&#125;,</span><br><span class="line">Name:<span class="string">"lisi"</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"一班"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s1.Age)<span class="comment">// 正确输出15</span></span><br><span class="line">fmt.Println(s1.Person.Name)<span class="comment">// 正确输出lisi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方式2</span></span><br><span class="line"><span class="keyword">var</span> s2 Student</span><br><span class="line">s2.Name = <span class="string">"zs"</span></span><br><span class="line">s2.Age = <span class="number">30</span></span><br><span class="line">s2.ClassName = <span class="string">"二班"</span></span><br><span class="line">fmt.Println(s2.Age)<span class="comment">// 正确输出30</span></span><br><span class="line">fmt.Println(s2.Person.Name)<span class="comment">// 正确输出zs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-匿名字段"><a href="#四-匿名字段" class="headerlink" title="四 匿名字段"></a>四 匿名字段</h2><p>结构体的字段名与类型一一对应，如果不提供名字，则为匿名字段。</p><p>匿名字段如果是一个struct，这个struct拥有的全部字段都被隐式引入了当前的struct。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person                   <span class="comment">// 匿名字段，那么默认Student就包含了Human的所有字段</span></span><br><span class="line">    classroom <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅仅是struct，其他所有内置类型和自定义类型都可以作为匿名字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> course []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Person <span class="comment">// 匿名字段，struct</span></span><br><span class="line">course<span class="comment">// 内置一个切片类型</span></span><br><span class="line">classroom <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个学生</span></span><br><span class="line">s := Student&#123;Person:Person&#123;<span class="string">"LiLei"</span>, <span class="number">17</span>&#125;, classroom:<span class="string">"二班"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问该学生字段</span></span><br><span class="line">fmt.Println(<span class="string">"name = "</span>, s.name)</span><br><span class="line">fmt.Println(<span class="string">"classroom =  "</span>, s.classroom)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改学生的课程</span></span><br><span class="line">s.course = []<span class="keyword">string</span>&#123;<span class="string">"语文"</span>, <span class="string">"美术"</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"course = "</span>, s.course)<span class="comment">// [语文 美术]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贴士：如果Person和Student中都有同一个字段，那么Go会优先访问当前层。例如二者都有<code>tel</code>字段，那么<code>s.tel</code>将会访问的是Student中的数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-结构体的基本使用&quot;&gt;&lt;a href=&quot;#一-结构体的基本使用&quot; class=&quot;headerlink&quot; title=&quot;一 结构体的基本使用&quot;&gt;&lt;/a&gt;一 结构体的基本使用&lt;/h2&gt;&lt;p&gt;结构体可以用来声明新的类型，作为其他类型的属性/字段的容器，如下定义一个学生
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>值类型-3-数组</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-3-%E6%95%B0%E7%BB%84/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-3-%E6%95%B0%E7%BB%84/</id>
    <published>2020-06-16T07:16:24.719Z</published>
    <updated>2020-04-21T01:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-数组"><a href="#一-数组" class="headerlink" title="一 数组"></a>一 数组</h2><h4 id="1-1-数组的声明"><a href="#1-1-数组的声明" class="headerlink" title="1.1 数组的声明"></a>1.1 数组的声明</h4><p>数组是一段固定长度的连续内存区域。数组的长度定义后不可更改，长度使用 len() 获取。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 [<span class="number">10</span>]<span class="keyword">int</span><span class="comment">//定义长度为10的整型数组，很少这样使用</span></span><br><span class="line">arr2 [<span class="number">5</span>]<span class="keyword">int</span> := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;<span class="comment">//定义并初始化</span></span><br><span class="line">arr3 := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;<span class="comment">//自动推导并初始化</span></span><br><span class="line">arr4 := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;<span class="comment">//指定总长度，前几位被初始化，没有的使用零值</span></span><br><span class="line">arr5 := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>:<span class="number">10</span>, <span class="number">4</span>:<span class="number">11</span>&#125;<span class="comment">//有选择的初始化，没被初始化的使用零值</span></span><br><span class="line">arr6 := [...]<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;<span class="comment">//自动计算长度</span></span><br></pre></td></tr></table></figure><h4 id="1-2-数组常用操作"><a href="#1-2-数组常用操作" class="headerlink" title="1.2 数组常用操作"></a>1.2 数组常用操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr[:]      代表所有元素</span><br><span class="line">arr[:5]     代表前五个元素，即区间的左闭右开</span><br><span class="line">arr[5:]     代表从第5个开始（不包含第5个）</span><br><span class="line">len(arr)    数组的长度</span><br></pre></td></tr></table></figure><p>贴士：上述操作会引发类型的变化，数组将会转化为Go中新的数据类型slice，见09节</p><h4 id="1-3-数组的遍历"><a href="#1-3-数组的遍历" class="headerlink" title="1.3 数组的遍历"></a>1.3 数组的遍历</h4><p>方式一：for循环遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">fmt.Println(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：for-range遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">fmt.Println(k)<span class="comment">//元素位置</span></span><br><span class="line">fmt.Println(v)<span class="comment">//元素值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-数组使用注意事项"><a href="#1-4-数组使用注意事项" class="headerlink" title="1.4 数组使用注意事项"></a>1.4 数组使用注意事项</h4><p>数组创建完长度就固定，不可以再追加元素；  </p><p>长度是数组类型的一部分，因此<code>[3]int</code>与<code>[4]int</code>是不同的类型；  </p><p>数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该函数的副本，而不是他的指针。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-数组&quot;&gt;&lt;a href=&quot;#一-数组&quot; class=&quot;headerlink&quot; title=&quot;一 数组&quot;&gt;&lt;/a&gt;一 数组&lt;/h2&gt;&lt;h4 id=&quot;1-1-数组的声明&quot;&gt;&lt;a href=&quot;#1-1-数组的声明&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>值类型-2-字符串</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-2-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-2-%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-06-16T07:16:24.717Z</published>
    <updated>2020-04-21T01:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-字符"><a href="#一-字符" class="headerlink" title="一 字符"></a>一 字符</h2><p>Golang 中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存，且使用单引号包裹。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 <span class="keyword">byte</span> = <span class="string">'a'</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="keyword">byte</span> = <span class="string">'0'</span></span><br><span class="line">fmt.Println(<span class="string">"c1="</span>, c1)<span class="comment">//输出 97   </span></span><br><span class="line">fmt.Println(<span class="string">"c2="</span>, c2)<span class="comment">//输出48</span></span><br><span class="line">fmt.Printf(<span class="string">"c1=%c,c2=%c\n"</span>, c1, c2)    <span class="comment">//输出原值 a 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//var c3 byte = '北'</span></span><br><span class="line"><span class="comment">//fmt.Printf("c3=%c", c3)// 溢出错误:overflows byte</span></span><br></pre></td></tr></table></figure><p>贴士：</p><ul><li>字符类型也可以用<code>d%</code>打印为整型</li><li>如果我们保存的字符在 ASCII 表的,比如[0-1, a-z,A-Z..]直接可以保存到 byte</li><li>如果我们保存的字符对应码值大于 255,这时我们可以考虑使用 int 类型保存</li><li>如果我们需要安装字符的方式输出，这时我们需要格式化输出，即 fmt.Printf(“%c”, c1)</li><li>字符可以和整型进行运算</li></ul><h2 id="二-字符串"><a href="#二-字符串" class="headerlink" title="二 字符串"></a>二 字符串</h2><p>传统的字符串是由字符组成的，而Go的字符串是由单个字节连接起来的，即Go字符串是一串固定长度的字符连接起来的字符序列。  </p><p>字符串在Go语言中是基本类型，内容在初始化后不能修改。  </p><p>Go中的字符串都是采用UTF-8字符集编码，使用一对双引号<code>&quot;&quot;</code>或反引号<code>``</code>定义。<code>``</code>可以额外解析换行，即其没有字符转义功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 <span class="keyword">string</span></span><br><span class="line">str1 = <span class="string">"Hello "</span></span><br><span class="line">str2 := <span class="string">" World!"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(str1[<span class="number">0</span>])     <span class="comment">// 输出字符串第一个字符 72</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(str1))   <span class="comment">// 输出长度 6</span></span><br><span class="line">fmt.Println(str1 + str2) <span class="comment">// 输出不带空格的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串不可变，编译报错： cannot assign to 因为</span></span><br><span class="line"><span class="comment">// str1[0] = 'c'</span></span><br></pre></td></tr></table></figure><p>由于Go中的字符串不可直接改变，可以使用下列两种方式进行修改：</p><p>方式一：通过转换为字节数组<code>[]byte</code>类型，构造一个临时字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">strTemp := []<span class="keyword">byte</span>(str)</span><br><span class="line">fmt.Println(<span class="string">"strTemp="</span>, strTemp)<span class="comment">// [104 101 108 108 111]</span></span><br><span class="line"></span><br><span class="line">strTemp[<span class="number">0</span>] = <span class="string">'c'</span></span><br><span class="line">strResult := <span class="keyword">string</span>(strTemp)</span><br><span class="line">fmt.Println(<span class="string">"strResult="</span>, strResult)<span class="comment">// strResult= cello</span></span><br></pre></td></tr></table></figure><p>方式二：使用切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello"</span></span><br><span class="line">str = <span class="string">"c"</span>+ str[<span class="number">1</span>:]<span class="comment">// 1: 表示从第1位开始到最后</span></span><br></pre></td></tr></table></figure><p>Go和Java等语言一样，字符串默认是不可变的，这样保证了线程安全，大家使用的都是只读对象，无须加锁，且能很方便的共享内存，不必使用写时复制。</p><h2 id="三-字符串常用操作"><a href="#三-字符串常用操作" class="headerlink" title="三 字符串常用操作"></a>三 字符串常用操作</h2><h4 id="3-1-len-函数与字符串遍历"><a href="#3-1-len-函数与字符串遍历" class="headerlink" title="3.1 len()函数与字符串遍历"></a>3.1 len()函数与字符串遍历</h4><p>len()函数是go语言的内建函数，可以用来获取字符串、切片、通道等的长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unicode/utf8"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">str1 := <span class="string">"hello world"</span></span><br><span class="line">str2 := <span class="string">"你好，"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(str1))<span class="comment">// 11</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(str2))<span class="comment">// 9</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(str2))<span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个函数输出11很容易理解，第二个函数却输出了9，理论上我们会认为应该是3才对。这是因为Go的字符串都是以UTF-8格式保存，每个中文占据3个字节。Go中计算UTF-8字符串格式的长度应该使用<code>utf8.RuneCountInString</code>。</p><p>字符串遍历方式一：使用字节数组，注意每个中文在UTF-8中占据3个字节</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">fmt.Println(i,str[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串遍历方式二：range关键字只是第一种遍历方式的简写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"你好"</span></span><br><span class="line"><span class="keyword">for</span> i,ch := <span class="keyword">range</span> str &#123;</span><br><span class="line">fmt.Println(i,ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：由于上述len()函数本身原因，Unicode字符遍历需要使用range。</p><h4 id="3-2-string-函数类型转换"><a href="#3-2-string-函数类型转换" class="headerlink" title="3.2 string()函数类型转换"></a>3.2 string()函数类型转换</h4><p>go的内建函数 <code>string()</code>可以将其他类型转变为字符串类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num := <span class="number">12</span></span><br><span class="line">fmt.Printf(<span class="string">"%T \n"</span>, <span class="keyword">string</span>(num))<span class="comment">// string</span></span><br></pre></td></tr></table></figure><h4 id="3-3-字符串连接"><a href="#3-3-字符串连接" class="headerlink" title="3.3 字符串连接"></a>3.3 字符串连接</h4><p>使用<code>+</code>能够连接字符串。但是该操作并不高效（因为字符串在Go中是基本类型，每次拼接都是拷贝了内存！）。Go1.10提供了类似Java的StringBuilder机制来进行高效字符串连接：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">str1 := <span class="string">"hello "</span></span><br><span class="line">str2 := <span class="string">" world"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建字节缓冲</span></span><br><span class="line"><span class="keyword">var</span> stringBuilder bytes.Buffer</span><br><span class="line"></span><br><span class="line"><span class="comment">//把字符串写入缓冲</span></span><br><span class="line">stringBuilder.WriteString(str1)</span><br><span class="line">stringBuilder.WriteString(str2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//将缓冲以字符串形式输出</span></span><br><span class="line">fmt.Println(stringBuilder.String())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在1.10版本前，可以使用bytes.Buffer拼接字符串（因为字符串其实是字节数组）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">buf.WriteString(<span class="string">"hello"</span>)</span><br><span class="line">fmt.Println(buf.String())</span><br></pre></td></tr></table></figure><h2 id="四-strings包相关函数"><a href="#四-strings包相关函数" class="headerlink" title="四 strings包相关函数"></a>四 strings包相关函数</h2><p>strings包提供了字符串的一些常见操作函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找s在字符串str中的索引</span></span><br><span class="line">Index(str, s <span class="keyword">string</span>) <span class="keyword">int</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//判断str是否包含s</span></span><br><span class="line">Contains(str, s <span class="keyword">string</span>) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过字符串str连接切片 s</span></span><br><span class="line">Join(s []<span class="keyword">string</span>, str <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//替换字符串str中old字符串为new字符串，n表示替换的次数，小于0全部替换</span></span><br><span class="line">Replace(str,old,<span class="built_in">new</span> <span class="keyword">string</span>,n <span class="keyword">int</span>) <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串str按照s分割，返回切片</span></span><br><span class="line">Splite(str,s <span class="keyword">string</span>)[]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除头部、尾部指定的字符串</span></span><br><span class="line">Trim(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除空格，返回切片</span></span><br><span class="line">Fields(s <span class="keyword">string</span>) []<span class="keyword">string</span></span><br></pre></td></tr></table></figure><h2 id="五-strconv包的字符串转换函数"><a href="#五-strconv包的字符串转换函数" class="headerlink" title="五 strconv包的字符串转换函数"></a>五 strconv包的字符串转换函数</h2><p>在Java中遇到 <code>&quot;你好&quot; + 123</code>会将 <code>+</code>转变为连接符。而Go语言要求 <code>+</code> 号两边数据的数据类型必须一致，这使得类似的操作变得比较不便，Go提供了strconv包用于字符串与基本类型之间的转换，常用函数有Append、Format、Parse。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Append 系列函数将整数等转换为字符串后，添加到现有的字节数组中</span></span><br><span class="line">str1 := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">str1 = strconv.AppendInt(str1, <span class="number">4567</span>, <span class="number">10</span>)</span><br><span class="line">str1 = strconv.AppendBool(str1, <span class="literal">false</span>)</span><br><span class="line">str1 = strconv.AppendQuote(str1, <span class="string">"abcdefg"</span>)</span><br><span class="line">str1 = strconv.AppendQuoteRune(str1, <span class="string">'单'</span>)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(str1))<span class="comment">// 4567false"abcdefg"'单'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Format 系列函数把其他类型的转换为字符串</span></span><br><span class="line">a := strconv.FormatBool(<span class="literal">false</span>)</span><br><span class="line">b := strconv.FormatFloat(<span class="number">123.23</span>, <span class="string">'g'</span>, <span class="number">12</span>, <span class="number">64</span>)</span><br><span class="line">c := strconv.FormatInt(<span class="number">1234</span>, <span class="number">10</span>)</span><br><span class="line">d := strconv.FormatUint(<span class="number">12345</span>, <span class="number">10</span>)</span><br><span class="line">e := strconv.Itoa(<span class="number">1023</span>)</span><br><span class="line">fmt.Println(a, b, c, d, e)<span class="comment">// false 123.23 1234 12345 1023</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse 系列函数把字符串转换为其他类型</span></span><br><span class="line">f, _ := strconv.ParseBool(<span class="string">"false"</span>)</span><br><span class="line">g, _ := strconv.ParseFloat(<span class="string">"123.23"</span>, <span class="number">64</span>)</span><br><span class="line">h, _ := strconv.ParseInt(<span class="string">"1234"</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">i, _ := strconv.ParseUint(<span class="string">"12345"</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">j, _ := strconv.Atoi(<span class="string">"1023"</span>)</span><br><span class="line">fmt.Println(f, g, h, j, i, j)<span class="comment">// false 123.23 1234 1023 12345 1023</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-字符&quot;&gt;&lt;a href=&quot;#一-字符&quot; class=&quot;headerlink&quot; title=&quot;一 字符&quot;&gt;&lt;/a&gt;一 字符&lt;/h2&gt;&lt;p&gt;Golang 中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存，且使用单引号包裹。  &lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>值类型-1-数值类型</title>
    <link href="https://cool2feel.github.io/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-1-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    <id>https://cool2feel.github.io/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-1-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-06-16T07:16:24.715Z</published>
    <updated>2020-04-21T01:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-数值类型"><a href="#一-数值类型" class="headerlink" title="一 数值类型"></a>一 数值类型</h2><p>数值类型指基本类型中的：整型、浮点型、复数。</p><h2 id="二-整数"><a href="#二-整数" class="headerlink" title="二 整数"></a>二 整数</h2><p>整数类型有无符号(如int)和带符号(如uint)两种，这两种类型的长度相同，但具体长度取决于不同编译器的实现。  </p><p>int8、int16、int32和int64四种有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，<br>同样uint8、uint16、uint32和uint64对应四种无符号整数类型。  </p><p>有符号类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int     32位系统占4字节（与int32范围一样），64位系统占8个节（与int64范围一样）     </span><br><span class="line">int8    占据1字节   范围 -128 ~ 127</span><br><span class="line">int16   占据2字节   范围 -2(15次方) ~ 2（15次方）-1</span><br><span class="line">int32   占据4字节   范围 -2(31次方) ~ 2（31次方）-1</span><br><span class="line">int64   占据8字节   范围 -2(63次方) ~ 2（63次方）-1</span><br><span class="line">runeint32的别称</span><br></pre></td></tr></table></figure><p>无符号类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint32位系统占4字节（与uint32范围一样），64位系统占8字节（与uint64范围一样）     </span><br><span class="line">uint8   占据1字节   范围 0 ~ 255</span><br><span class="line">uint16  占据2字节   范围 0 ~ 2（16次方）-1</span><br><span class="line">uint32  占据4字节   范围 0 ~ 2（32次方）-1</span><br><span class="line">uint64  占据8字节   范围 0 ~ 2（64次方）-1</span><br><span class="line">byteuint8的别称</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>上述类型的变量由于是不同类型，不允许互相赋值或操作</li><li>Go默认的整型类型是int</li><li>查看数据所占据的字节数方法：unsafe.Sizeof()</li></ul><h2 id="三-浮点类型"><a href="#三-浮点类型" class="headerlink" title="三 浮点类型"></a>三 浮点类型</h2><h4 id="3-1-浮点类型的分类"><a href="#3-1-浮点类型的分类" class="headerlink" title="3.1 浮点类型的分类"></a>3.1 浮点类型的分类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float32 单精度  占据4字节   范围 -3.403E38 ~ 3.403E38    (math.MaxFloat32)</span><br><span class="line">float64 双精度  占据8字节   范围 -1.798E208 ~ 1.798E308  (math.MaxFloat64)</span><br></pre></td></tr></table></figure><p>由上看出：</p><ul><li>浮点数是有符号的，浮点数在机器中存放形式是：浮点数=符号位+指数位+尾数位  </li><li>浮点型的范围是固定的，不受操作系统限制</li><li><code>.512</code> 这样数可以识别为 <code>0.512</code></li><li>科学计数法：<ul><li>5.12E2 = 5.12 * 10<sup>2</sup> </li><li>5.12E-2 = 5.12 / 10<sup>2</sup> </li></ul></li></ul><h4 id="3-2-精度损失"><a href="#3-2-精度损失" class="headerlink" title="3.2 精度损失"></a>3.2 精度损失</h4><p>float32可以提供大约6个十进制数的精度，float64大约可以提供15个十进制的精度（一般选择float64）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 <span class="keyword">float32</span> = <span class="number">-123.0000901</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="keyword">float64</span> = <span class="number">-123.0000901</span> </span><br><span class="line">fmt.Println(<span class="string">"num1="</span>,num1)<span class="comment">// -123.00009</span></span><br><span class="line">fmt.Println(<span class="string">"num2="</span>,num2)<span class="comment">// -123.0000901</span></span><br></pre></td></tr></table></figure><h4 id="3-3-浮点数判断相等"><a href="#3-3-浮点数判断相等" class="headerlink" title="3.3 浮点数判断相等"></a>3.3 浮点数判断相等</h4><p>使用 == 号判断浮点数，是不可行的，替代方案如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEqual</span><span class="params">(f1,f2,p <span class="keyword">float64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// p为用户自定义精度，如：0.00001</span></span><br><span class="line">   <span class="keyword">return</span> math.Abs(f1-f2) &lt; p           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-复数"><a href="#四-复数" class="headerlink" title="四 复数"></a>四 复数</h2><p>Go中复数默认类型是complex128（64位实数+64位虚数）。如果需要小一些的，也有complex64(32位实数+32位虚数)。  </p><p>复数的形式为<code>RE + IMi</code>，其中RE是实数部分，IM是虚数部分，而最后的i是虚数单位。</p><p>如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">complex128</span></span><br><span class="line">t = <span class="number">2.1</span> + <span class="number">3.14i</span></span><br><span class="line">t1 = <span class="built_in">complex</span>(<span class="number">2.1</span>,<span class="number">3.14</span>) <span class="comment">// 结果同上</span></span><br><span class="line">fmt.Println(<span class="built_in">real</span>(t))   <span class="comment">// 实部：2.1</span></span><br><span class="line">fmt.Println(<span class="built_in">imag</span>(t))   <span class="comment">// 虚部：3.14</span></span><br></pre></td></tr></table></figure><h2 id="五-NaN非数"><a href="#五-NaN非数" class="headerlink" title="五 NaN非数"></a>五 NaN非数</h2><p>go中的<code>NaN</code>非数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z <span class="keyword">float64</span></span><br><span class="line"><span class="comment">// 输出 "0 -0 +Inf -Inf NaN"</span></span><br><span class="line">fmt.Println(z, -z, <span class="number">1</span>/z, <span class="number">-1</span>/z, z/z)</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>函数<code>math.IsNaN</code>用于测试一个数是否是非数NaN，</li><li>函数<code>math.NaN</code>则返回非数对应的值。</li><li>虽然可以用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等的。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nan := math.NaN()</span><br><span class="line"><span class="comment">// "false false false"</span></span><br><span class="line">fmt.Println(nan == nan, nan &lt; nan, nan &gt; nan)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-数值类型&quot;&gt;&lt;a href=&quot;#一-数值类型&quot; class=&quot;headerlink&quot; title=&quot;一 数值类型&quot;&gt;&lt;/a&gt;一 数值类型&lt;/h2&gt;&lt;p&gt;数值类型指基本类型中的：整型、浮点型、复数。&lt;/p&gt;
&lt;h2 id=&quot;二-整数&quot;&gt;&lt;a href=&quot;#二-整
      
    
    </summary>
    
    
    
  </entry>
  
</feed>

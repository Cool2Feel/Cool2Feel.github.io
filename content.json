{"meta":{"title":"Dwl's blog","subtitle":"记录生活中的点点滴滴","description":"","author":"Dwesome","url":"http://www.dwlblog.网址","root":"/"},"pages":[{"title":"about","date":"2020-06-16T06:42:49.000Z","updated":"2020-06-16T06:42:49.723Z","comments":true,"path":"about/index.html","permalink":"http://www.dwlblog.网址/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2020-06-16T06:43:56.000Z","updated":"2020-06-16T06:43:56.600Z","comments":true,"path":"archives/index.html","permalink":"http://www.dwlblog.网址/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-06-16T06:18:04.000Z","updated":"2020-06-16T07:23:16.641Z","comments":true,"path":"categories/index.html","permalink":"http://www.dwlblog.网址/categories/index.html","excerpt":"","text":""},{"title":"schedule","date":"2020-06-16T06:45:20.000Z","updated":"2020-06-16T06:45:20.419Z","comments":true,"path":"schedule/index.html","permalink":"http://www.dwlblog.网址/schedule/index.html","excerpt":"","text":""},{"title":"","date":"2020-06-16T02:48:00.319Z","updated":"2020-06-16T02:48:00.319Z","comments":false,"path":"tags/index.html","permalink":"http://www.dwlblog.网址/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git使用规范","slug":"项目中的git使用规范","date":"2020-06-16T08:34:57.000Z","updated":"2020-06-16T08:38:47.114Z","comments":true,"path":"2020/06/16/项目中的git使用规范/","link":"","permalink":"http://www.dwlblog.网址/2020/06/16/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84git%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/","excerpt":"","text":"祖师爷 Linus 在创造了伟大的 Linux 之后，又创造了应用最广泛的代码管理工具 —— Git，极大地提高了程序员的生产力。 现如今大部分项目都在使用 Git 作为代码管理工具，不论是在代码管理、版本控制以及团队协作上，Git 相比其他版本控制软件都有着无可比拟的优势。 虽然 Git 是个优秀的工具，但是在项目中是否能够正确合理地使用，是否能够发挥其最大的优势，就我自己这几年的工作经历来看，对于大部分团队这个问题的答案是否定的。 大部分程序员对 Git 的使用基本上都停留在 git add、git commit、git push、git pull 这几个指令上，而且大部分团队也没有 Git 规范，提交信息充斥着大量的 “fix”、“update”，分支管理也很混乱，代码提交哪个分支上也没具体的规定，导致在团队协作过程中经常出现代码合并后谁的代码不见了，修过的 bug 在新版本又出现了……0. 我们可能面临的问题 试想遇到以下这些问题，你会采取怎样的方式去解决： * 需要线上某个历史版本的源码，直接在 develop 分支根据提交记录和时间找对应的节点？ * 线上版本出现严重 bug 需要紧急修复发版本，而你的项目就一个分支，上个版本发布之后已经有大量改动了，怎么办？ * 某个提交改动了部分代码，涉及到 10 几个文件，现在这个改动不需要了，此时要一个个找出这些文件然后再改回去么？ * 出现了一个 bug，之前好像处理过，但是现在忘了当初怎么处理的了，在一堆写着 “fix bug”、“update” 的提交记录中，如何找到当初那笔的提交？ * 某个功能本来准备发布的，现在突然决定这个版本不上了，现在要一处处找到之前的代码，然后再改回去？ * ……以上这些问题在我们的项目中都是会或多或少出现的，部分问题可能涉及到的是对 Git 的功能是否熟悉的问题，大部分问题则是涉及到一个项目的 Git 使用规范问题，如果有一个很好的规范，在项目中合理地使用 Git，很多问题压根就不是问题。 Git 规范的必要性 既然认同需要一份 Git 规范，那么这个规范需要规范哪些内容，解决哪些问题，又带来哪些好处呢？个人认为有以下几点： 分支管理 代码提交在应该提交的分支 随时可以切换到线上稳定版本代码 多个版本的开发工作同时进行 提交记录的可读性 准确的提交描述，具备可检索性 合理的提交范围，避免一个功能就一笔提交 分支间的合并保有提交历史，且合并后结果清晰明了 避免出现过多的分叉 团队协作 明确每个分支的功用，做到对应的分支执行对应的操作 合理的提交，每次提交有明确的改动范围和规范的提交信息 使用 Git 管理版本迭代、紧急线上 bug fix、功能开发等任务 以上就是一份 Git 规范的作用和使命。 接下来结合 Git-Flow 和个人实际的项目经验，总结了一份项目中使用 Git 的规范，其中大部分内容都是对 Git-Flow 进行一个解读和扩展，告诉大家为什么这么做以及怎么做。 这里也推荐一下 Git-Flow 相关的内容： A successful Git branching model » nvie.com这是一份 2010 年提出来的分支管理规范，距今已过去 8 年了，但是其工作流程至今还是适用的，也衍生出很多优秀的开发流程。 以下就是 Git-Flow 的经典流程图：如果你熟悉 Git-Flow，那么你对上图中的各种分支和线应该都能够理解，如果你之前没了解过相关的知识，那你可能会有点懵，不过在读完本文之后再看这张图，应该就能够理解了。2. 分支管理规范2.1 分支说明和操作 master 分支 主分支，永远处于稳定状态，对应当前线上版本 以 tag 标记一个版本，因此在 master 分支上看到的每一个 tag 都应该对应一个线上版本 不允许在该分支直接提交代码 develop 分支 开发分支，包含了项目最新的功能和代码，所有开发都依赖 develop 分支进行 小的改动可以直接在 develop 分支进行，改动较多时切出新的 feature 分支进行 注： 更好的做法是 develop 分支作为开发的主分支，也不允许直接提交代码。小改动也应该以 feature 分支提 merge request 合并，目的是保证每个改动都经过了强制代码 review，降低代码风险 feature 分支 功能分支，开发新功能的分支 开发新的功能或者改动较大的调整，从 develop 分支切换出 feature 分支，分支名称为 feature/xxx 开发完成后合并回 develop 分支并且删除该 feature/xxx 分支 release 分支 发布分支，新功能合并到 develop 分支，准备发布新版本时使用的分支 当 develop 分支完成功能合并和部分 bug fix，准备发布新版本时，切出一个 release 分支，来做发布前的准备，分支名约定为release/xxx 发布之前发现的 bug 就直接在这个分支上修复，确定准备发版本就合并到 master 分支，完成发布，同时合并到 develop 分支 hotfix 分支 紧急修复线上 bug 分支 当线上版本出现 bug 时，从 master 分支切出一个 hotfix/xxx 分支，完成 bug 修复，然后将 hotfix/xxx 合并到 master 和 develop 分支(如果此时存在 release 分支，则应该合并到 release 分支)，合并完成后删除该 hotfix/xxx 分支以上就是在项目中应该出现的分支以及每个分支功能的说明。 其中稳定长期存在的分支只有 master 和 develop 分支，别的分支在完成对应的使命之后都会合并到这两个分支然后被删除。简单总结如下： master 分支: 线上稳定版本分支 develop 分支: 开发分支，衍生出 feature 分支和 release 分支 release 分支: 发布分支，准备待发布版本的分支，存在多个，版本发布之后删除 feature 分支: 功能分支，完成特定功能开发的分支，存在多个，功能合并之后删除 hotfix 分支: 紧急热修复分支，存在多个，紧急版本发布之后删除2.2 分支间操作注意事项 在团队开发过程中，避免不了和其他人一起协作，\b 同时也会遇到合并分支等一些操作，这里提交 2 个个人觉得比较好的分支操作规范。 同一分支 git pull 使用 rebase 首先看一张图： 看到这样的 \b 提交线图，想从中看出一条清晰的提交线几乎是不可能的，充满了 Merge remote-tracking branch ‘origin/xxx’ into xxx 这样的提交记录，同时也将提交线弄成了交错纵横的图，没有了可读性。 这里最大的原因就是因为默认的 git pull 使用的是 merge 行为，当你更新代码时，如果本地存在未推送到远程的提交，就会产生一个这样的 merge 提交记录。因此在同一个分支上更新代码时推荐使用 git pull --rebase。 下面这张图展示了默认的 git pull 和 git pull --rebase 的结果差异，使用 git pull --rebase 目的是修整提交线图，使其形成一条直线。 默认的 git pull 行为是 merge，可以进行如下设置修改默认的 git pull 行为： # 为某个分支单独设置，这里是设置 dev 分支 git config branch.dev.rebase true # 全局设置，所有的分支 git pull 均使用 --rebase git config --global pull.rebase true git config --global branch.autoSetupRebase always 这里需要说明一下，在我看来使用 git pull --rebase 操作是比较好的，能够得到一条很清晰的提交直线图，方便查看提交记录和 code review，但是由于 rebase 会改变提交历史，也存在一些不好的影响。这里就不做过多的讨论了，有兴趣的话可以移步知乎上的讨论：在开发过程中使用 git rebase 还是 git merge，优缺点分别是什么？ 分支合并使用 --no-ff # 例如当前在 develop 分支，需要合并 feature/xxx 分支 git merge --no-ff feature/xxx 在解释这个命令之前，先解释下 Git 中的 fast-forward： 举例来说，开发一直在 develop 分支进行，此时有个新功能需要开发，新建一个 feature/a 分支，并在其上进行一系列开发和提交。当完成功能开发时，此时回到 develop 分支，此时 develop 分支在创建 feature/a 分支之后没有产生任何的 commit，那么此时的合并就叫做 fast-forward。 fast-forward 合并的结果如下图所示，这种 merge 的结果就是一条直线了，无法明确看到切出一个新的 feature 分支，并完成了一个新的功能开发，因此此时比较推荐使用 git merge --no-ff，得到的结果就很明确知道，\b新的一系列提交是完成了一个新的功能，如果需要对这个功能进行 code review，那么只需要检视叉的那条线上的提交即可。 关于以上两个分支间的操作建议，如果需要了解更多，可以阅读洁癖者用 Git：pull –rebase 和 merge –no-ff 这篇文章。 2.3 项目分支操作流程示例 这部分内容结合日常项目的开发流程，涉及到开发新功能、分支合并、发布新版本以及发布紧急修复版本等操作，展示常用的命令和操作。 切到 develop 分支，更新 develop 最新代码 git checkout develop git pull --rebase 新建 feature 分支，开发新功能 git checkout -b feature/xxx ... git add &lt;files&gt; git commit -m &quot;feat(xxx): commit a&quot; git commit -m &quot;feat(xxx): commit b&quot; # 其他提交 ... 如果此时 develop 分支有一笔提交，影响到你的 feature 开发，可以 rebase develop 分支，前提是 该 feature 分支只有你自己一个在开发，如果多人都在该分支，需要进行协调： # 切换到 develop 分支并更新 develop 分支代码 git checkout develop git pull --rebase # 切回 feature 分支 git checkout feature/xxx git rebase develop # 如果需要提交到远端，且之前已经提交到远端，此时需要强推(强推需慎重！) git push --force 上述场景也可以通过 git cherry-pick 来实现，有兴趣的可以去了解一下这个指令。 完成 feature 分支，合并到 develop 分支 # 切到 develop 分支，更新下代码 git check develop git pull --rebase # 合并 feature 分支 git merge feature/xxx --no-ff # 删除 feature 分支 git branch -d feature/xxx # 推到远端 git push origin develop 当某个版本所有的 feature 分支均合并到 develop 分支，就可以切出 release 分支，准备发布新版本，提交测试并进行 bug fix # 当前在 develop 分支 git checkout -b release/xxx # 在 release/xxx 分支进行 bug fix git commit -m &quot;fix(xxx): xxxxx&quot; ... 所有 bug 修复完成，准备发布新版本 # master 分支合并 release 分支并添加 tag git checkout master git merge --no-ff release/xxx --no-ff # 添加版本标记，这里可以使用版本发布日期或者具体的版本号 git tag 1.0.0 # develop 分支合并 release 分支 git checkout develop git merge --no-ff release/xxx # 删除 release 分支 git branch -d release/xxx 至此，一个新版本发布完成。 线上出现 bug，需要紧急发布修复版本 # 当前在 master 分支 git checkout master # 切出 hotfix 分支 git checkout -b hotfix/xxx ... 进行 bug fix 提交 # master 分支合并 hotfix 分支并添加 tag(紧急版本) git checkout master git merge --no-ff hotfix/xxx --no-ff # 添加版本标记，这里可以使用版本发布日期或者具体的版本号 git tag 1.0.1 # develop 分支合并 hotfix 分支(如果此时存在 release 分支的话，应当合并到 release 分支) git checkout develop git merge --no-ff hotfix/xxx # 删除 hotfix 分支 git branch -d hotfix/xxx 至此，紧急版本发布完成。 提交信息规范 提交信息规范部分参考 Angular.js commit messgae。 git commit 格式 如下： 1&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; 各个部分的说明如下： type 类型，提交的类别 feat: 新功能 fix: 修复 bug docs: 文档变动 style: 格式调整，对代码实际运行没有改动，例如添加空行、格式化等 refactor: bug 修复和添加新功能之外的代码改动 perf: 提升性能的改动 test: 添加或修正测试代码 chore: 构建过程或辅助工具和库（如文档生成）的更改 scope 修改范围 主要是这次修改涉及到的部分，简单概括，例如 login、train-order subject 修改的描述 具体的修改描述信息 范例 feat(detail): 详情页修改样式 fix(login): 登录页面错误处理 test(list): 列表页添加测试代码这里对提交规范加几点说明： 1. type + scope 能够控制每笔提交改动的文件尽可能少且集中，避免一次很多文件改动或者多个改动合成一笔。 2. subject 对于大部分国内项目而已，如果团队整体英文不是较高水平，比较推荐使用中文，方便阅读和检索。 3. 避免重复的提交信息，如果发现上一笔提交没改完整，可以使用 git commit --amend 指令追加改动，尽量避免重复的提交信息。","categories":[{"name":"Git学习","slug":"Git学习","permalink":"http://www.dwlblog.网址/categories/Git%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.dwlblog.网址/tags/Git/"}]},{"title":"Go语言-面向对象三大特性","slug":"面向对象-2-三大特性","date":"2020-06-16T07:47:57.000Z","updated":"2020-06-16T08:00:18.105Z","comments":true,"path":"2020/06/16/面向对象-2-三大特性/","link":"","permalink":"http://www.dwlblog.网址/2020/06/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-2-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/","excerpt":"","text":"一 面向对象三大特性1.1 封装封装：把抽象出的字段和对字段的操作封装在一起,数据被保护在内部,程序的其它包只有通过被授权的操作(方法),才能对字段进行修改，其作用有： 隐藏实现细节 可以对数据进行验证，保证安全合理 Golang对面向对象做了极大简化，并不强调封装特性，下列示例进行模拟实现： 在person包下新建person.go文件： 123456789101112131415161718192021222324252627package personimport \"fmt\"type person struct &#123; Name string age int //年龄是隐私，不允许其他包访问&#125;//工厂函数（类似构造函数）func NewPerson(name string) *person &#123; return &amp;person&#123; Name: name, &#125;&#125;func (p *person) SetAge(age int) &#123; if age &gt; 0 &amp;&amp; age &lt; 150 &#123; //校验 p.age = age &#125; else &#123; fmt.Println(\"年龄不合法\") &#125;&#125;func (p *person) GetAge() int &#123; return p.age&#125; main.go文件操作person： 123456789101112package mainimport ( \"demo/person\" // demo是go mod模式下，整体项目名 \"fmt\")func main() &#123; p := person.NewPerson(\"Tom\") p.SetAge(18) fmt.Println(p)&#125; 1.2 继承在 Golang 中，如果一个 struct 嵌套了另一个匿名结构体，那么这个结构体可以直接访 问匿名结构体的字段和方法，从而实现了继承特性。 1234567891011121314151617181920212223242526272829303132package mainimport ( \"fmt\")type Father struct &#123; Name string age int&#125;func (f *Father) run() &#123; fmt.Println(f.Name + \" like running...\")&#125;type Son struct &#123; Father //嵌套匿名结构体&#125;func main() &#123; var s Son //s.Father.Name = \"Tom\" //s.Father.age = 10 //可以访问未导出属性 //s.Father.run() //可以访问未导出方法 //上述可以简写为： s.Name = \"Tom\" s.age = 10 s.run()&#125; 注意： 当结构体和匿名结构体有相同的字段或者方法时，编译器采用就近访问原则访问，如果希望访问匿名结构体的字段和方法，可以通过匿名结构体名来区分。 结构体嵌入多个匿名结构体，如果两个匿名结构体有相同的字段和方法(同时结构体本身没有同名的字段和方法)，访问时必须明确指定匿名结构体名字，否则编译报错。 如果一个 struct 嵌套了一个有名结构体，这种模式就是组合，如果是组合关系，那么在访问组合的结构体的字段或方法时，必须带上结构体的名字。 关于多重继承：如果一个 struct 嵌套了多个匿名结构体，那么该结构体可以直接访问嵌套的匿名结构体的字段和方法，从而实现多重继承。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( \"fmt\")type Father1 struct &#123; Name string age int&#125;func (f *Father1) run() &#123; fmt.Println(f.Name + \" like running...\")&#125;type Father2 struct &#123; Like string&#125;type Son1 struct &#123; Father1 Father2&#125;type Son2 struct &#123; *Father1 *Father2&#125;func main() &#123; s1 := &amp;Son1 &#123; Father1&#123; Name: \"Tom\", age: 10, &#125;, Father2&#123; Like: \"伏特加\", &#125;, &#125; fmt.Println(s1) s2 := &amp;Son2&#123; &amp;Father1&#123; Name: \"Tom\", age: 10, &#125;, &amp;Father2&#123; Like: \"伏特加\", &#125;, &#125; fmt.Println(s2.Father1)&#125; 输出结果： 12&amp;&#123;&#123;Tom 10&#125; &#123;伏特加&#125;&#125;&amp;&#123;Tom 10&#125; 1.3 多态多态与接口（interface）有关联，参见接口章节","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-面向对象基础","slug":"面向对象-1-构造函数与方法","date":"2020-06-16T07:46:57.000Z","updated":"2020-06-16T08:00:06.547Z","comments":true,"path":"2020/06/16/面向对象-1-构造函数与方法/","link":"","permalink":"http://www.dwlblog.网址/2020/06/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95/","excerpt":"","text":"一 面向对象初识1.1 模拟构造函数Go和传统的面向对象语言如Java有着很大区别。结构体没有构造函数初始化功能，可以通过以下方式模拟： 1234567891011121314151617181920212223242526272829package mainimport ( \"fmt\")type Person struct &#123; Name string Age int&#125;func NewPersonByName(name string) *Person &#123; return &amp;Person&#123; Name: name, &#125;&#125;func NewPersonByAge(age int) *Person &#123; return &amp;Person&#123; Age: age, &#125;&#125;func main() &#123; p := NewPersonByName(\"zs\") fmt.Println(p) // &#123;zs 0&#125;&#125; 贴士：因为Go没有函数重载，为了避免函数名字冲突，使用了NewPersonByName和NewPersonByAge两个不同的函数表示不同的Person构造过程。 1.2 父子关系结构体初始化Person可以看做父类，Student是子类，子类需要继承父类的成员： 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"fmt\")type Person struct &#123; Name string Age int&#125;type Student struct &#123; Person ClassName string&#125;//构造父类func NewPerson(name string, age int) *Person &#123; return &amp;Person&#123; Name: name, Age: age, &#125;&#125;//构造子类func NewStudent(classname string) *Student &#123; p := &amp;Student&#123;&#125; p.ClassName = classname return p&#125;func main() &#123; s := NewStudent(\"一班\") fmt.Println(s) // &amp;&#123;&#123; 0&#125; 一班&#125;&#125; 1.3 Go中的面向对象初识在Go中，可以给任意类型（除了指针）添加相应方法： 12345678910type Interger intfunc (i Interger) Less (j Interger) bool &#123; return i &lt; j&#125;func main() &#123; var i Interger = 1 fmt.Print(i.Less(5))&#125; 二 方法2.1 方法Golang 中的方法是作用在指定的数据类型上的(即:和指定的数据类型绑定)，因此自定义类型，都可以有方法，而不仅仅是 struct。 方法的声明和调用： 1234func (recevier type) methodName(参数列表) (返回值列表)&#123; //方法体 return 返回值&#125; 方法与函数的示例： 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"fmt\")type Person struct &#123; Name string Age int&#125;// 一个run函数func run(p *Person, name string) &#123; p.Name = name fmt.Println(\"函数 run...\", p.Name)&#125;// 一个run方法func (p *Person)run() &#123; fmt.Println(\"方法 run...\", p.Name)&#125;func main() &#123; // 实例化一个对象（结构体） p1 := &amp;Person&#123; \"ruyue\", 10, &#125; // 执行一个普通方法 run(p1, \"张三\") // 输出 函数 run... 张三 // 执行方法 p1.run() // 输出 方法 run... 张三&#125; 2.2 Go方法本质Go的方法是一种作用于特定类型变量的函数，这种特定类型的变量叫做接收器（Receiver）。如果特定类型理解为结构体或者“类”时，接收器就类似于其他语言的this或者self。 在Go中，接收器可以是任何类型，不仅仅是结构体，依此我们看出，Go中的方法和其他语言的方法类似，但是Go语言的接收器强调方法的作用对象是实例。 方法与函数的区别就是：函数没有作用对象。 上述Person案例中，接收器类型是*Person，属于指针类型，非常接近Java中的this，由于指针的特性，调用方法时，修改接收器指针的任意长远变量，在方法结束后，修改都是有效的。 当方法作用于非指针接收器时，Go语言会在代码运行时将接收器的值复制一份，在非指针接收器的方法中可以获取接收器的成员值，但修改后无效，如下所示： 12345678910111213141516171819202122232425262728package mainimport \"fmt\"//定义一个表示点的结构体type Point struct &#123; X int Y int&#125;//非指针接收器func (p Point) Add(otherP Point) Point &#123; return Point&#123; p.X + otherP.X, p.Y + otherP.Y, &#125;&#125;func main() &#123; p1 := Point&#123;1, 1&#125; p2 := Point&#123;2, 2&#125; result := p1.Add(p2) fmt.Println(result) // &#123;3 3&#125;&#125; 一般情况下，小对象由于复制时速度较快，适合使用非指针接收器，大对象因为复制性能较低，适合使用指针接收器，此时再接收器和参数之间传递时不进行复制，只传递指针。","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-数组","slug":"值类型-3-数组","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-16T08:03:12.447Z","comments":true,"path":"2020/06/16/值类型-3-数组/","link":"","permalink":"http://www.dwlblog.网址/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-3-%E6%95%B0%E7%BB%84/","excerpt":"","text":"一 数组1.1 数组的声明数组是一段固定长度的连续内存区域。数组的长度定义后不可更改，长度使用 len() 获取。 123456var arr1 [10]int //定义长度为10的整型数组，很少这样使用arr2 [5]int := [5]int&#123;1,2,3,4,5&#125; //定义并初始化arr3 := [5]int&#123;1,2,3,4,5&#125; //自动推导并初始化arr4 := [5]int&#123;1,2&#125; //指定总长度，前几位被初始化，没有的使用零值arr5 := [5]int&#123;2:10, 4:11&#125; //有选择的初始化，没被初始化的使用零值arr6 := [...]int&#123;2,3,4&#125; //自动计算长度 1.2 数组常用操作1234arr[:] 代表所有元素arr[:5] 代表前五个元素，即区间的左闭右开arr[5:] 代表从第5个开始（不包含第5个）len(arr) 数组的长度 贴士：上述操作会引发类型的变化，数组将会转化为Go中新的数据类型slice，见09节 1.3 数组的遍历方式一：for循环遍历 12345arr := [3]int&#123;1,2,3&#125;for i := 0; i &lt; len(arr); i++ &#123; fmt.Println(arr[i])&#125; 方式二：for-range遍历 123456arr := [3]int&#123;1,2,3&#125;for k, v := range arr &#123; fmt.Println(k) //元素位置 fmt.Println(v) //元素值&#125; 1.4 数组使用注意事项数组创建完长度就固定，不可以再追加元素； 长度是数组类型的一部分，因此[3]int与[4]int是不同的类型； 数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该函数的副本，而不是他的指针。","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-函数1","slug":"函数-1-函数简介","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-16T07:57:49.383Z","comments":true,"path":"2020/06/16/函数-1-函数简介/","link":"","permalink":"http://www.dwlblog.网址/2020/06/16/%E5%87%BD%E6%95%B0-1-%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B/","excerpt":"","text":"一 函数1.1 函数声明函数声明格式： 1234func 函数名字 (参数列表) (返回值列表）&#123; // 函数体 return 返回值列表&#125; 注意： 函数名首字母小写为私有，大写为公有； 参数列表可以有0-多个，多参数使用逗号分隔，不支持默认参数； 返回值列表返回值类型可以不用写变量名 如果只有一个返回值且不声明类型，可以省略返回值列表与括号 如果有返回值，函数内必须有return Go中函数常见写法： 123456789101112131415161718192021222324//无返回值，默认返回0，所以也可以写为 func fn() int &#123;&#125;func fn()&#123;&#125; //Go推荐给函数返回值起一个变量名func fn1() (result int) &#123; return 1&#125;//第二种返回值写法func fn2() (result int) &#123; result = 1 return &#125;//多返回值情func fn3() (int, int, int) &#123; return 1,2,3&#125;//Go返回值推荐多返回值写法：func fn4() (a int, b int, c int) &#123; 多个参数类型如果相同，可以简写为： a,b int a , b, c = 1, 2, 3 return &#125; 1.2 值传递和引用传递不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝决定拷贝的 数据大小，数据越大，效率越低。 如果希望函数内的变量能修改函数外的变量，可以传入变量的地址&amp;，函数内以指针的方式操作变量。 1.3 可变参数可变参数变量是一个包含所有参数的切片。如果要在多个可变参数中传递参数 ，可以在传递时在可变参数变量中默认添 加“ …”，将切片中的元素进行传递，而不是传递可变参数变量本身。 示例：对可变参数列表进行遍历 1234567891011func joinStrings(slist ...string) string &#123; var buf bytes.Buffer for _, s := range slist &#123; buf.WriteString(s) &#125; return buf.String()&#125;func main() &#123; fmt.Println(joinStrings(\"pig\", \" and\", \" bird\"))&#125; 示例：参数传递 12345678910111213141516// 实际打印函数func rawPrint(rawList ...interface&#123;&#125;) &#123; for _, a := range rawList &#123; fmt.Println(a) &#125;&#125;// 封装打印函数func print(slist ...interface&#123;&#125;) &#123; // 将slist可变参数切片完整传递给下一个函数 rawPrint(slist...)&#125;func main() &#123; print(1,2,3)&#125; 1.4 匿名函数匿名函数可以看做函数字面量，所有直接使用函数类型变量的地方都可以由匿名函数代替。匿名函数可以直接赋值给函数变量，可以当做实参，也可以作为返回值使用，还可以直接被调用。 1234567891011121314151617181920212223242526func main() &#123; a := 3 f1 := func(num int) &#123; // f1 即为匿名函数 fmt.Println(num) // 匿名函数访问外部变量 &#125; f1(a) func() &#123; // 匿名函数自调 fmt.Println(a) &#125;()&#125;//匿名函数实战：取最大值,最小值x, y := func(i,j int) (max,min int) &#123; if i &gt; j &#123; max = i min = j &#125; else &#123; max = j min = i &#125; return&#125;(10,20)fmt.Println(x + ' ' + y) 1.5 函数类型函数去掉函数名、参数名和{}后的结果即是函数类型，可以使用%T打印该结果。 两个函数类型相同的前提是：拥有相同的形参列表和返回值列表，且列表元素的次序、类型都相同，形参名可以不同。 示例： 123456789101112131415func mathSum(a, b int) int &#123; return a + b&#125;func mathSub(a, b int) int &#123; return a - b&#125;//定义一个函数类型type MyMath func(int, int) int//定义的函数类型作为参数使用func Test(f MyMath, a , b int) int&#123; return f(a,b)&#125; 通常可以把函数类型当做一种引用类型，实际函数类型变量和函数名都可以当做指针变量，只想函数代码开始的位置，没有初始化的函数默认值是nil。 二 Go函数特性总结 支持有名称的返回值； 不支持默认值参数； 不支持重载； 不支持命名函数嵌套，匿名函数可以嵌套； Go函数从实参到形参的传递永远是值拷贝，有时函数调用后实参指向的值发生了变化，是因为参数传递的是指针的拷贝，实参是一个指针变量，传递给形参的是这个指针变量的副本，实质上仍然是值拷贝； Go函数支持不定参数； 三 两个特殊函数3.1 init函数Go语言中，除了可以在全局声明中初始化实体，也可以在init函数中初始化。init函数是一个特殊的函数，它会在包完成初始化后自动执行，执行优先级高于main函数，并且不能手动调用init函数，每一个文件有且仅有一个init函数，初始化过程会根据包的以来关系顺序单线程执行。 1234567891011package mainimport ( \"fmt\")func init() &#123; //在这里可以书写一些初始化操作 fmt.Println(\"init...\")&#125;func main() &#123; fmt.Println(\"main...\")&#125; 3.2 new函数new函数可以用来创建变量。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T： 1234p := new(int) // p 为 *int类型，只想匿名的int变量fmt.Println(*p) // \"0\"*p = 2 // 设置 int匿名变量值为2fmt.Println(*p) new函数还可以用来为结构体创建实例： 1234type file struct &#123;&#125;f := new(file) 贴士：new函数其实是语法糖，不是新概念，如下所示的两个函数其实拥有相同的行为。 12345678func newInt1() *int &#123; return new(int)&#125;func newInt2() *int &#123; var dummy int return &amp;dummy&#125; 注意：new只是一个预定义函数，并不是一个关键字，所以new也有可能会被项目定义为别的类型。 3.3 make函数make函数经常用来创建切片、Map、管道： 12m1 := map[string]int&#123;&#125;m2 := make(map[string]int, 10) 上面展示了两种map的创建方式，其不同点是第一种创建方式无法预估长度，当长度超过了当前长度时，会引起内存的拷贝！！第二种创建方式直接限定了长度，这样能有效提升性能！","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言介绍","slug":"Go简介","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-16T07:25:21.937Z","comments":true,"path":"2020/06/16/Go简介/","link":"","permalink":"http://www.dwlblog.网址/2020/06/16/Go%E7%AE%80%E4%BB%8B/","excerpt":"","text":"一 Go语言介绍Go语言是Google公司开发的一种静态、编译型语言，具备自动垃圾回收功能，原生支持并发开发。 Go的诞生是为了解决当下编程语言对并发支持不友好、编译速度慢、编程复杂这三个主要问题。 Go既拥有接近静态编译语言（如C）的安全和性能，又有接近脚本语言（如python）的开发效率，其主要特点有： 天然并发：语言层面支持并发，包括gorotuine、channel 语法优势：没有历史包袱，包含多返回值、匿名函数、defer 语言层面支持多核CPU利用 与Java相比的不同： 没有Java支持的一些面向对象思想：重载、构造函数、继承等 代码规范严格：花括号位置固定，变量名大小写代表公有私有等 支持函数式编程：匿名函数，闭包 接口非侵入式：不需要显式声明对接口的继承，实现了接口的方法即为实现了该接口类型 二 Go安装推荐使用官方的安装包直接安装，下载地址：https://golang.org/dl/ 贴士：本笔记都是基于go1.13 Win安装Go：打开Win安装包下一步下一步即可，默认安装在目录：c:\\Go Mac安装Go：打开Mac安装包下一步下一步即可，需要预装Xcode。安装完毕后需配置环境变量即可使用，但是如果要使用一些go mod功能推荐如下配置： 1234567891011vim ~&#x2F;.bash_profileexport GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go # golang本身的安装位置export GOPATH&#x3D;~&#x2F;go&#x2F; # golang包的本地安装位置export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.io # golang包的下载代理export GO111MODULE&#x3D;on # 开启go mod模式export PATH&#x3D;$PATH:$GOROOT&#x2F;bin # go本身二进制文件的环境变量export PATH&#x3D;$PATH:$GOPATH&#x2F;bin # go第三方二进制文件的环境便令# 重启环境source ~&#x2F;.bash_profile Linux安装Go： 123456789101112131415# 下载解压wget https:&#x2F;&#x2F;dl.google.com&#x2F;go&#x2F;go1.13.1.linux-amd64.tar.gztar zxvf go*.tar.gz -C &#x2F;usr&#x2F;local&#x2F;# 配置环境：注意该环境必须是go1.11版本及以上且项目要求使用go mod才可以开启vim &#x2F;etc&#x2F;profileexport GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go # golang本身的安装位置export GOPATH&#x3D;~&#x2F;go # golang包的本地安装位置export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.io,direct # golang包的下载代理,回源地址获取export GO111MODULE&#x3D;on # 开启go mod模式export PATH&#x3D;$PATH:$GOROOT&#x2F;bin # go本身二进制文件的环境变量export PATH&#x3D;$PATH:$GOPATH&#x2F;bin # go第三方二进制文件的环境便令# 重启环境source &#x2F;etc&#x2F;profile 测试安装： 12345# 查看go版本go version# 查看go环境配置go env 关于go modules的详细讲解位于本章12节。 三 HelloWorld新建文件hello.go，代码如下： 1234567package main //每个程序都有且仅有一个main包import \"fmt\" func main() &#123; //主函数main只有一个 fmt.Println(\"Hello World!\") //函数调用：包名.函数名&#125; 运行文件： 123456# 执行方式一：先编译，再运行go build hello.go # 编译。在同级目录下生成文件&#96;hello&#96;，添加参数&#96;-o 名称&#96; 则可指定生成的文件名 .&#x2F;hello # 运行。贴士：win下生成的是.exe文件，直接双击执行即可# 执行方式二：直接运行go run hello.go 两种执行流程的区别： 先编译方式：可执行文件可以在任意没有go环境的机器上运行，（因为go依赖被打包进了可执行文件） 直接执行方式：源码执行时，依赖于机器上的go环境，没有go环境无法直接运行 四 Go语法注意 Go源文件以 “go” 为扩展名 与Java、C语言类似，Go应用程序的执行入口也是main()函数 Go语言严格区分大小写 Go不需要分号结尾 Go编译是一行一行执行，所以不能将类似两个 Print 函数写在一行 Go语言定义的变量或者import的包如果没有使用到，代码不能编译通过 Go的注释使用 // 或者 /* */ 五 开发工具推荐笔者推荐的go开发工具： goland vscode vscode的相关go插件会出现无法下载情况，解决办法： 12345678910111213141516171819202122# 如果开启了go mod，则 go get -u -v github.com&#x2F;ramya-rao-a&#x2F;go-outline go get -u -v github.com&#x2F;acroca&#x2F;go-symbols go get -u -v golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;guru go get -u -v golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;gorename go get -u -v github.com&#x2F;rogpeppe&#x2F;godef go get -u -v github.com&#x2F;sqs&#x2F;goreturns go get -u -v github.com&#x2F;cweill&#x2F;gotests&#x2F;gotests go get -u -v golang.org&#x2F;x&#x2F;lint&#x2F;golint# 如果未开启go mod，则需要进入cd $GOPATH&#x2F;src ，使用 git clone 下载上述文件 # 安装cd $GOPATH go install github.com&#x2F;ramya-rao-a&#x2F;go-outline go install github.com&#x2F;acroca&#x2F;go-symbols go install golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;guru go install golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;gorename go install github.com&#x2F;rogpeppe&#x2F;godef go install github.com&#x2F;sqs&#x2F;goreturns go install github.com&#x2F;cweill&#x2F;gotests&#x2F;gotests go install golang.org&#x2F;x&#x2F;lint&#x2F;golint","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-函数2-闭包","slug":"函数-2-闭包","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-16T07:58:15.540Z","comments":true,"path":"2020/06/16/函数-2-闭包/","link":"","permalink":"http://www.dwlblog.网址/2020/06/16/%E5%87%BD%E6%95%B0-2-%E9%97%AD%E5%8C%85/","excerpt":"","text":"一 闭包1.1 闭包概念闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使己经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量。 简单的说 : 函数+引用环境=闭包 贴士：闭包( Closure)在某些编程语言中也被称为 Lambda表达式（如Java） 在闭包中可以修改引用的变量： 123456str := \"hello\"foo := func()&#123; // 声明一个匿名函数 str = \"world\"&#125;foo() // 调用匿名函数，修改str值fmt.Print(str) // world 1.2 闭包案例一 简单示例12345678910111213141516171819func fn1(a int) func(i int) int &#123; return func(i int) int &#123; print(&amp;a, a) return a &#125;&#125;func main() &#123; f := fn1(1) //输出地址 g := fn1(2) //输出地址 fmt.Println(f(1)) //输出1 fmt.Println(f(1)) //输出1 fmt.Println(g(2)) //输出2 fmt.Println(g(2)) //输出2&#125; 1.3 闭包案例二 实现累加器12345678910111213func Accumulate(value int) func() int &#123; return func() int &#123; // 返回一个闭包 value++ return value &#125;&#125;func main() &#123; accAdd := Accumulate(1) fmt.Println(accAdd()) // 2 fmt.Println(accAdd()) // 3&#125;","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-结构体","slug":"值类型-4-结构体","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-16T08:03:25.947Z","comments":true,"path":"2020/06/16/值类型-4-结构体/","link":"","permalink":"http://www.dwlblog.网址/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-4-%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"","text":"一 结构体的基本使用结构体可以用来声明新的类型，作为其他类型的属性/字段的容器，如下定义一个学生结构体： 1234567891011121314151617181920type Person struct &#123; name string age int&#125;//按顺序初始化：每个成员都必须初始化var p1 Person = Person&#123;\"lisi\", 20&#125;//制定成员初始化：没有被初始化的，自动赋零值p2 := Person&#123;age:30&#125; // new 申请结构体p3 := new(Person) //被new生成的结构体实例其实是指针类型p3.name = \"zs\" //这里的.语法只是语法糖，将p3.name转换成了(*p3).namep3.age = 27 //直接声明var s4 Personp4.name = \"ww\"p4.age = 30 贴士： struct的结构中的类型可以是任意类型，且存储空间是连续的，其字段按照声明时的顺序存放 如果结构体的所有的成员都是可以比较的，那么结构体本身也是可以比较的，使用 == != ，不支持 &gt; 和 &lt; 如果结构体的成员要被包外调用，需要大写首字母。 二 结构体地址与实例化前面说过，对结构体的new其实是生成了一个指针类型。其实对结构体进行&amp;取地址操作时，也可以视为对该类型进行一次new的实例化操作。 1234ins := &amp;T&#123;&#125;# T是结构体类型# ins为结构体的实例，类型为*T，是指针类型 四 内嵌结构体当前结构体可以直接访问其内嵌结构体的内部字段： 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport \"fmt\"type Animal struct &#123; Age int&#125;type Person struct &#123; Animal Name string&#125;type Student struct &#123; Person ClassName string&#125;func main() &#123; // 初始化方式1 s1 := Student&#123; Person&#123; Animal: Animal &#123; Age: 15, &#125;, Name:\"lisi\", &#125;, \"一班\", &#125; fmt.Println(s1.Age) // 正确输出15 fmt.Println(s1.Person.Name) // 正确输出lisi // 初始化方式2 var s2 Student s2.Name = \"zs\" s2.Age = 30 s2.ClassName = \"二班\" fmt.Println(s2.Age) // 正确输出30 fmt.Println(s2.Person.Name) // 正确输出zs&#125; 四 匿名字段结构体的字段名与类型一一对应，如果不提供名字，则为匿名字段。 匿名字段如果是一个struct，这个struct拥有的全部字段都被隐式引入了当前的struct。 123456789type Person struct &#123; name string age int&#125; type Student struct &#123; Person // 匿名字段，那么默认Student就包含了Human的所有字段 classroom string&#125; 不仅仅是struct，其他所有内置类型和自定义类型都可以作为匿名字段： 1234567891011121314151617181920212223242526272829package mainimport \"fmt\"type Person struct &#123; name string age int&#125;type course []stringtype Student struct &#123; Person // 匿名字段，struct course // 内置一个切片类型 classroom string&#125;func main() &#123; // 创建一个学生 s := Student&#123;Person:Person&#123;\"LiLei\", 17&#125;, classroom:\"二班\"&#125; // 访问该学生字段 fmt.Println(\"name = \", s.name) fmt.Println(\"classroom = \", s.classroom) // 修改学生的课程 s.course = []string&#123;\"语文\", \"美术\"&#125; fmt.Println(\"course = \", s.course) // [语文 美术]&#125; 贴士：如果Person和Student中都有同一个字段，那么Go会优先访问当前层。例如二者都有tel字段，那么s.tel将会访问的是Student中的数据。","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-常量","slug":"常量","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-16T07:56:45.297Z","comments":true,"path":"2020/06/16/常量/","link":"","permalink":"http://www.dwlblog.网址/2020/06/16/%E5%B8%B8%E9%87%8F/","excerpt":"","text":"一 常量常量：在编译阶段就确定下来的值，程序运行时无法改变。 定义方式： 123const A = 3const PI float32 = 3.1415const mask = 1 &lt;&lt; 3 //常量与表达式 错误写法：常量赋值是一个编译期行为，右边的值不能出现在运行时才能得到结果的值。 1const HOME = os.GetEnv(\"HOME\") 二 无类型常量一个常量可以有任意一个确定的基础类型，例如int或float64，但是许多常量并没有一个明确的基础类型。 无类型常量的作用： 编译器会为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算，可以认为至少有256bit的运算精度 无类型的常量可以直接用于更多的表达式而不需要显式的类型转换 示例：math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方： 123var x float32 = math.Pivar y float64 = math.Pivar z complex128 = math.Pi 如果math.Pi被确定为特定类型，比如float64，那么结果精度可能会不一样，同时对于需要float32或complex128类型值的地方则会强制需要一个明确的类型转换： 12345const Pi64 float64 = math.Pivar x float32 = float32(Pi64)var y float64 = Pi64var z complex128 = complex128(Pi64) 对于常量面值，不同的写法可能会对应不同的类型。例如0、0.0、0i和\\u0000虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，true和false也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。 前面说过除法运算符/会根据操作数的类型生成对应类型的结果。因此，不同写法的常量除法表达式可能对应不同的结果： 1234var f float64 = 212fmt.Println((f - 32) * 5 / 9) // \"100\"; (f - 32) * 5 is a float64fmt.Println(5 / 9 * (f - 32)) // \"0\"; 5/9 is an untyped integer, 0fmt.Println(5.0 / 9.0 * (f - 32)) // \"100\"; 5.0/9.0 is an untyped float 只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语句，或者出现在有明确类型的变量声明的右边，如下面的其余三行语句，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话。 1234var f float64 = 3 + 0i // untyped complex -&gt; float64f = 2 // untyped integer -&gt; float64f = 1e123 // untyped floating-point -&gt; float64f = 'a' // untyped rune -&gt; float64 上面的语句相当于: 1234var f float64 = float64(3 + 0i)f = float64(2)f = float64(1e123)f = float64('a') 无论是隐式或显式转换，将一种类型转换为另一种类型都要求目标可以表示原始值。对于浮点数和复数，可能会有舍入处理： 123456789const ( deadbeef = 0xdeadbeef // untyped int with value 3735928559 a = uint32(deadbeef) // uint32 with value 3735928559 b = float32(deadbeef) // float32 with value 3735928576 (rounded up) c = float64(deadbeef) // float64 with value 3735928559 (exact) d = int32(deadbeef) // compile error: constant overflows int32 e = float64(1e309) // compile error: constant overflows float64 f = uint(-1) // compile error: constant underflows uint) 对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型，就像下面的例子： 1234i := 0 // untyped integer; implicit int(0)r := '\\000' // untyped rune; implicit rune('\\000')f := 0.0 // untyped floating-point; implicit float64(0.0)c := 0i // untyped complex; implicit complex128(0i) 注意有一点不同：无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。如果不知道浮点数类型的内存大小是很难写出正确的数值算法的，因此Go语言不存在整型类似的不确定内存大小的浮点数和复数类型。 如果要给变量一个不同的类型，我们必须显式地将无类型的常量转化为所需的类型，或给声明的变量指定明确的类型，像下面例子这样： 12var i = int8(0)var i int8 = 0 当尝试将这些无类型的常量转为一个接口值时（见第7章），这些默认类型将显得尤为重要，因为要靠它们明确接口对应的动态类型。 1234fmt.Printf(\"%T\\n\", 0) // \"int\"fmt.Printf(\"%T\\n\", 0.0) // \"float64\"fmt.Printf(\"%T\\n\", 0i) // \"complex128\"fmt.Printf(\"%T\\n\", '\\000') // \"int32\" (rune)","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-字符串","slug":"值类型-2-字符串","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-16T08:03:00.842Z","comments":true,"path":"2020/06/16/值类型-2-字符串/","link":"","permalink":"http://www.dwlblog.网址/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-2-%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"一 字符Golang 中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存，且使用单引号包裹。 12345678var c1 byte = 'a'var c2 byte = '0'fmt.Println(\"c1=\", c1) //输出 97 fmt.Println(\"c2=\", c2) //输出48fmt.Printf(\"c1=%c,c2=%c\\n\", c1, c2) //输出原值 a 0//var c3 byte = '北'//fmt.Printf(\"c3=%c\", c3) // 溢出错误:overflows byte 贴士： 字符类型也可以用d%打印为整型 如果我们保存的字符在 ASCII 表的,比如[0-1, a-z,A-Z..]直接可以保存到 byte 如果我们保存的字符对应码值大于 255,这时我们可以考虑使用 int 类型保存 如果我们需要安装字符的方式输出，这时我们需要格式化输出，即 fmt.Printf(“%c”, c1) 字符可以和整型进行运算 二 字符串传统的字符串是由字符组成的，而Go的字符串是由单个字节连接起来的，即Go字符串是一串固定长度的字符连接起来的字符序列。 字符串在Go语言中是基本类型，内容在初始化后不能修改。 Go中的字符串都是采用UTF-8字符集编码，使用一对双引号&quot;&quot;或反引号``定义。``可以额外解析换行，即其没有字符转义功能。 12345678910var str1 stringstr1 = \"Hello \"str2 := \" World!\"fmt.Println(str1[0]) // 输出字符串第一个字符 72fmt.Println(len(str1)) // 输出长度 6fmt.Println(str1 + str2) // 输出不带空格的// 字符串不可变，编译报错： cannot assign to 因为// str1[0] = 'c' 由于Go中的字符串不可直接改变，可以使用下列两种方式进行修改： 方式一：通过转换为字节数组[]byte类型，构造一个临时字符串 12345678str := \"hello\"strTemp := []byte(str)fmt.Println(\"strTemp=\", strTemp) // [104 101 108 108 111]strTemp[0] = 'c'strResult := string(strTemp)fmt.Println(\"strResult=\", strResult) // strResult= cello 方式二：使用切片 12str := \"hello\"str = \"c\"+ str[1:] // 1: 表示从第1位开始到最后 Go和Java等语言一样，字符串默认是不可变的，这样保证了线程安全，大家使用的都是只读对象，无须加锁，且能很方便的共享内存，不必使用写时复制。 三 字符串常用操作3.1 len()函数与字符串遍历len()函数是go语言的内建函数，可以用来获取字符串、切片、通道等的长度。 12345678910111213141516package mainimport ( \"fmt\" \"unicode/utf8\")func main() &#123; str1 := \"hello world\" str2 := \"你好，\" fmt.Println(len(str1)) // 11 fmt.Println(len(str2)) // 9 fmt.Println(utf8.RuneCountInString(str2)) // 3&#125; 第一个函数输出11很容易理解，第二个函数却输出了9，理论上我们会认为应该是3才对。这是因为Go的字符串都是以UTF-8格式保存，每个中文占据3个字节。Go中计算UTF-8字符串格式的长度应该使用utf8.RuneCountInString。 字符串遍历方式一：使用字节数组，注意每个中文在UTF-8中占据3个字节 1234str := \"hello\"for i := 0; i &lt; len(str); i++ &#123; fmt.Println(i,str[i])&#125; 字符串遍历方式二：range关键字只是第一种遍历方式的简写 1234str := \"你好\"for i,ch := range str &#123; fmt.Println(i,ch)&#125; 注意：由于上述len()函数本身原因，Unicode字符遍历需要使用range。 3.2 string()函数类型转换go的内建函数 string()可以将其他类型转变为字符串类型： 12num := 12fmt.Printf(\"%T \\n\", string(num)) // string 3.3 字符串连接使用+能够连接字符串。但是该操作并不高效（因为字符串在Go中是基本类型，每次拼接都是拷贝了内存！）。Go1.10提供了类似Java的StringBuilder机制来进行高效字符串连接： 1234567891011121314151617181920212223package mainimport ( \"bytes\" \"fmt\")func main() &#123; str1 := \"hello \" str2 := \" world\" //创建字节缓冲 var stringBuilder bytes.Buffer //把字符串写入缓冲 stringBuilder.WriteString(str1) stringBuilder.WriteString(str2) //将缓冲以字符串形式输出 fmt.Println(stringBuilder.String())&#125; 在1.10版本前，可以使用bytes.Buffer拼接字符串（因为字符串其实是字节数组）： 123var buf bytes.Bufferbuf.WriteString(\"hello\")fmt.Println(buf.String()) 四 strings包相关函数strings包提供了字符串的一些常见操作函数： 1234567891011121314151617181920//查找s在字符串str中的索引Index(str, s string) int //判断str是否包含sContains(str, s string) bool//通过字符串str连接切片 sJoin(s []string, str string) string//替换字符串str中old字符串为new字符串，n表示替换的次数，小于0全部替换Replace(str,old,new string,n int) string//字符串str按照s分割，返回切片Splite(str,s string)[]string// 去除头部、尾部指定的字符串Trim(s string, cutset string) string// 去除空格，返回切片Fields(s string) []string 五 strconv包的字符串转换函数在Java中遇到 &quot;你好&quot; + 123会将 +转变为连接符。而Go语言要求 + 号两边数据的数据类型必须一致，这使得类似的操作变得比较不便，Go提供了strconv包用于字符串与基本类型之间的转换，常用函数有Append、Format、Parse。 123456789101112131415161718192021222324252627282930313233package mainimport ( \"fmt\" \"strconv\")func main() &#123; // Append 系列函数将整数等转换为字符串后，添加到现有的字节数组中 str1 := make([]byte, 0, 100) str1 = strconv.AppendInt(str1, 4567, 10) str1 = strconv.AppendBool(str1, false) str1 = strconv.AppendQuote(str1, \"abcdefg\") str1 = strconv.AppendQuoteRune(str1, '单') fmt.Println(string(str1)) // 4567false\"abcdefg\"'单' // Format 系列函数把其他类型的转换为字符串 a := strconv.FormatBool(false) b := strconv.FormatFloat(123.23, 'g', 12, 64) c := strconv.FormatInt(1234, 10) d := strconv.FormatUint(12345, 10) e := strconv.Itoa(1023) fmt.Println(a, b, c, d, e) // false 123.23 1234 12345 1023 // Parse 系列函数把字符串转换为其他类型 f, _ := strconv.ParseBool(\"false\") g, _ := strconv.ParseFloat(\"123.23\", 64) h, _ := strconv.ParseInt(\"1234\", 10, 64) i, _ := strconv.ParseUint(\"12345\", 10, 64) j, _ := strconv.Atoi(\"1023\") fmt.Println(f, g, h, j, i, j) // false 123.23 1234 1023 12345 1023&#125;","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-切片","slug":"引用类型-1-切片","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-16T08:01:55.772Z","comments":true,"path":"2020/06/16/引用类型-1-切片/","link":"","permalink":"http://www.dwlblog.网址/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-1-%E5%88%87%E7%89%87/","excerpt":"","text":"一 切片创建切片(slice)解决了数组长度不能扩展，以及基本类型数组传递时产生副本的问题。 常用创建方式： 1234var s1 []int // 和声明数组一样，只是没有长度，但是这样做没有意义，因为底层的数组指针为nils2 := []byte &#123;'a','b','c'&#125;fmt.Println(s1) //输出 []fmt.Print(s2) //输出 [97 98 99] 使用make函数创建： 123slice1 := make([]int,5) // 创建长度为5，容量为5，初始值为0的切片slice2 := make([]int,5,7) // 创建长度为5，容量为7，初始值为0的切片slice3 := []int&#123;1,2,3,4,5&#125; // 创建长度为5，容量为5，并已经初始化的切片 从数组创建：slice可以从一个数组再次声明。slice通过array[i:j]来获取，其中i是数组的开始位置，j是结束位置，但不包含array[j]，它的长度是j-i: 12345678910// 声明一个含有10个元素元素类型为byte的数组var arr = [10]byte &#123;'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'&#125;// 声明两个含有byte的slicear a, b []byte// a指向数组的第3个元素开始，并到第五个元素结束，现在a含有的元素: ar[2]、ar[3]和ar[4]a = arr[2:5] // b是数组arr的另一个slicre,b的元素是：ar[3]和ar[4]b = arr[3:5] 注意：声明数组时，方括号内写明了数组的长度或使用…自动计算长度，而声明slice时，方括号内没有任何字符。 从切片创建： 12oldSlice := []int&#123;1,2,3&#125;newSlice := oldSlice[:6] //基于切片前6个元素创建，没有的默认0 注意：如果选择的旧切片长度超出了旧切片的cap()值（切片存储长度），则不合法。 二 切片常见操作2.1 切片常见内置函数切片常用内置函数： 12345len() 返回切片长度cap() 返回切片底层数组容量append() 对切片追加元素func copy(dst, src []Type) int 将src中数据拷贝到dst中，返回拷贝的元素个数 切片空间与元素个数： 1234slice1 := make([]int, 5, 10)fmt.Println(len(slice1)) // 5fmt.Println(cap(slice1)) // 10fmt.Println(slice1) // [0 0 0 0 0] 切片操作 1234567891011121314151617181920212223242526272829//切片增加slice1 = append(slice1,1,2)fmt.Println(slice1) //输出[0 0 0 0 0 1 2]//切片增加一个新切片sliceTemp := make([]int,3)slice1 = append(slice1,sliceTemp...)fmt.Println(slice1) //输出[0 0 0 0 0 1 2 0 0 0]//切片拷贝s1 := []int&#123;1,3,6,9&#125;s2 := make([]int, 10) //必须给与充足的空间num := copy(s2, s1)fmt.Println(s1) //[1 3 6 9]fmt.Println(s2) //[1 3 6 9 0 0 0 0 0 0]fmt.Println(num) //4//切片中删除元素s1 := []int&#123;1,3,6,9&#125;index := 2 //删除该位置元素s1 = append(s1[:index], s1[index+1:]...)fmt.Println(s1) //[1 3 9]// 切片拷贝s1 := []int&#123;1,2,3,4,5&#125;s2 := []int&#123;6,7,8&#125;copy(s1,s2) //复制s2前三个元素到slice1前3位置copy(s2,s1) //复制s1前三个元素到slice2 注意：没有…会编译错误，默认第二个参数后是元素值，传入切片需要展开。如果追加的长度超过当前已分配的存储空间，切片会自动分配更大的内存。 2.2 切片的一些简便操作 slice的默认开始位置是0，ar[:n]等价于ar[0:n] slice的第二个序列默认是数组的长度，ar[n:]等价于ar[n:len(ar)] 如果从一个数组里面直接获取slice，可以这样ar[:]，因为默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)] 切片的遍历可以使用for循环，也可以使用range函数 123456789101112131415161718192021222324252627282930313233// 声明一个数组var array = [10]byte&#123;'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'&#125;// 声明两个slicevar aSlice, bSlice []byte// 演示一些简便操作aSlice = array[:3] // 等价于aSlice = array[0:3] aSlice包含元素: a,b,caSlice = array[5:] // 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,jaSlice = array[:] // 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素// 从slice中获取sliceaSlice = array[3:7] // aSlice包含元素: d,e,f,g，len=4，cap=7bSlice = aSlice[1:3] // bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,fbSlice = aSlice[:3] // bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,fbSlice = aSlice[0:5] // 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,hbSlice = aSlice[:] // bSlice包含所有aSlice的元素: d,e,f,g``` #### 2.3 切片的截取- `s[n]`：切片s中索引为位置为n的项- `s[:]`：从切片s的索引位置0到`len(s)-1`所获得的切片- `s[low:]`：从切片s的索引位置low到`len(s)-1`所获得的切片- `s[:high]`：从切片s的索引位置0到high所获得的切片- `s[low:high]`：从切片s的索引位置low到high所获得的切片- `s[low:high:max]`：从low到high的切片，且容量`cap=max-low`#### 1.7 字符串转切片 ```gostr := \"hello,世界\"a := []byte(str) //字符串转换为[]byte类型切片b := []rune(str) //字符串转换为[]rune类型切片 三 切片存储结构与数组相比，切片多了一个存储能力值的概念，即元素个数与分配空间可以是两个不同的值，其结构如下所示： 12345type slice struct &#123; arrary = unsafe.Pointer //指向底层数组的指针 len int //切片元素数量 cap int //底层数组的容量&#125; 所以切片通过内部的指针和相关属性引用数组片段，实现了变长方案，Slice并不是真正意义上的动态数组。 合理设置存储能力，可以大幅提升性能，比如知道最多元素个数为50，那么提前设置为50，而不是先设为30，可以明显减少重新分配内存的操作。 四 切片作为函数参数1234567891011121314func test(s []int) &#123; fmt.Printf(\"test---%p\\n\", s) // 打印与main函数相同的地址 s = append(s, 1, 2, 3, 4, 5) fmt.Printf(\"test---%p\\n\", s) // 一旦append的数据超过切片长度，则会打印新地址 fmt.Println(\"test---\", s) // [0 0 0 1 2 3 4 5]&#125;func main() &#123; s1 := make([]int, 3) test(s1) fmt.Printf(\"main---%p\\n\", s1) // 不会因为test函数内的append而改变 fmt.Println(\"main---\", s1) // [ 0 0 0]&#125;","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-集合map","slug":"引用类型-2-集合","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-16T08:02:07.470Z","comments":true,"path":"2020/06/16/引用类型-2-集合/","link":"","permalink":"http://www.dwlblog.网址/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-2-%E9%9B%86%E5%90%88/","excerpt":"","text":"一 集合map1.1 map的创建Go内置了map类型，map是一个无序键值对集合（也有一些书籍翻译为字典）。 普通创建： 123// 声明一个map类型，[]内的类型指任意可以进行比较的类型 int指值类型m := map[string]int&#123;\"a\":1,\"b\":2&#125;fmt.Print(m[\"a\"]) make方式创建map： 123456789101112131415type Person struct&#123; ID string Name string&#125;func main() &#123; var m map[string] Person m = make(map[string] Person) m[\"123\"] = Person&#123;\"123\",\"Tom\"&#125; p,isFind := m[\"123\"] fmt.Println(isFind) //true fmt.Println(p) //&#123;123 Tom&#125;&#125; 注意：golang中map的 key 通常 key 为 int 、string，但也可以是其他类型如：bool、数字、string、指针、channel，还可以是只包含前面几个类型的接口、结构体、数组。slice、map、function由于不能使用 == 来判断，不能作为map的key。 1.2 map的使用通过key操作元素： 12345678var numbers map[string]intnumbers = make(map[string]int)numbers[\"one\"] = 1 //赋值numbers[\"ten\"] = 10 //赋值numbers[\"three\"] = 3delete(numbers, \"ten\") // 删除key为 ten 的元素fmt.Println(\"第三个数字是: \", numbers[\"three\"]) // 读取数据 map的遍历：同数组一样，使用for-range 的结构遍历 注意： map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取； map的长度是不固定的，也就是和slice一样，也是一种引用类型 内置的len函数同样适用于map，返回map拥有的key的数量 go没有提供清空元素的方法，可以重新make一个新的map，不用担心垃圾回收的效率，因为go中并行垃圾回收效率比写一个清空函数高效很多 map和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制 1.3 并发安全的map演示并发读写map的问题： 1234567891011121314151617181920package mainfunc main() &#123; m := make(map[int]int) go func() &#123; for &#123; //无限写入 m[1] = 1 &#125; &#125;() go func() &#123; for &#123; //无限读取 _ = m[1] &#125; &#125;() for &#123;&#125; //无限循环，让并发程序在后台执行&#125; 编译会有错误提示：fatal error: concurrent map read and map write，即出现了并发读写，因为用两个并发程序不断的对map进行读和写，产生了竞态问题。map内部会对这种错误进行检查并提前发现。 Go内置的map只有读是线程安全的，读写是线程不安全的。 需要并发读写时，一般都是加锁，但是这样做性能不高，在go1.9版本中提供了更高效并发安全的sync.Map。 sync.Map的特点： 无须初始化，直接声明即可 sync.Map不能使用map的方式进行取值和设值操作，而是使用sync.Map的方法进行调用。Store表示存储，Load表示获取，Delete表示删除。 使用Range配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，需要继续迭代时，返回true，终止迭代返回false。 12345678910111213141516171819202122232425package mainimport ( \"fmt\" \"sync\")func main() &#123; var scene sync.Map //保存键值对 scene.Store(\"id\",1) scene.Store(\"name\",\"lisi\") //根据键取值 fmt.Println(scene.Load(\"name\")) //遍历 scene.Range(func(k, v interface&#123;&#125;) bool&#123; fmt.Println(k,v) return true &#125;)&#125; 注意：map没有提供获取map数量的方法，可以在遍历时手动计算。sync.Map为了并发安全。损失了一定的性能。","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-指针","slug":"引用类型-3-指针","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-16T08:02:20.361Z","comments":true,"path":"2020/06/16/引用类型-3-指针/","link":"","permalink":"http://www.dwlblog.网址/2020/06/16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-3-%E6%8C%87%E9%92%88/","excerpt":"","text":"一 指针1.1 指针的创建Go保留了指针，代表某个内存地址，默认值为 nil ，使用 &amp; 取变量地址，通过 * 访问目标对象。 简单示例： 12345var a int = 10fmt.Println(\"&amp;a=\", &amp;a) // 0xc000096008 一个十六进制数var p *int = &amp;afmt.Println(\"*p=\", *p) // 10 注意： Go同样支持多级指针，如 **T 空指针：声明但未初始化的指针 野指针：引用了无效地址的指针，如：var p *int = 0，var p *int = 0xff00(超出范围) Go中直接使用.访问目标成员 1.2 指针使用示例：实现变量值交换123func swap(p1,p2 *int) &#123;*p1,*p2 = *p2,*p1&#125; 1.3 结构体指针示例： 1234567891011121314type User struct&#123; name string age int&#125;func main() &#123; var u = User&#123; name:\"lisi\", age: 18, &#125; p := &amp;u fmt.Println(u.name) //输出李四 fmt.Println(p.name) //输出李四&#125; 1.4 Go不支持指针运算由于垃圾回收机制的存在，指针运算造成许多困扰，所以Go直接禁止了指针运算 123a := 1p := &amp;ap++ //报错：non-numeric type *int 1.5 new()函数使用new()函数可以在 heap堆 区申请一片内存地址空间： 123var p *boolp = new(bool)fmt.Println(*p) // false","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-数值类型","slug":"值类型-1-数值类型","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-16T08:02:46.164Z","comments":true,"path":"2020/06/16/值类型-1-数值类型/","link":"","permalink":"http://www.dwlblog.网址/2020/06/16/%E5%80%BC%E7%B1%BB%E5%9E%8B-1-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"一 数值类型数值类型指基本类型中的：整型、浮点型、复数。 二 整数整数类型有无符号(如int)和带符号(如uint)两种，这两种类型的长度相同，但具体长度取决于不同编译器的实现。 int8、int16、int32和int64四种有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，同样uint8、uint16、uint32和uint64对应四种无符号整数类型。 有符号类型： 123456int 32位系统占4字节（与int32范围一样），64位系统占8个节（与int64范围一样） int8 占据1字节 范围 -128 ~ 127int16 占据2字节 范围 -2(15次方) ~ 2（15次方）-1int32 占据4字节 范围 -2(31次方) ~ 2（31次方）-1int64 占据8字节 范围 -2(63次方) ~ 2（63次方）-1rune int32的别称 无符号类型： 123456uint 32位系统占4字节（与uint32范围一样），64位系统占8字节（与uint64范围一样） uint8 占据1字节 范围 0 ~ 255uint16 占据2字节 范围 0 ~ 2（16次方）-1uint32 占据4字节 范围 0 ~ 2（32次方）-1uint64 占据8字节 范围 0 ~ 2（64次方）-1byte uint8的别称 注意： 上述类型的变量由于是不同类型，不允许互相赋值或操作 Go默认的整型类型是int 查看数据所占据的字节数方法：unsafe.Sizeof() 三 浮点类型3.1 浮点类型的分类12float32 单精度 占据4字节 范围 -3.403E38 ~ 3.403E38 (math.MaxFloat32)float64 双精度 占据8字节 范围 -1.798E208 ~ 1.798E308 (math.MaxFloat64) 由上看出： 浮点数是有符号的，浮点数在机器中存放形式是：浮点数=符号位+指数位+尾数位 浮点型的范围是固定的，不受操作系统限制 .512 这样数可以识别为 0.512 科学计数法： 5.12E2 = 5.12 * 102 5.12E-2 = 5.12 / 102 3.2 精度损失float32可以提供大约6个十进制数的精度，float64大约可以提供15个十进制的精度（一般选择float64） 1234var num1 float32 = -123.0000901var num2 float64 = -123.0000901 fmt.Println(\"num1=\",num1) // -123.00009fmt.Println(\"num2=\",num2) // -123.0000901 3.3 浮点数判断相等使用 == 号判断浮点数，是不可行的，替代方案如下： 1234func isEqual(f1,f2,p float64) bool &#123; // p为用户自定义精度，如：0.00001 return math.Abs(f1-f2) &lt; p &#125; 四 复数Go中复数默认类型是complex128（64位实数+64位虚数）。如果需要小一些的，也有complex64(32位实数+32位虚数)。 复数的形式为RE + IMi，其中RE是实数部分，IM是虚数部分，而最后的i是虚数单位。 如下所示： 12345var t complex128t = 2.1 + 3.14it1 = complex(2.1,3.14) // 结果同上 fmt.Println(real(t)) // 实部：2.1fmt.Println(imag(t)) // 虚部：3.14 五 NaN非数go中的NaN非数： 123var z float64// 输出 \"0 -0 +Inf -Inf NaN\"fmt.Println(z, -z, 1/z, -1/z, z/z) 注意： 函数math.IsNaN用于测试一个数是否是非数NaN， 函数math.NaN则返回非数对应的值。 虽然可以用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等的。 123nan := math.NaN()// \"false false false\"fmt.Println(nan == nan, nan &lt; nan, nan &gt; nan)","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-数据类型","slug":"数据类型","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-16T08:00:42.575Z","comments":true,"path":"2020/06/16/数据类型/","link":"","permalink":"http://www.dwlblog.网址/2020/06/16/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"一 数据类型分类值类型：基本数据类型是Go语言实际的原子，复合数据类型是由不同的方式组合基本类型构造出来的数据类型，如：数组，slice，map，结构体 1234567整型 int8,uint # 基础类型之数字类型浮点型 float32，float64 # 基础类型之数字类型复数 # 基础类型之数字类型布尔型 bool # 基础类型，只能存true&#x2F;false，占据1个字节，不能转换为整型，0和1也不能转换为布尔字符串 string # 基础类型数组 # 复合类型 结构体 struct # 复合类型 引用类型：即保存的是对程序中一个变量的或状态的间接引用，对其修改将影响所有该引用的拷贝 123456指针 *切片 slice字典 map函数 func管道 chan接口 interface 贴士：Go语言没有字符型，可以使用byte来保存单个字母 二 零值机制Go变量初始化会自带默认值，不像其他语言为空，下面列出各种数据类型对应的0值： 1234567891011int 0int8 0int32 0int64 0uint 0x0rune 0 //rune的实际类型是 int32byte 0x0 // byte的实际类型是 uint8float32 0 //长度为 4 bytefloat64 0 //长度为 8 bytebool falsestring \"\" 三 格式化输出常用格式化输出： 12345678910111213141516171819%% %字面量%b 二进制整数值，基数为2，或者是一个科学记数法表示的指数为2的浮点数%c 该值对应的unicode字符%d 十进制数值，基数为10%e 科学记数法e表示的浮点或者复数%E 科学记数法E表示的浮点或者附属%f 标准计数法表示的浮点或者附属%o 8进制度%p 十六进制表示的一个地址值%s 输出字符串或字节数组%T 输出值的类型，注意int32和int是两种不同的类型，编译器不会自动转换，需要类型转换。%v 值的默认格式表示%+v 类似%v，但输出结构体时会添加字段名%#v 值的Go语法表示%t 单词true或false%q 该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示%x 表示为十六进制，使用a-f%X 表示为十六进制，使用A-F%U 表示为Unicode格式：U+1234，等价于&quot;U+%04X&quot; 示例： 1234567891011121314151617181920212223242526272829type User struct &#123; Name string Age int&#125;user : = User&#123; \"overnote\", 1,&#125;fmt.Printf(\"%%\\n\") // %fmt.Printf(\"%b\\n\", 16) // 10000fmt.Printf(\"%c\\n\", 65) // Afmt.Printf(\"%c\\n\", 0x4f60) // 你fmt.Printf(\"%U\\n\", '你') // U+4f60fmt.Printf(\"%x\\n\", '你') // 4f60fmt.Printf(\"%X\\n\", '你') // 4F60fmt.Printf(\"%d\\n\", 'A') // 65fmt.Printf(\"%t\\n\", 1 &gt; 2) // falsefmt.Printf(\"%e\\n\", 4396.7777777) // 4.396778e+03 默认精度6位fmt.Printf(\"%20.3e\\n\", 4396.7777777) // 4.397e+03 设置宽度20,精度3,宽度一般用于对齐fmt.Printf(\"%E\\n\", 4396.7777777) // 4.396778E+03fmt.Printf(\"%f\\n\", 4396.7777777) // 4396.777778fmt.Printf(\"%o\\n\", 16) // 20fmt.Printf(\"%p\\n\", []int&#123;1&#125;) // 0xc000016110fmt.Printf(\"Hello %s\\n\", \"World\") // Hello Worldfmt.Printf(\"Hello %q\\n\", \"World\") // Hello \"World\"fmt.Printf(\"%T\\n\", 3.0) // float64fmt.Printf(\"%v\\n\", user) // &#123;overnote 1&#125;fmt.Printf(\"%+v\\n\", user) // &#123;Name:overnote Age:1&#125;fmt.Printf(\"%#v\\n\", user) // main.User&#123;Name:\"overnote\", Age:1&#125;","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-运算符","slug":"运算符","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-16T08:02:33.401Z","comments":true,"path":"2020/06/16/运算符/","link":"","permalink":"http://www.dwlblog.网址/2020/06/16/%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"一 运算符1.1 运算符汇总123456算术运算符： + - * &#x2F; % ++ -- 关系运算符： &#x3D;&#x3D; !&#x3D; &lt;&#x3D; &gt;&#x3D; &lt; &gt; 逻辑运算符： ! &amp;&amp; ||位运算： &amp;（按位与） |（按位或） ^（按位取反） &lt;&lt;（左移） &gt;&gt;（右移）赋值运算符： &#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;其他运算符： &amp;（取地址） *（取指针值） &lt;-（Go Channel相关运算符） 1.2 自增、自减Go中只有后--和后++，且自增自减不能用于表达式中，只能独立使用： 123a = i++ // 错误用法if i++ &gt; 0 &#123;&#125; // 错误用法i++ // 正确用法 1.3 位运算12345&amp; 按位与，参与运算的两个数二进制位相与：同时为1，结果为1，否则为0| 按位或，参与运算的两个数二进制位相或：有一个为1，结果为1，否则为0^ 按位异或：二进位不同，结果为1，否则为0&lt;&lt; 按位左移：二进位左移若干位，高位丢弃，低位补0，左移n位其实就是乘以2的n次方&gt;&gt; 按位右移：二进位右移若干位，右移n位其实就是除以2的n次方 二 优先级 三 进制转换1.1 常见进制 二进制：只有0和1，Go中不能直接使用二进制表示整数 八进制：0-7，以数字0开头 十进制：0-9 十六进制：0-9以及A-F，以0X开头，A-F以及X不区分大小写 1.2 任意进制转换为十进制二进制转十进制： 从最低位开始，每个位上数乘以2（位数-1）次方然后求和1011 = 1*20 + 1*21 + 0*22 + 1*23 = 11 八进制转十进制： 从最低位开始，每个位上数乘以8（位数-1）次方然后求和0123 = 3*80 + 2*81 + 1*82 + 0*83 = 83 其他进制转十进制同理。 1.3 十进制转其他进制十进制转二进制： 不断除以2，直到0为止,余数倒过来即可，如图计算28转换为二进制11100 十进制转八进制：不断除以8，直到0为止，余数倒过来即可。 十进制转十六进制：不断除以16，直到0为止，余数倒过来即可。 1.4 其他进制互转 二进制转换八进制：将二进制数从低位开始，每三位一组，转换成八进制数即可 二进制转十六进制：将二进制数从低位开始，每四位一组，转换成十六进制数即可 八进制转换二进制：将八进制数每1位转换成一个3位的二进制数（首位0除外） 十六进制转二进制：将十六进制每1位转换成对应的一个4位的二进制数即可 四 计算机运算原理计算机常见的术语： bit：比特，代表1个二进制位，一个位只能是0或者1 Byte：字节，代表8个二进制位，计算机中存储的最小单元是字节 WORD：双字节，即2个字节，16位 DWORD：两个WORD，即4个字节，32位 一些常用单位： 1b：1bit，1位 1Kb：1024bit，即1024位 1Mb：1024*1024bit 1B：1Byte，1字节，8位 1KB：1024B 1MB：1024K 对于有符号数而言，二进制的最高为是符号位：0表示正数，1表示负数，比如 1在二进制中： 121 二进制位：0000 0001-1 二进制位：1000 0001 正数的原码、反码、补码都一样，负数的反码=原码符号位不变，其他位取反，补码是反码+1 1234 1 -1原码 0000 0001 1000 0001反码 0000 0001 1111 1110补码 0000 0001 1111 1111 常见理解： 0的反码补码都是0 计算机中是以补码形式运算的","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-类型转换","slug":"类型转换与别名","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-16T07:59:31.800Z","comments":true,"path":"2020/06/16/类型转换与别名/","link":"","permalink":"http://www.dwlblog.网址/2020/06/16/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%88%AB%E5%90%8D/","excerpt":"","text":"一 数据类型转换1.1 显式转换Go在不同类型的变量之间赋值时需要显式转换。也就是说Golang中数据类型不能自动转换。 1.2 数值类型转换123var i int32 = 100var n1 float64 = float64(i)fmt.Printf(\"n1=%v\", n1) //输出100 注意：在转换中，比如将int64转成int8【-128---127】，编译时不会报错，只是转换的结果是按溢出处理，和我们希望的结果不一样。 因此在转换时，需要考虑范围。 1.3 基本数据类型与字符串转换基本数据类型转字符串：fmt.Sprintf();该函数会返回转换后的字符串 12345var b bool = truevar str stringstr = fmt.Sprintf(\"%t\", b)fmt.Printf(str) //true 字符串转基本数据类型：使用包strconv 1234var str string = \"true\"var b boolb, _ = strconv.ParseBool(str) fmt.Printf(\"%v\", b) 注意：在将String类型转成基本数据类型时，要确保String类型能够转成有效的数据，比如可以把”123”,转成一个整数，但不能转换”hello”，如果这样做，Golang 直接将其转成0，其它类型也是一样的道理，如：float =&gt; 0 bool =&gt; false。 二 类型别名2.1 类型别名的使用Go在1.9版本加入了类型别名。主要用于代码升级、迁移中类型的兼容问题（C/C++中使用宏来解决重构升级带来的问题）。 Go1.9之前的版本内部定义了新的类型byte和rune，用于指代uint8和int32： 12type byte uint8type rune int32 Go1.9之后uint8和int32使用了类型别名： 1234567891011121314type byte = uint8 // 使用 = 号定义后，都会按照等号右边的类型打印、计算type rune = int32``` 类型定义是定义了一个全新的类型的类型。类型别名只是某个类型的小名，并非创造了新的类型：```gotype MyInt int // 类型定义type AliasInt = int // 类型别名，支持使用括号，同时起多个别名var a1 MyIntfmt.Printf(\"a1 type: %T\\n\", a1) //main.MyIntvar a2 AliasIntfmt.Printf(\"a2 type: %T\\n\", a2) //int 2.2 不同包下的类型定义如下示例，在项目根目录新建文件夹mypack，在该目录建立person.go文件： 1234567891011package mypackimport \"fmt\"type Person struct &#123;&#125;func (p *Person)Run() &#123; fmt.Println(\"run...\")&#125; 在main.go中，如下使用： 12345678910111213141516171819package mainimport ( \"TestGo/mypack\" // // TestGo 是 go.mod文件中定义的项目名：module TestGo \"fmt\")type Student mypack.Personfunc (s *Student) Study() &#123; fmt.Println(\"study...\")&#125;func main() &#123; s := &amp;Student&#123;&#125; s.Study()&#125; 2.3 不同包下的类型别名2.2 中的案例如果将类型定义改为类型别名： 1type Student = mypack.Person // 这时Student的方法就会报错：无法为 Person 添加新的方法 使用方式：必须直接在person文件中直接使用类型别名 123456789101112131415161718package mypackimport \"fmt\"type Person struct &#123;&#125;func (p *Person)Run() &#123; fmt.Println(\"run...\")&#125;type Student = Personfunc (p *Student) Study() &#123; fmt.Println(\"study...\")&#125; main中调用别名方法： 123456789101112131415161718package mypackimport \"fmt\"type Person struct &#123;&#125;func (p *Person)Run() &#123; fmt.Println(\"run...\")&#125;type Student = Personfunc (p *Student) Study() &#123; fmt.Println(\"study...\")&#125; 三 Go的类型系统补充3.1 命名类型和未命名类型 命名类型：Named Type。类型通过标识符、自定义类型表示 未命名类型：Unamed Type。也称为类型字面量（Type Literal），由预声明类型、关键字、操作符等组合而成，如array、slice、channel、pointer、function、未使用type定义的struct、未使用type定义的interface。 示例： 12345678// 命名类型，其类型是 Persontype Person struct &#123; name string&#125;// 未命名类型，其类型是 struct &#123; name string &#125;p := struct &#123; name string&#125; 3.2 底层类型所有类型都有一个底层类型 underlying type，其规则如下： 预声明类型（Pre-declared types）和类型字面量（type literals）的底层类型是他们自身 自定义类型type newtype oldtype中newtype的底层类型是逐层递归向下查找的，直到找到oldtype的预声明类型或字面量类型 3.3 Go中的类型相同Go中类型相同的规范： 命名类型的数据类型相同：声明语句必须完全相同 未命名类型数据类型相同：类型声明字面量结构相同，且内部元素的类型相同 命名类型与未命名类型永远不同 通过类型别名语句声明的两个类型相同。类型别名语法：type T1 = T2","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-流程控制","slug":"流程控制","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-16T07:59:48.553Z","comments":true,"path":"2020/06/16/流程控制/","link":"","permalink":"http://www.dwlblog.网址/2020/06/16/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"","text":"一 流程控制之-条件语句1.1 判断语句 ifif判断示例： 123// 初始化与判断写在一起： if a := 10; a == 10if i == '3' &#123; &#125; if的特殊写法： 12if err := Connect(); err != nil &#123; // 这里的 err!=nil 才是真正的if判断表达式&#125; 1.2 分支语句 switch示例： 12345678switch num &#123; case 1: // case 中可以是表达式 fmt.Println(\"111\") case 2: fmt.Println(\"222\") default: fmt.Println(\"000\")&#125; 贴士： Go保留了break，用来跳出switch语句，上述案例的分支中默认就书写了该关键字 Go也提供fallthrough，代表不跳出switch，后面的语句无条件执行 二 流程控制之-循环语句2.1 for循环Go只支持for一种循环语句，但是可以对应很多场景： 12345678910111213141516171819202122// 传统的for循环for init;condition;post&#123;&#125;// for循环简化var i intfor ; ; i++ &#123; if(i &gt; 10)&#123; break; &#125;&#125;// 类似while循环for condition &#123;&#125;// 死循环for&#123;&#125;// for range:一般用于遍历数组、切片、字符串、map、管道for k, v := range []int&#123;1,2,3&#125; &#123;&#125; 2.2 跳出循环常用的跳出循环关键字： break用于函数内跳出当前for、switch、select语句的执行 continue用于跳出for循环的本次迭代。 goto可以退出多层循环 break跳出循环案例(continue同下)： 12345678910111213OuterLoop: for i := 0; i &lt; 2; i++ &#123; for j := 0; j &lt; 5; j++ &#123; switch j &#123; case 2: fmt.Println(i,j) break OuterLoop case 3: fmt.Println(i,j) break OuterLoop &#125; &#125; &#125; goto跳出多重循环案例： 123456789101112for x:=0; x&lt;10; x++ &#123; for y:=0; y&lt;10; x++ &#123; if y==2 &#123; goto breakHere &#125; &#125; &#125;breakHere: fmt.Println(\"break\") 贴士：goto也可以用来统一错误处理。 123456if err != nil &#123; goto onExit&#125;onExit: fmt.Pritln(err) exitProcess()","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-标识符与变量","slug":"标识符与变量","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-16T07:56:31.721Z","comments":true,"path":"2020/06/16/标识符与变量/","link":"","permalink":"http://www.dwlblog.网址/2020/06/16/%E6%A0%87%E8%AF%86%E7%AC%A6%E4%B8%8E%E5%8F%98%E9%87%8F/","excerpt":"","text":"一 标识符1.1 关键字Go现在拥有25个关键字： 1234if for func case struct import go type chan defer default packagemap const else break select interfacevar goto range return switch continue fallthrough 1.2 保留字123456789101112内建常量： true false iota nil内建类型： int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64bool： byte rune string error内建函数： make delete complex panic append copy close len cap real imag new recover 二 变量2.1 变量声明Go变量声明的三种方式： 123var a int // 声明一个变量，默认为0var b = 10 // 声明并初始化，且自动推导类型c := 20 // 初始化，且自动推导 注意： :=定义变量只能在函数内部使用，所以经常用var定义全局变量 Go对已经声明但未使用的变量会在编译阶段报错：** not used Go中的标识符以字母或者下划线开头，大小写敏感 Go推荐使用驼峰命名 2.2 多变量声明12345678var a,b stringvar a1,b1 string = \"哼\",\"哈\"var a2,b2 int = 1,2 //类型可以直接省略c,d := 1,2var( e int f bool) 2.3 变量值互换12m,n = n,m //变量值互换temp,_ = m,n //匿名变量：变量值互换，且丢弃变量n 2.4 _丢弃变量_是个特殊的变量名，任何赋予它的值都会被丢弃。该变量不占用命名空间，也不会分配内存。 1_, b := 34, 35 //将值`35`赋予`b`，并同时丢弃`34`： 2.5 := 声明的注意事项下面是正确的代码示例： 12in, err := os.Open(file)out, err := os.Create(file) // err已经在上方定义，此处的 err其实是赋值 但是如果在第二行赋值的变量名全部和第一行一致，则编译不通过： 12in, err := os.Open(file)in, err := os.Create(file) // 即 := 必须确保至少有一个变量是用于声明 :=只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么:=将会在当前词法域重新声明一个新的变量。 2.6 多数据分组书写Go可以使用该方式声明多个数据： 1234567891011const( i = 100 pi = 3.1415 prefix = \"Go_\") var( i int pi float32 prefix string) 三 关键字iota关键字iota声明初始值为0，每行递增1： 123456789101112131415161718const ( a = iota // 0 b = iota // 1 c = iota // 2)const ( d = iota // 0 e // 1 f // 2)//如果iota在同一行，则值都一样const ( g = iota //0 h,i,j = iota,iota,iota // 1,1,1 // k = 3 // 此处不能定义缺省常量，会编译错误 )","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-反射2","slug":"反射-2-应用","date":"2020-05-09T02:24:27.000Z","updated":"2020-06-16T07:57:36.650Z","comments":true,"path":"2020/05/09/反射-2-应用/","link":"","permalink":"http://www.dwlblog.网址/2020/05/09/%E5%8F%8D%E5%B0%84-2-%E5%BA%94%E7%94%A8/","excerpt":"","text":"一 反射的使用1.1 反射操作简单数据类型12345678910111213var num int64 = 100// 设置值：指针传递ptrValue := reflect.ValueOf(&amp;num)newValue := ptrValue.Elem() // Elem()用于获取原始值的反射对象fmt.Println(\"type：\", newValue.Type()) // int64fmt.Println(\" can set：\", newValue.CanSet()) // truenewValue.SetInt(200)// 获取值：值传递rValue := reflect.ValueOf(num)fmt.Println(rValue.Int()) // 方式一：200fmt.Println(rValue.Interface().(int64)) // 方式二：200 1.2 反射进行类型推断1234567891011121314type user struct &#123; Name string Age int&#125;u := &amp;user&#123; Name: \"Ruyue\", Age: 100,&#125;fmt.Println(reflect.TypeOf(u)) // *main.userfmt.Println(reflect.TypeOf(*u)) // main.userfmt.Println(reflect.TypeOf(*u).Name()) // userfmt.Println(reflect.TypeOf(*u).Kind()) // struct 1.3 反射操作指针12345678910111213type user struct &#123; Name string Age int&#125;u := &amp;user&#123; Name: \"Ruyue\", Age: 100,&#125;typeOfUser = reflect.TypeOf(u).Elem()fmt.Println(\"element name: \", typeOfUser.Name()) // userfmt.Println(\"element kind: \", typeOfUser.Kind()) // struct 1.4 反射操作结构体反射可以获取结构体的详细信息： 1234567891011121314151617181920212223242526type user struct &#123; Name string Age int `json:\"age\" id:\"100\"` // 结构体标签&#125;s := user&#123; Name: \"zs\", Age: 1,&#125;typeOfUser := reflect.TypeOf(s)// 字段用法for i := 0; i &lt; typeOfUser.NumField(); i++ &#123; // NumField 当前结构体有多少个字段 fieldType := typeOfUser.Field(i) // 获取每个字段 fmt.Println(fieldType.Name, fieldType.Tag)&#125;if userAge, ok := typeOfUser.FieldByName(\"Age\"); ok &#123; fmt.Println(userAge) // &#123;Age int json:\"age\" id:\"100\" 16 [1] false&#125;&#125;// 方法用法for i := 0; i &lt; typeOfUser.NumMethod(); i++ &#123; fieldType := typeOfUser.Method(i) // 获取每个字段 fmt.Println(fieldType.Name)&#125; 二 反射调用函数与方法2.1 使用反射调用函数如果反射值对象(reflect.Value)中值的类型为函数时，可以通过 reflect.Value调用该 函数。使用反射调用函数时，需要将参数使用反射值对象的切片 口reflect.Value 构造后传入 Call()方法中 ， 调用完成时，函数的返回值通过 []reflect.Value 返回 。 1234567891011func add(name string, age int) &#123; fmt.Printf(\"name is %s, age is %d \\n\", name, age)&#125;func main() &#123; funcValue := reflect.ValueOf(add) params := []reflect.Value&#123;reflect.ValueOf(\"lisi\"), reflect.ValueOf(20)&#125; reList := funcValue.Call(params) fmt.Println(reList) // 函数返回值&#125; 2.2 反射调用方法方法的调用是需要接收者的： 123456789101112131415161718192021222324252627282930313233package mainimport ( \"fmt\" \"reflect\")type user struct &#123; Name string Age int&#125;func (u *user) ShowName() &#123; fmt.Println(u.Name)&#125;func (u *user) AddAge(addNum int) &#123; fmt.Println(\"age add result:\", u.Age + addNum)&#125;func main() &#123; u := &amp;user&#123;\"lisi\", 20&#125; v := reflect.ValueOf(u) // 调用无参方法 methodV := v.MethodByName(\"ShowName\") methodV.Call(nil) // 或者传递一个空切片也可 // 调用有参方法 methodV2 := v.MethodByName(\"AddAge\") args := []reflect.Value&#123;reflect.ValueOf(30)&#125; // methodV2.Call(args)&#125;","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-反射-1","slug":"反射-1-概述","date":"2020-05-03T01:54:07.000Z","updated":"2020-06-16T07:57:22.353Z","comments":true,"path":"2020/05/03/反射-1-概述/","link":"","permalink":"http://www.dwlblog.网址/2020/05/03/%E5%8F%8D%E5%B0%84-1-%E6%A6%82%E8%BF%B0/","excerpt":"","text":"一 反射简介反射是指在程序运行期对程序本身进行访问和修改的能力，即可以在运行时动态获取变量的各种信息，比如变量的类型（type），类别（kind），如果是结构体变量，还可以获取到结构体本身的信息（字段与方法），通过反射，还可以修改变量的值，可以调用关联的方法。 反射常用在框架的开发上，一些常见的案例，如JSON序列化时候tag标签的产生，适配器函数的制作等，都需要用到反射。反射的两个使用常见使用场景： 不知道函数的参数类型：没有约定好参数、传入类型很多，此时类型不能统一表示，需要反射 不知道调用哪个函数：比如根据用户的输入来决定调用特定函数，此时需要依据函数、函数参数进行反射，在运行期间动态执行函数 Go程序的反射系统无法获取到一个可执行文件空间中或者是一个包中的所有类型信息，需要配合使用标准库中对应的词法、语法解析器和抽象语法树( AST) 对源码进行扫描后获得这些信息。 贴士： C，C++没有支持反射功能，只能通过 typeid 提供非常弱化的程序运行时类型信息。 Java、 C#等语言都支持完整的反射功能。 Lua、JavaScript类动态语言，由于其本身的语法特性就可以让代码在运行期访问程序自身的值和类型信息，因此不需要反射系统。 注意： 在编译期间，无法对反射代码进行一些错误提示。 反射影响性能 二 反射是如何实现的反射是通过接口的类型信息实现的，即反射建立在类型的基础上：当向接口变量赋予一个实体类型的时候，接口会存储实体的类型信息。 Go中反射相关的包是reflect，在该包中，定义了各种类型，实现了反射的各种函数，通过它们可以在运行时检测类型的信息、改变类型的值。 变量包括type、value两个部分（所以 nil != nil ），type包括两部分： static type：在开发时使用的类型，如int、string concrete type：是runtime系统使用的类型 类型能够断言成功，取决于 concrete type ，如果一个reader变量，如果 concrete type 实现了 write 方法，那么它可以被类型断言为writer。 Go中，反射与interface类型相关，其type是 concrete type，只有interface才有反射！每个interface变量都有一个对应的pair，pair中记录了变量的实际值和类型（value, type）。即一个接口类型变量包含2个指针，一个指向对应的 concrete type ，另一个指向实际的值 value。 示例： 12345var r io.Reader // 定义了一个接口类型r, err := os.OpenFile() // 记录接口的实际类型、实际值var w io.Writer // 定义一个接口类型w = r.(io.Writer) // 赋值时，接口内部的pair不变，所以 w 和 r 是同一类型 三 Go中反射初识3.1 reflect包的两个函数reflect 提供了2个重要函数： ValueOf()：获取变量的值，即pair中的 value TypeOf()：获取变量的类型，即pair中的 concrete type 12345678910111213141516type Person struct &#123; Name string Age int&#125;p := Person&#123; \"lisi\", 13&#125;fmt.Println(reflect.ValueOf(p)) // &#123;lisi 13&#125; 变量的值fmt.Println(reflect.ValueOf(p).Type()) // main.Person 变量类型的对象名fmt.Println(reflect.TypeOf(p)) // main.Person 变量类型的对象名fmt.Println(reflect.TypeOf(p).Name()) // Person:变量类型对象的类型名fmt.Println(reflect.TypeOf(p).Kind()) // struct:变量类型对象的种类名fmt.Println(reflect.TypeOf(p).Name() == \"Person\") // truefmt.Println(reflect.TypeOf(p).Kind() == reflect.Struct) //true 类型与种类的区别： Type是原生数据类型： int、string、bool、float32 ，以及 type 定义的类型，对应的反射获取方法是 reflect.Type 中 的 Name() Kind是对象归属的品种：Int、Bool、Float32、Chan、String、Struct、Ptr（指针）、Map、Interface、Fune、Array、Slice、Unsafe Pointer等 3.2 静态类型与动态类型静态类型：变量声明时候赋予的类型 12type MyInt int // int 是静态类型var i *int // *int 是静态类型 动态类型：运行时给这个变量赋值时，这个值的类型即为动态类型（为nil时没有动态类型）。 123var A interface&#123;&#125; // 空接口 是静态类型，必须是接口类型才能实现类型动态变化A = 10 // 此时静态类型为 interface&#123;&#125; 动态为intA = \"hello\" // 此时静态类型为 interface&#123;&#125; 动态为string","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-时间操作","slug":"时间操作","date":"2020-04-26T02:34:57.000Z","updated":"2020-06-16T08:00:29.903Z","comments":true,"path":"2020/04/26/时间操作/","link":"","permalink":"http://www.dwlblog.网址/2020/04/26/%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C/","excerpt":"","text":"一 时间操作1.1 创建时间Golang中时间操作位于 time 包中，常见操作有： 12345678// 当前时间nowTime := time.Now()fmt.Printf(\"当前时间为：%T\\n\", nowTime) // 其类型是 time.Timefmt.Println(nowTime) // 2019-01-01 13:50:07.522712 +0800 CST m=+0.000138178// 自定义时间customTime := time.Date(2008, 7, 15, 13, 30,0,0, time.Local)fmt.Println(customTime) // 2008-07-15 13:30:00 +0800 CST 1.2 时间格式化与解析Go的时间格式化必须传入Go的生日：Mon Jan 2 15:04:05 -0700 MST 2006 123nowTime := time.Now()stringTime := nowTime.Format(\"2006年1月2日 15:04:05\")fmt.Println(stringTime) // 2019年01月01日 13:55:30 Go的时间解析： 123 stringTime := \"2019-01-01 15:03:01\"objTime,_ := time.Parse(\"2006-01-02 15:04:05\",stringTime)fmt.Println(objTime) // 2019-01-01 15:03:01 +0000 UTC 注意：这些方法的参数模板必须与时间一一对应，否则报错！ 1.3 获取 年 月 日12345678910111213 nowTime := time.Now()year, month, day := nowTime.Date()fmt.Println(year, month, day) // 2019 November 01hour, min, sec := nowTime.Clock()fmt.Println(hour, min, sec)fmt.Println(nowTime.Year())fmt.Println(nowTime.Month())fmt.Println(nowTime.Hour())fmt.Println(nowTime.YearDay()) // 指今年一共过了多少天 1.4 时间戳时间戳是指计算时间距离 1970年1月1日的秒数： 12nowTime := time.Now()fmt.Println(nowTime.Unix()) 1.5 时间间隔123nowTime := time.Now()fmt.Println(nowTime.Add(time.Second * 10)) // 10秒后 fmt.Println(nowTime.AddDate(1, 0, 0)) // 1年后 贴士： 传入负数则是往前计算 Sub()函数可以用来计算两个时间的差值 1.6 时间睡眠1time.Sleep(time.Second * 3) // 程序睡眠三秒钟 二 时间中的通道操作（定时器）标准库中的Timer可以让用户自定义一个定时器，在用对select处理多个channel的超时、单channel读写的超时等情形时很方便： 123timer := time.NewTimer(time.Second * 3) // 类型为 *time.Timerch := timer.C // timer内部包含一个通道fmt.Println(&lt;-ch) // 3秒后，通道内有了数据，可以取出 配合协程： 12345678910timer := time.NewTimer(time.Second * 3) // 类型为 *time.Timergo func() &#123; &lt;- timer.C fmt.Println(\"timer 结束\")&#125;()time.Sleep(time.Second * 5)flag := timer.Stop() // 取消定时器 fmt.Println(flag) // false time.After函数的使用： 123ch := time.After(time.Second * 3) // 底层其实是 new Timer(d).CnewTime := &lt;-ch // 阻塞3秒fmt.Println(newTime)","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-文件的读操作","slug":"文件操作-2-读操作","date":"2020-04-23T05:44:57.000Z","updated":"2020-06-16T08:01:32.235Z","comments":true,"path":"2020/04/23/文件操作-2-读操作/","link":"","permalink":"http://www.dwlblog.网址/2020/04/23/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-2-%E8%AF%BB%E6%93%8D%E4%BD%9C/","excerpt":"","text":"一 文件读取文件读写的接口位于io包，file文件类是这些接口的实现类。 1.1 直接读取 read()read() 实现的是按字节数读取： 1234567891011121314readByte := make([]byte, 128) // 指定要读取的长度for &#123; n, err := f.Read(readByte) // 将数据读取如切片，返回值 n 是实际读取到的字节数 if err != nil &amp;&amp; err != io.EOF&#123; // 如果读到了文件末尾：EOF 即 end of file fmt.Println(\"read file : \", err) break &#125; fmt.Println(\"read: \", string(readByte[:n])) if n &lt; 128 &#123; fmt.Println(\"read end\") break &#125;&#125; 1.2 bufio的写操作bufio封装了io.Reader、io.Writer接口对象，并创建了另一个也实现了该接口的对象：bufio.Reader、bufio.Writer。通过该实现，bufio实现了文件的缓冲区设计，可以大大提高文件I/O的效率。 使用bufio读取文件时，先将数据读入内存的缓冲区（缓冲区一般比要比程序中设置的文件接收对象要大），这样就可以有效降低直接I/O的次数。 bufio.Read([]byte)相当于读取大小len(p)的内容： 当缓冲区有内容时，将缓冲区内容全部填入p并清空缓冲区 当缓冲区没有内容且len(p)&gt;len(buf)，即要读取的内容比缓冲区还要大，直接去文件读取即可 当缓冲区没有内容且len(p)&lt;len(buf)，即要读取的内容比缓冲区小，读取文件内容并填满缓冲区，并将p填满 以后再次读取时，缓冲区有内容，将缓冲区内容全部填入p并清空缓冲区（和第一步一致） 示例： 123456// 创建读对象reader := bufio.NewReader(f)// 读一行数据byt, _ := reader.ReadBytes('\\n') fmt.Println(string(byt)) ReadString() 函数也具有同样的功能，且能直接读取到字符串数据，无需转换，示例：读取大文件的全部数据 12345678910111213reader := bufio.NewReader(f)for &#123; // 按照缓冲区读取：读取到特定字符结束 str, err := reader.ReadString('\\n') // 按行读取 if err != nil &amp;&amp; err != io.EOF &#123; fmt.Println(\"read err: \", err) break &#125; fmt.Println(\"str = \", str) if err == io.EOF &#123; fmt.Print(\"read end\") break &#125;&#125; 在Unix设计思想中，一切皆文件，命令行输入也可以作为文件读入： 12reader := bufio.NewReader(os.Stdin)s, _ := reader.ReadString(\"-\") // 假设命令行以 - 开始 缓冲的思想：通过bufio，数据被写入用户缓冲，再进入系统缓冲，最后由操作系统将系统缓冲区的数据写入磁盘。 1.3 io/ioutil 包文件读取ioutil直接读取文件： 123456ret, err := ioutil.ReadFile(\"test.txt\")if err != nil &#123; fmt.Println(\"read err :\", err) return&#125;fmt.Println(string(ret)) 二 文件写入2.1 直接写123456789101112f, err := os.OpenFile(\"test.txt\", os.O_CREATE | os.O_WRONLY, os.ModePerm)if err != nil &#123; fmt.Println(\"open err:\", err) return&#125;defer f.Close()n, err := f.Write([]byte(\"hello world\"))if err != nil &#123; fmt.Println(\"write err:\", err)&#125;fmt.Println(n) // 每次都会从头开始重新写入 上述案例中，如果我们不想每次写入都会从头开始重新写入，那么需要将打开模式修改为：os.O_CREATE | os.O_WRONLY | os.O_APPEND 2.2 bufio的写操作1234567writer := bufio.NewWriter(f)_, err = writer.WriteString(\"hello world!\")if err != nil &#123; fmt.Println(\"write err:\", err) return&#125;writer.Flush() // 必须刷新缓冲区：将缓冲区的内容写入文件中。如果不刷新，则只会在内容超出缓冲区大小时写入 2.3 io/ioutil 包文件写入12s := \"你好世界\"err := ioutil.WriteFile(\"test.txt\", []byte(s), os.ModePerm) 三 文件读取偏移量文件读取时，是可以控制光标位置的： 12345678910111213141516171819202122232425262728f, err := os.OpenFile(\"test.txt\", os.O_RDWR, os.ModePerm)if err != nil &#123; fmt.Println(\"open err:\", err) return&#125;defer f.Close()// 读取前五个字节，假设读取的文件内容为： hello world!bs := []byte&#123;0&#125; // 创建1个字节的切片_, err = f.Read(bs)if err != nil &#123; fmt.Println(\"read err:\", err) return&#125;fmt.Println(\"读到的数据是：\", string(bs)) // h// 移动光标_, err = f.Seek(4, io.SeekStart) // 光标从开始位置(h之前)，移动4位，到达o之前if err != nil &#123; fmt.Println(\"seek err:\", err) return&#125;_, err = f.Read(bs)if err != nil &#123; fmt.Println(\"read err:\", err) return&#125;fmt.Println(\"读到的数据是：\", string(bs)) // o 通过记录光标的位置，可以实现断点续传：假设已经下载了1KB文件，即本地临时文件存储了1KB，此时断电，重启后通过本地文件大小、Seek()方法获取到上次读取文件的光标位置即可实现继续下载！","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-接口使用","slug":"接口类型-1-接口的使用","date":"2020-04-21T07:24:57.000Z","updated":"2020-06-16T07:58:34.885Z","comments":true,"path":"2020/04/21/接口类型-1-接口的使用/","link":"","permalink":"http://www.dwlblog.网址/2020/04/21/%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B-1-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"一 接口 interface接口（interface）是调用方和实现方均需要遵守的一种约束，约束开发者按照统一的方法命名、参数类型、数量来处理具体业务。实际上，接口就是一组没有实现的方法声明，到某个自定义类型要使用该方法时，根据具体情况把这些方法实现出来。接口语法： 12345type 接口类型名 interface &#123; 方法名1(参数列表) 返回值列表 方法名2(参数列表) 返回值列表 ...&#125; 示例： 123456789101112131415161718192021222324252627282930313233343536package mainimport \"fmt\"// 运输方式type Transporter interface &#123; BicycleTran() CarTran()&#125;// 驾驶员type Driver struct &#123; Name string Age int&#125;// 实现运输方式接口func (d *Driver) BicycleTran() &#123; fmt.Println(\"使用自行车运输\")&#125;func (d *Driver) CarTran() &#123; fmt.Println(\"使用小汽车运输\")&#125;func main() &#123; d := &amp;Driver&#123; \"张三\", 27, &#125; trans(d)&#125;// 只要实现了 Transporter接口的类型都可以作为参数func trans(t Transporter) &#123; t.BicycleTran()&#125; 注意： Go语言的接口在命名时，一般会在单词后面添加er，如写操作的接口叫做Writer 当方法名首字母大写，且实现的接口首字母也是大写，则该方法可以被接口所在包之外的代码访问 方法与接口中的方法签名一致（方法名、参数列表、返回列表都必须一致） 参数列表和返回值列表中的变量名可以被忽略，如：type writer interfae{ Write([]byte) error} 接口中所有的方法都必须被实现 如果编译时发现实现接口的方法签名不一致，则会报错：does not implement。 二 Go接口的特点在上述示例中，Go无须像Java那样显式声明实现了哪个接口，即为非侵入式，接口编写者无需知道接口被哪些类型实现，接口实现者只需要知道实现的是什么样子的接口，但无需指明实现了哪个接口。编译器知道最终编译时使用哪个类型实现哪个接口，或者接口应该由谁来实现。 类型和接口之间有一对多和多对一的关系，即： 一个类型可以实现多个接口，接口间是彼此独立的，互相不知道对方的实现 多个类型也可以实现相同的接口。 123456789101112131415161718192021222324252627type Service interface &#123; Start() Log(string)&#125;// 日志器type Logger struct &#123;&#125;//日志输出方法func (g *Logger) Log(s string)&#123; fmt.Println(\"日志：\", s)&#125;// 游戏服务type GameService struct &#123; Logger&#125;// 实现游戏服务的Start方法func (g *GameService) Start() &#123; fmt.Println(\"游戏服务启动\")&#125;func main() &#123; s := new(GameService) s.Start() s.Log(\"hello\")&#125; 在上述案例中，即使没有接口也能运行，但是当存在接口时，会隐式实现接口，让接口给类提供约束。 使用接口调用了结构体中的方法，也可以理解为实现了面向对象中的多态。 三 接口嵌套Go中不仅结构体之间可以嵌套，接口之间也可以嵌套。接口与接口嵌套形成了新的接口，只要接口的所有方法被实现，则这个接口中所有嵌套接口的方法均可以被调用。 123456789101112131415// 定义一个 写 接口type Writer interface &#123; Write(p []byte) (n int, e error)&#125;// 定义一个 读 接口type Reader interface &#123; Read() error&#125;// 定义一个 嵌套接口type IO interface &#123; Writer Closer&#125; 四 空接口4.1 空接口定义空接口是接口的特殊形式，没有任何方法，因此任何具体的类型都可以认为实现了空接口。 1234567var any interface&#123;&#125;any = 1fmt.Println(any)any = \"hello\"fmt.Println(any) 空接口作为函数参数： 12345678func Test(i interface&#123;&#125;) &#123; fmt.Printf(\"%T\\n\", i)&#125;func main() &#123; Test(3) // int Test(\"hello\") // sting&#125; 利用空接口，可以实现任意类型的存储： 123m := make(map[string]interface&#123;&#125;)m[\"name\"] = \"李四\"m[\"age\"] = 30 4.2 从空接口获取值保存到空接口的值，如果直接取出指定类型的值时，会发生编译错误： 123var a int = 1var i interface&#123;&#125; = avar b int = i //这里编译报错（类型不一致），可以这样做：b := i 4.3 空接口值比较类型不同的空接口比较： 1234var a interface&#123;&#125; = 100var b interface&#123;&#125; = \"hi\"fmt.Println(a == b) //false 不能比较空接口中的动态值： 123var c interface&#123;&#125; = []int&#123;10&#125;var d interface&#123;&#125; = []int&#123;20&#125;fmt.Println(c == d) //运行报错 空接口的类型和可比较性： 类型 说明 map 不可比较，会发生宕机错误 切片 不可比较，会发生宕机错误 通道 可比较，必须由同一个make生成，即同一个通道才是true 数组 可比较，编译期即可知道是否一致 结构体 可比较，可诸葛比较结构体的值 函数 可比较","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-文件的写操作","slug":"文件操作-1-写操作","date":"2020-04-21T02:24:57.000Z","updated":"2020-06-16T08:01:15.702Z","comments":true,"path":"2020/04/21/文件操作-1-写操作/","link":"","permalink":"http://www.dwlblog.网址/2020/04/21/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-1-%E5%86%99%E6%93%8D%E4%BD%9C/","excerpt":"","text":"一 文件的基本操作1.1 创建文件1234567f, err := os.Create(\"test.txt\")if err != nil &#123; fmt.Println(err) return&#125;fmt.Println(f) // 打印文件指针f.Close() // 打开的资源在不使用时必须关闭 使用Create()创建文件时： 如果文件不存在，则创建文件。 如果文件存在，则清空文件内内容。 Create创建的文件任何人都可以读写。 1.2 打开文件，写入内容打开文件有两种方式： Open()：以只读的方式打开文件，若文件不存在则会打开失败 OpenFile()：打开文件时，可以传入打开方式，该函数的三个参数： 参数1：要打开的文件路径 参数2：文件打开模式，如 O_RDONLY，O_WRONGLY，O_RDWR，还可以通过管道符来指定文件不存在时创建文件 参数3：文件创建时候的权限级别，在0-7之间，常用参数为6 123456f, err := os.OpenFile(\"test.txt\", os.O_APPEND | os.O_RDWR, os.ModeAppend)if err != nil &#123; fmt.Println(\"open file err: \", err) return&#125;f.Close() 常用的文件打开模式： 1234567891011121314151617181920 O_RDONLY int = syscall.O_RDONLY // 只读 O_WRONGLY int = syscall.O_WRONGLY // 只写 O_RDWR int = syscall.O_RDWR // 读写 O_APPEND int = syscall.O_APPEND // 写操作时将数据追加到文件末尾 O_CREATE int = syscall.O_CREATE // 如果不存在则创建一个新文件 O_EXCL int = syscall.O_EXCL // 打开文件用于同步I/O O_TRUNC int = syscall.O_TRUNC // 如果可能，打开时清空文件``` ### 1.3 写文件写入字节 `Write()`：```go // 写入文件内容 n, err := f.Write([]byte(\"hello\")) if err != nil &#123; fmt.Println(\"write err: \", err) return &#125; fmt.Println(\"write number = \", n) 按字符串写 WriteString()： 1234567// 写入文件内容n, err := f.WriteString([\"hello\") // 会将前5个字符替换为 helloif err != nil &#123; fmt.Println(\"write err: \", err) return&#125;fmt.Println(\"write number = \", n) 修改文件的读写指针位置 Seek()，包含两个参数： 参数1：偏移量，为正数时向文件尾偏移，为负数时向文件头偏移 参数2：偏移的开始位置，包括： io.SeekStart：从文件起始位置开始 io.SeekCurrent：从文件当前位置开始 io.SeekEnd：从文件末尾位置开始 Seek()函数返回 123456f, _ := os.OpenFile(\"test.txt\",os.O_RDWR, 6)off, _ := f.Seek(5, io.SeekStart)fmt.Println(off) // 5n, _ := f.WriteAt([]byte(\"111\"), off)fmt.Println(n)f.Close() 1.4 获取文件描述信息 os.Stat()Go的os包中定义了file类，封装了文件描述信息，同时也提供了Read、Write的实现。 123456fileInfo, err := os.Stat(\"./test.txt\")if err != nil &#123; fmt.Println(\"stat err: \", err) return&#125;fmt.Printf(\"%T\\n\", fileInfo) // *os.fileStat 获取到的fileInfo内部包含 文件名Name()、大小Size()、是否是目录IsDir() 等操作。 1.5 路径、目录操作12345678910111213141516171819202122232425262728 // 路径操作 fmt.Println(filepath.IsAbs(\"./test.txt\")) // false：判断是否是绝对路径 fmt.Println(filepath.Abs(\"./test.txt\")) // 转换为绝对路径 // 创建目录 err := os.Mkdir(\"./test\", os.ModePerm) if err != nil &#123; fmt.Println(\"mkdir err: \", err) return &#125; // 创建多级目录 err = os.MkdirAll(\"./dd/rr\", os.ModePerm) if err != nil &#123; fmt.Println(\"mkdirAll err: \", err) return &#125;``` 贴士：Openfile()可以用于打开目录。### 1.6 删除文件```go err := os.Remove(\"test.txt\") if err != nil &#123; fmt.Println(\"remove err:\", err) return &#125; 该函数也可用于删除目录（只能删除空目录）。如果要删除非空目录，需要使用 RemoveAll() 函数","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-接口断言、多态","slug":"接口类型-2-断言与多态","date":"2020-04-15T08:14:57.000Z","updated":"2020-06-16T07:59:18.633Z","comments":true,"path":"2020/04/15/接口类型-2-断言与多态/","link":"","permalink":"http://www.dwlblog.网址/2020/04/15/%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B-2-%E6%96%AD%E8%A8%80%E4%B8%8E%E5%A4%9A%E6%80%81/","excerpt":"","text":"一 断言接口是编程的规范，他也可以作为函数的参数，以让函数更具备适用性。在下列示例中，有三个接口动物接口、飞翔接口、游泳接口，两个实现类鸟类与鱼类： 鸟类：实现了动物接口，飞翔接口 鱼类：实现了动物接口，游泳接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport \"fmt\"// 定义一个通用接口：动物接口type Animal interface &#123; Breath() // 动物都具备 呼吸方法&#125;type Flyer interface &#123; Fly()&#125;type Swimer interface &#123; Swim()&#125;// 定义一个鸟类：其呼吸的方式是在陆地type Bird struct &#123; Name string Food string Kind string&#125;func (b *Bird) Breath() &#123; fmt.Println(\"鸟 在 陆地 呼吸\")&#125;func (b *Bird) Fly() &#123; fmt.Printf(\"%s 在 飞\\n\", b.Name)&#125;// 一定一个鱼类：其呼吸方式是在水下type Fish struct &#123; Name string Kind string&#125;func (f *Fish) Breath() &#123; fmt.Println(\"鱼 在 水下 呼吸\")&#125;func (f *Fish) Swim() &#123; fmt.Printf(\"%s 在游泳\\n\", f.Name)&#125;// 一个普通函数，参数是动物接口func Display(a Animal) &#123; // 直接调用接口中的方法 a.Breath() // 调用实现类的成员：此时会报错 fmt.Println(a.Name)&#125;func main() &#123; var b = &amp;Bird&#123; \"斑鸠\", \"蚂蚱\", \"鸟类\" &#125; Display(b)&#125; 接口类型无法直接访问其具体实现类的成员，需要使用断言（type assertions），对接口的类型进行判断，类型断言格式： 12t := i.(T) //不安全写法：如果i没有完全实现T接口的方法，这个语句将会触发宕机t, ok := i.(T) // 安全写法：如果接口未实现接口，将会把ok掷为false，t掷为T类型的0值 i代表接口变量 T代表转换的目标类型 t代表转换后的变量 上述案例的Dsiplay就可以书写为： 123456789101112func Display(a Animal) &#123; // 直接调用接口中的方法 a.Breath() // 调用实现类的成员：此时会报错 instance, ok := a.(*Bird) // 注意：这里必须是 *Bird类型，因为是*Bird实现了接口，不是Bird实现了接口 if ok &#123; // 得到了具体的实现类，才能访问实现类的成员 fmt.Println(\"该鸟类的名字是：\", instance.Name) &#125; else &#123; fmt.Println(\"该动物不是鸟类\") &#125;&#125; 二 接口类型转换在接口定义时，其类型已经确定，因为接口的本质是方法签名的集合，如果两个接口的方法签名结合相同（顺序可以不同），则这2个接口之间不需要强制类型转换就可以相互赋值，因为go编译器在校验接口是否能赋值时，比较的是二者的方法集。 在上一节中，函数Display接收的是Animal接口类型，在断言后转换为了别的类型：*Bird(实现类指针类型)： 123456789func Display(a Animal) &#123; instance, ok := a.(*Bird) // 动物接口转换为了 *Bird实现类 if ok &#123; // 得到了具体的实现类，才能访问实现类的成员 fmt.Println(\"该鸟类的名字是：\", instance.Name) &#125; else &#123; fmt.Println(\"该动物不是鸟类\") &#125;&#125; 其实，断言还可以将接口转换成另外一个接口： 123456789func Display(a Animal) &#123; instance, ok := a.(Flyer) // 动物接口转换为了飞翔接口 if ok &#123; instance.Fly() &#125; else &#123; fmt.Println(\"该动物不会飞\") &#125;&#125; 一个实现类往往实现了很多接口，为了精准类型查询，可以使用switch语句来判断对象类型： 123456var v1 interfaceP&#123;&#125; = ...switch v := v1.(type) &#123; case int: case string: ...&#125; 三 多态多态是面向对象的三大特性之一，即一个类型具备多种具体的表现形式。 上述示例中，鸟和鱼都实现了动物接口的 Breath方法，即动物的Breath方法在鸟和鱼中具备不同的体现。我们在new出动物的具体对象实例时，这个对象实例也就实现了对应自己的接口方法。 1234567891011121314151617181920212223// New出Animal的函数func NewAnimal(kind string) Animal&#123; switch kind &#123; case \"鸟类\": return &amp;Bird&#123;&#125; case \"鱼类\": return &amp;Fish&#123;&#125; default: return nil &#125;&#125;func main() &#123; // 获取的是动物接口类型，但是实现类是鸟类 a1 := NewAnimal(\"鸟类\") a1.Breath() // 鸟 在 陆地 呼吸 // 获取的是动物接口类型，但是实现类是鱼类 a2 := NewAnimal(\"鱼类\") a2.Breath() // 鱼 在 水下 呼吸&#125;","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]}],"categories":[{"name":"Git学习","slug":"Git学习","permalink":"http://www.dwlblog.网址/categories/Git%E5%AD%A6%E4%B9%A0/"},{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.dwlblog.网址/tags/Git/"},{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]}
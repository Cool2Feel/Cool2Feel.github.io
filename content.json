{"meta":{"title":"Dwl's blog","subtitle":"记录生活中的点点滴滴","description":"","author":"Dwesome","url":"http://www.dwlblog.网址","root":"/"},"pages":[{"title":"about","date":"2020-06-16T06:42:49.000Z","updated":"2020-06-17T11:58:43.996Z","comments":true,"path":"about/index.html","permalink":"http://www.dwlblog.网址/about/index.html","excerpt":"","text":"我我就是我，是颜色不一样的花火 先生不知何许人也，亦不详其姓字，宅边有五柳树，因以为号焉。闲静少言，不慕荣利。好读书，不求甚解；每有会意，便欣然忘食。性嗜酒，家贫不能常得。亲旧知其如此，或置酒而招之；造饮辄尽，期在必醉。既醉而退，曾不吝情去留。环堵萧然，不蔽风日；短褐穿结，箪瓢屡空，晏如也。常著文章自娱，颇示己志。忘怀得失，以此自终。 —— 「五柳先生传」"},{"title":"archives","date":"2020-06-16T06:43:56.000Z","updated":"2020-06-16T06:43:56.600Z","comments":true,"path":"archives/index.html","permalink":"http://www.dwlblog.网址/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-06-16T06:18:04.000Z","updated":"2020-06-16T07:23:16.641Z","comments":true,"path":"categories/index.html","permalink":"http://www.dwlblog.网址/categories/index.html","excerpt":"","text":""},{"title":"schedule","date":"2020-06-16T06:45:20.000Z","updated":"2020-06-17T07:41:07.105Z","comments":true,"path":"schedule/index.html","permalink":"http://www.dwlblog.网址/schedule/index.html","excerpt":"","text":""},{"title":"文章标签","date":"2020-06-17T05:47:40.000Z","updated":"2020-06-17T07:45:30.469Z","comments":true,"path":"tags/index.html","permalink":"http://www.dwlblog.网址/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式——单例模式","slug":"设计模式之单例模式","date":"2020-06-17T12:04:57.000Z","updated":"2020-06-17T12:14:40.329Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"单例模式 今天就开始分析第一个设计模式，该模式是：【单例模式】，英文名称：Singleton Pattern，这个模式很简单，一个类型只需要一个实例，他是创建型的设计模式。为什么叫“创建型”设计模式呢，因为他们有分类。当然了分类的方式不一样，分类的结果也就不一样。 从目的来看： -创建型（Creational）模式：负责对象创建 -结构型（Structural）模式：处理类与对象间的组合 -行为型（Behavioral）模式：类与对象交互中的职责分配 从范围来看： -类模式处理类与子类的静态关系 -对象模式处理对象间的动态关系 以上就是分类的方式，我们按大多数的分类，采用“从目的来看”的分类来对设计模式进行分类。 1.定义：1.1 动机（Motivate） 在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。 1.2、意图（Intent） 某一个类只有一个实例，并且这个实例是在类内部进行实例化，并向整个系统提供该实例。 1.3、结构图（Structure） 1.4、单例模式的组成 单件实例（Singleton）：这个模式里面只有一个类型，就是Singleton类型，并且这个类只有一个实例，可以通过Instance()方法获取该类型的实例。 2.单例模式的通用代码：public sealed class Singleton { private static sealed Singleton _singleton = new Singleton(); private Singleton() { } public static Singleton GetInstance() { return _singleton; } public static void DoSomething() { } }3.优点：（1）、实例控制：Singleton 会阻止其他对象实例化其自己的 Singleton 对象的副本，从而确保所有对象都访问唯一实例 （2）、灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程4.单例模式使用场景（1）、当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。 （2）、当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。5.线程安全的单例模式：总结 本质：内存只能有一个对象； 使用场景：定时器；计数器；一个项目只要一个共享访问点和共享数据；创建对象消耗资源比较多，如IO操作和数据库读取注意； 线程安全的单例模式代码： public sealed class Singleton { private static Singleton _singleton = null; private static readonly object _synLock = new object(); private Singleton(){} public static Singleton GetInstance() { lock (_synLock) { if (_singleton==null) _singleton = new Singleton(); return _singleton; } } }","categories":[{"name":"C#","slug":"C","permalink":"http://www.dwlblog.网址/categories/C/"},{"name":"设计模式","slug":"C/设计模式","permalink":"http://www.dwlblog.网址/categories/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.dwlblog.网址/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"并发编程-并发模型对比","slug":"并发简略-对比并发模型","date":"2020-06-17T07:05:27.000Z","updated":"2020-06-17T07:15:38.154Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 并发模型总结 多进程： 稳定性高：进程地址空间互相独立，一个进程出现问题，不会影响其他进程。Linux系统是个典型的多进程模型，稳定性极高，适合服务端开发 开销很大 多线程： 开销较小 协程： 程序执行效率高 非阻塞I/O： 无需痛苦的同步编程 交换数据方式： 多进程交换数据方式复杂（管道、消息队列、信号量、共享内存） 多线程之间交换数据很简单，但会产生竞态条件，需要解决同步问题 综合而言，多线程方式具备大量优势，但是在处理信号、同时运行多套不同程序以及包含多个需要超大内存支持的任务等，多进程方式更适合，而协程和非阻塞IO则更能充分的提升程序的运行效率。 二 线程不一定比进程轻量理论上，线程之间共享内存，创建新线程的时候不需要创建真正的虚拟内存空间，也不需要 MMU（内存管理单元）上下文切换。此外，线程间通信比进程之间通信更加简单，主要是因为线程之间有共享内存，而进程通信往往需要利用各种模式的 IPC（进程间通信），如信号量，消息队列，管道等。 但是在多处理器操作系统中，线程并不一定比进程更高效：例如 Linux 就是不区分线程和进程的，两者在 Linux 都被称作任务（task）。每个任务在 cloned 的时候都有一个介于最小到最大之间的共享级别。 调用 fork() 创建任务时，创建的是一个没有共享文件描述符，PID 和内存空间的新任务。而调用 pthread_create() 创建任务时，创建的任务将包含上述所有共享资源。 线程之间保持共享内存与多核的L1缓存中的数据同步，与在隔离内存中运行不同的进程相比，需要付出更加大的代价。 三 线程的改进方向线程变慢的主要三个原因： 线程自身有一个很大的堆（≥ 1MB）占用了大量内存，如果一下创建 1000 个线程意味着需要 1GB 的内存！！！！！ 线程需要重复存储许多寄存器，其中一些包括 AVX（高级向量扩展），SSE（流式 SIMD 外设），浮点寄存器，程序计数器（PC），堆栈指针（SP），这会降低应用程序性能。 线程创建和消除需要调用操作系统以获取资源（例如内存），而这一操作相对是比较慢的。 四 goroutineGoroutines 是在 Golang 中执行并发任务的方式，不过要切记： Goroutines仅存在于 Go 运行时而不存在于 OS 中，因此需要 Go调度器（GoRuntimeScheduler） 来管理它们的生命周期。 Go运行时为此维护了三个C结构（https://golang.org/src/runtime/runtime2.go）： G 结构：表示单个 Goroutine，包含跟踪其堆栈和当前状态所需的对象。还包含自己负责的代码的引用。 M 结构：表示 OS 线程。包含一些对象指针，例如全局可执行的 Goroutines 队列，当前运行的 Goroutine，它自己的缓存以及对 Go 调度器的引用。 P 结构：也做Sched结构，它是一个单一的全局对象，用于跟踪 Goroutine 和 M 的不同队列以及调度程序运行时需要的其他一些信息，例如单一全局互斥锁（Global Sched Lock）。 G 结构主要存在于两种队列之中，一个是 M （线程）可以找到任务的可执行队列，另外一个是一个空闲的 Goroutine 列表。调度程序维护的 M（执行线程）只能每次关联其中一个队列。为了维护这两种队列并进行切换，就必须维持单一全局互斥锁（Global Sched Lock）。 因此，在启动时，go 运行空间会为 GC，调度程序和用户代码启动许多 Goroutine。并创建 OS 线程来处理这些 Goroutine。不过创建的线程数量最多可以等于 GOMAXPROCS（默认为 1，但为了获得最佳性能，通常设置为计算机上的处理器数量）。 五 协程对比线程的改进为了使运行时的堆栈更小，go 在运行期间使用了大小可调整的有限堆栈，并且初始大小只有 2KB/goroutine。新的 Goroutine 通常会分配几 kb 的空间，这几乎总是足够的。如果不够的话，运行空间还能自动增长（或者缩小）内存来实现堆栈的管理，从而让大部分 Goroutine 存在于适量的内存中。每个函数调用的平均 CPU 开销大概是三个简单指令。因此在同一地址空间中创建数十万个 Goroutine 是切实可行的。但是如果 Goroutine 是线程的话，系统资源将很快被消耗完。 六 协程阻塞当 Goroutine 进行阻塞调用时，例如通过调用阻塞的系统调用，这时调用的线程必须阻塞，go 的运行空间会操作自动将同一操作系统线程上的其他 Goroutine，将它们移动到从调度程序（Sched Struct）的线程队列中取出的另一个可运行的线程上，所以这些 Goroutine 不会被阻塞。因此，运行空间应至少创建一个线程，以继续执行不在阻塞调用中的其他 Goroutine。 而且关键的是程序员是看不到这一点的。结论是，我们称之为 Goroutines 的事物，可以是很低廉的：它们在堆栈的内存之外几乎没有开销，而内存中也只有几千字节。 Go 协程也可以很好地扩展。 但是，如果你使用只存在于 Go 的虚拟空间的 channels 进行通信（产生阻塞时），操作系统将不会阻塞该线程。 只是让该 Goroutine 进入等待状态，并安排另一个可运行的 Goroutine（来自 M 结构关联的可执行队列）它的位置。 七 Go Runtime SchedulerGo Runtime Scheduler 跟踪记录每个 Goroutine，并安排它们依次地在进程的线程池中运行。 Go Runtime Scheduler 执行协作调度，这意味着只有在当前 Goroutine 阻塞或完成时才会调度另一个 Goroutine，这通过代码可以轻松完成。这里有些例子： 调用系统调用如文件或网络操作阻塞时 因为垃圾收集被停止后 这样比定时阻塞并调度新线程的抢占式调度要好得多，因为当线程数量增加，或者当高优先级任务将被调度运行时，有低优先级的任务已经在运行了（此时低优先级队列将被阻塞），定时抢占调度可能导致某些任务完成花费的时间大大超过实际所需时间。 另一个优点是，因为 Goroutine 在代码中隐式调用的，例如在睡眠或 channel 等待期间，编译只需要安全地恢复在这些时刻处存活的寄存器。在 Go 中，这意味着在上下文切换期间仅更新 3 个寄存器，即 PC，SP 和 DX（数据寄存器） 而不是所有寄存器（例如 AVX，浮点，MMX）。 八 goroutine 与 coroutineC#、 Lua、 Python语言都支持协程 coroutine（Java也有一些第三方库支持）。 coroutine与 goroutine都可以将函数或者语句在独立的环境中运行，但是它们之间有两点不同： goroutine可能发生并行执行，coroutine始终顺序执行 goroutine 使用 channel 通信，coroutine 使用 yield 和 resume coroutine 程序需要主动交出控制权，宿主才能获得控制权并将控制权交给其他 coroutine coroutine 的运行机制属于协作式任务处理。在早期的操作系统中，应用程序在不需要使用 CPU 时，会主动交出 CPU 使用权。如果开发者故意让应用程序长时间占用 CPU，操作系统也无能为力。coroutine 始终发生在单线程。 goroutine可能发生在多线程环境下， goroutine无法控制自己获取高优先度支持 goroutine 属于抢占式任务处理，和现有的多线程和多进程任务处理非常类似。应用程序对 CPU 的控制最终还需要由操作系统来管理，操作系统如果发现一个应用程序长时间大量地占用 CPU，那么用户有权终止这个任务。 九 Go协程总结Go协程的特点： 有独立的栈空间 共享程序堆空间 调度由用户控制 注意： Go程序在启动时，就会为main函数创建一个默认的goroutine，也就是入口函数main本身也是一个协程 如果主线程退出了，则协程即使还没有执行完毕也退出 单纯的将函数并发执行是没有意义的，函数与函数之间必须能够交换数据才能体现并发执行函数的意义。为了实现数据的通信，有两种常见并发模型： 共享数据：一般使用共享内存方式来共享数据，Go中的实现方式为互斥锁（sync包）。 消息：消息机制认为每个并发单元都是独立个体，拥有自己的变量。不同的并发单元之间不共享各自的变量，只通过消息来进行数据输入输出，Go中的实现方式为channle。 在Go中对上述两种方式都进行了实现，但是Go不推荐共享数据方式，推荐channel的方式进行协程通信。因为多个 goroutine 为了争抢数据，容易发生竞态问题，会造成执行的低效率，使用队列的方式是最高效的， channel 就是一种队列一样的结构。 如图所示： channel特性： channel的本质是一个数据结构-队列，先进先出 channel是线程安全的，多goroutine访问时，不需要加锁，因为在任何时候，同时只能有一个goroutine访问通道。 channel拥有类型，一个string的channle只能存放string类型数据 golang奉行通过通信来共享内存，而不是通过共享内存来通信。","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"},{"name":"并发编程","slug":"Go学习/并发编程","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"并发编程-协程","slug":"并发简略-协程","date":"2020-06-17T07:04:37.000Z","updated":"2020-06-17T07:16:32.233Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 理解协程 协程：也称为纤程（Coroutine）, 是一个特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处外继续运行。 协程与进程、线程相比并不是一个维度的概念，协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。 正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程（目前的协程框架一般都是设计成 1:N 模式）。 注意： 多个进程或一个进程内的多个线程是可以并行运行的 一个线程内的多个协程却是串行的，无论CPU有多少个核，因为协程本质上还是一个函数，当一个协程运行时，其它协程必须挂起 但是协程的切换过程只有用户态，即没有陷入内核态，因此切换效率比进程和线程高很多 协程自己会主动适时的让出 CPU，也就是说每个协程池里面有一个调度器，这个调度器是被动调度的。意思就是他不会主动调度。而且当一个协程发现自己执行不下去了（比如异步等待网络的数据回来，但是当前还没有数据到)，这个时候就可以由这个协程通知调度器，这个时候执行到调度器的代码，调度器根据事先设计好的调度算法找到当前最需要 CPU 的协程。切换这个协程的 CPU 上下文把 CPU 的运行权交个这个协程，直到这个协程出现执行不下去需要等等的情况，或者它调用主动让出 CPU 的 API 之类，触发下一次调度。 二 协程的优缺点优点： 占用小：协程更加轻量，创建成本更小，降低了内存消耗，协程一般只占据极小的内存（2~5KB），而线城市1MB左右。虽然线程和协程都是独有栈，但是线程栈是固定的，比如在Java中，基本是2M，假如一个栈只有一个打印方法，还要为此开辟一个2M的栈，就太浪费了。而Go的的协程具备动态收缩功能，初始化为2KB，最大可达1GB 运行效率高：线程切换需要从用户态-&gt;内核态-&gt;用户态，而协程切换是在用户态上，即用户态-&gt;用户态-&gt;用户态，其切换过程由语言层面的调度器（coroutine）或者语言引擎（goroutine）实现。 减少了同步锁：协程最终还是运行在线程上，本质上还是单线程运行，没有临界区域的话自然不需要锁的机制。多协程自然没有竞争关系。但是，如果存在临界区域，依然需要使用锁，协程可以减少以往必须使用锁的场景 同步代码思维写出异步代码 缺点： 无法利用多核资源：协程运行在线程上，单线程应用无法很好的利用多核，只能以多进程方式启动。 协程不能有阻塞操作：线程是抢占式，线程在遇见IO操作时候，线程从运行态→阻塞态，释放cpu使用权。这是由操作系统调度。协程是非抢占式，如果遇见IO操作时候，协程是主动释放执行权限的，如果无法主动释放，程序将阻塞，无法往下执行，随之而来是整个线程被阻塞。 CPU密集型不是长处：假设这个线程中有一个协程是 CPU 密集型的他没有 IO 操作，也就是自己不会主动触发调度器调度的过程，那么就会出现其他协程得不到执行的情况，所以这种情况下需要程序员自己避免。 应用场景： 高性能计算，牺牲公平性换取吞吐。协程最早来自高性能计算领域的成功案例，协作式调度相比抢占式调度而言，可以在牺牲公平性时换取吞吐 IO Bound 的任务：虽然异步IO在数据到达的时候触发回调，减少了线程切换带来性能损失，但是该思想不符合人类的思维模式。异步回调在破坏点思维连贯性的同时也破坏掉了程序的连贯性，让你在阅读程序的时候花费更多的精力。但是协程可以很好解决这个问题。比如把一个 IO 操作 写成一个协程。当触发 IO 操作的时候就自动让出 CPU 给其他协程。要知道协程的切换很轻的。协程通过这种对异步 IO 的封装既保留了性能也保证了代码的容易编写和可读性。 三 协程的简单实现ES6提供了一种新的方法名叫Generator。Generator的执行过程可以被暂停和恢复，所以它被认为是ES6中的协程，但严格地说，Generator只是半协程（semi-coroutine），因为虽然它可以主动放弃执行权，但是它并没有告知运行环境，下一步哪个协程会被调用。当一个Generator被调用时，它的代码并不会被执行，调用者得到的是它的观察者（Observer）。调用者通过调用这个观察者的方法，比如next方法，来执行Generator的代码。 123456789101112131415161718192021222324252627282930313233const Q = [];const Q_LEN = 10;function* produce() &#123; while (Q.length &lt; Q_LEN) &#123; const item = Date.now(); Q.push(item); console.log(`Item $&#123;item&#125; is produced`); if (Q.length === Q_LEN) &#123; yield; &#125; &#125;&#125;function* consume() &#123; while (Q.length &gt; 0) &#123; const item = Q.pop(); console.log(`Item $&#123;item&#125; is consumed`); if (Q.length === 0) &#123; yield; &#125; &#125;&#125;function bootstrap() &#123; const producer = produce(); const consumer = consume(); while(true) &#123; producer.next(); consumer.next(); &#125;&#125;bootstrap(); 在上面代码中，produce和consume是两个协程。bootstrap方法是这两个协程的调用者，它首先获取produce和consume协程的观察者，然后循环调用观察者的next方法，从而使得生产者和消费者的关系持续运行。在循环过程中，如果produce检测队列已满，它就主动放弃执行权从而被暂停，consume将获得执行权，如果consume检测队列已空，它就主动放弃执行权从而被暂停，produce将重新获得执行权。","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"},{"name":"并发编程","slug":"Go学习/并发编程","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"并发编程-非阻塞IO","slug":"并发简略-非阻塞IO","date":"2020-06-17T06:56:37.000Z","updated":"2020-06-17T07:17:18.066Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 深入理解进程阻塞进程间的通信时通过 send() 和 receive() 两种基本操作完成的。具体如何实现这两种基础操作，存在着不同的设计： 消息的传递有可能是阻塞的或非阻塞的，也被称为同步或异步的。—-《操作系统概论》 阻塞式发送：blocking send，发送方进程会被一直阻塞，直到消息被接受方进程收到 非阻塞式发送：nonblocking send），发送方进程调用 send() 后，立即就可以其他操作 阻塞式接收：blocking receive，接收方调用 receive() 后一直阻塞，直到消息到达可用 非阻塞式接受：nonblocking receive，接收方调用 receive() 函数后，要么得到一个有效的结果，要么得到一个空值，即不会被阻塞。 上述不同类型的发送方式和不同类型的接收方式，可以自由组合，即从进程级通信的维度讨论时， 阻塞和同步（非阻塞和异步）就是一对同义词， 且需要针对发送方和接收方作区分对待。 概念解释： 中断（interrupt）：CPU 微处理器有一个中断信号位， 在每个CPU时钟周期的末尾, CPU会去检测那个中断信号位是否有中断信号到达， 如果有，则会根据中断优先级决定是否要暂停当前执行的指令， 转而去执行处理中断的指令。 （其实就是 CPU 层级的 while 轮询） 时钟中断( Clock Interrupt )：一个硬件时钟会每隔一段（很短）的时间就产生一个中断信号发送给 CPU，CPU 在响应这个中断时， 就会去执行操作系统内核的指令， 继而将 CPU 的控制权转移给了操作系统内核， 可以由操作系统内核决定下一个要被执行的指令。 系统调用（system call）：system call 是操作系统提供给应用程序的接口。 用户通过调用 systemcall 来完成那些需要操作系统内核进行的操作， 例如硬盘， 网络接口设备的读写等。 进程在从用户空间切换到内核空间，需要以下步骤： 1.当一个程序正在执行的过程中， 中断（interrupt） 或 系统调用（system call） 发生可以使得 CPU 的控制权会从当前进程转移到操作系统内核。 2.操作系统内核负责保存进程i在 CPU 中的上下文（程序计数器，寄存器）到 PCB$_i$（操作系统分配给进程的一个内存块）中 3.从PCB$_j$取出进程 j 的CPU 上下文， 将 CPU 控制权转移给进程 j ， 开始执行进程 j 的指令。 操作系统在进行进切换时，需要进行一系列的内存读写操作， 这带来了一定的开销：对于一个运行着 UNIX 系统的现代 PC 来说， 进程切换至少需要花费 300 us 的时间。我们所说的 “阻塞”是指进程在发起了一个系统调用（System Call） 后，由于该系统调用的操作不能立即完成，需要等待一段时间，于是内核将进程挂起为等待 （waiting）状态， 以确保它不会被调度执行， 占用 CPU 资源。 综上所述，阻塞和非阻塞描述的是进程的一个操作是否会使得进程转变为“等待”的状态，又因为阻塞这个词是与系统调用 System Call 紧紧联系在一起的， 因为要让一个进程进入 等待（waiting） 的状态，要么是它主动调用 wait() 或 sleep() 等挂起自己的操作，要么是它调用 System Call， 而 System Call 因为涉及到了 I/O 操作，不能立即完成，于是内核就会先将该进程置为等待状态，调度其他进程的运行，等到它所请求的 I/O 操作完成了以后，再将其状态更改回 ready 。 操作系统内核在执行 System Call 时， CPU 需要与 IO 设备完成一系列物理通信上的交互， 其实再一次会涉及到阻塞和非阻塞的问题， 例如， 操作系统发起了一个读硬盘的请求后， 其实是向硬盘设备通过总线发出了一个请求，它即可以阻塞式地等待IO 设备的返回结果，也可以非阻塞式的继续其他的操作。 在现代计算机中，这些物理通信操作基本都是异步完成的， 即发出请求后， 等待 I/O 设备的中断信号后， 再来读取相应的设备缓冲区。 但是，大部分操作系统默认为用户级应用程序提供的都是阻塞式的系统调用 （blocking systemcall）接口， 因为阻塞式的调用，使得应用级代码的编写更容易（代码的执!行顺序和编写顺序是一致的）。 但同样，现在的大部分操作系统也会提供非阻塞I/O 系统调用接口（Nonblocking I/O system call）。 一个非阻塞调用不会挂起调用程序， 而是会立即返回一个值，表示有多少bytes 的数据被成功读取（或写入）。 非阻塞I/O 系统调用( nonblocking system call )的另一个替代品是 异步I/O系统调用 （asychronous system call）。 与非阻塞 I/O 系统调用类似，asychronous system call 也是会立即返回， 不会等待 I/O 操作的完成， 应用程序可以继续执行其他的操作， 等到 I/O 操作完成了以后，操作系统会通知调用进程（设置一个用户空间特殊的变量值 或者 触发一个 signal 或者 产生一个软中断 或者 调用应用程序的回调函数）。 非阻塞I/O 系统调用( nonblocking system call ) 和 异步I/O系统调用 （asychronous system call）的区别是： 一个非阻塞I/O 系统调用 read() 操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。 异步I/O系统调用 read（）结果必须是完整的，但是这个操作完成的通知可以延迟到将来的一个时间点。 总结： 阻塞/非阻塞， 同步/异步的概念要注意讨论的上下文 在进程通信层面， 阻塞/非阻塞， 同步/异步基本是同义词， 但是需要注意区分讨论的对象是发送方还是接收方，发送方阻塞/非阻塞（同步/异步）和接收方的阻塞/非阻塞（同步/异步） 是互不影响的。 在 IO 系统调用层面（ IO system call ）层面， 非阻塞IO 系统调用 和 异步IO 系统调用存在着一定的差别， 它们都不会阻塞进程， 但是返回结果的方式和内容有所差别， 但是都属于非阻塞系统调用（ non-blocing system call ） 阻塞系统调用（non-blocking I/O system call 与 asynchronous I/O system call） 的存在可以用来实现线程级别的 I/O 并发， 与通过多进程实现的 I/O 并发相比可以减少内存消耗以及进程切换的开销。 二 I/O模型总结2.0 I/O模型汇总Unix网络编程中，可以利用的IO模型有5种： 阻塞IO 非阻塞IO 多路复用IO 信号驱动IO 异步IO 2.1 阻塞I/O模型阻塞I/O是最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。 典型的阻塞IO模型的例子为： 1data = socket.read(); 如果数据没有就绪，就会一直阻塞在read()方法。 2.2 非阻塞IO模型当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。 所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU，典型的非阻塞IO模型一般如下： 1234567while(true)&#123; data = socket.read(); if(data!= error)&#123; // 处理数据 break; &#125; &#125; 但是对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。 2.3 多路复用IO模型多路复用IO模型是目前使用得比较多的模型，如Java的NIO。在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。 在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。 采用 多线程+ 阻塞IO 也能达到类似的效果，但是此时每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。而多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。 另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态是通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。 不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。 2.4 信号驱动I/O模型在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。 2.5 异步IO模型异步IO模型是最理想的IO模型：当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它收到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，接着将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。在此过程中用户线程完全不需要知道实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。 在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作。 异步IO是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO。也只有异步IO才真正的异步IO，其他的IO模型都是同步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。 二 高性能I/O设计模式2.1 多进程每到达一个请求， 们为这个请求新创建一个进程来处理。这样，一个进程在等待 IO 时，其他的进程可以被调度执行，更加充分地利用 CPU 等资源。但是每新创建一个进程都会消耗一定的内存空间，且进程切换也会有时间消耗，高并发时，大量进程来回切换的时间开销会变得明显起来。 2.2 多线程模式在传统的网络服务设计模式中，有两种比较经典的模式：一种是 多线程，一种是线程池。 对于多线程模式，也就说来了client，服务器就会新建一个线程来处理该client的读写事件，如下图所示： 这种模式虽然处理起来简单方便，但是由于服务器为每个client的连接都采用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，再有用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。 2.3 线程池模式为了解决这种一个线程对应一个客户端模式带来的问题，提出了采用线程池的方式，也就说创建一个固定大小的线程池，来一个客户端，就从线程池取一个空闲线程来处理，当客户端处理完读写操作之后，就交出对线程的占用。因此这样就避免为每一个客户端都要创建线程带来的资源浪费，使得线程可以重用。 2.4 Reactor模式在Reactor模式中，会先对每个client注册感兴趣的事件，然后有一个线程专门去轮询每个client是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理完之后，便再转去继续轮询，如下图所示： 从这里可以看出，上面的五种IO模型中的多路复用IO就是采用Reactor模式。注意，上面的图中展示的 是顺序处理每个事件，当然为了提高事件处理速度，可以通过多线程或者线程池的方式来处理事件。 2.5 Proactor模式在Proactor模式中，当检测到有事件发生时，会新起一个异步操作，然后交由内核线程去处理，当内核线程完成IO操作之后，发送一个通知告知操作已完成，可以得知，异步IO模型采用的就是Proactor模式。 三 杰出代表Node.jsNode.js是在v8引擎基础上开发的javascript运行时，为javascript提供了模块化、文件IO、Socket编程等支持。其架构如图所示： 他们分别是： Node.js 标准库，这部分是由 Javascript编写的，即我们使用过程中直接能调用的 API。在源码中的 lib 目录下可以看到。 Node bindings，这一层是 Javascript与底层 C/C++ 能够沟通的关键，前者通过 bindings 调用后者，相互交换数据。实现在 node.cc 这一层是支撑 Node.js 运行的关键，由 C/C++ 实现。 V8：Google 推出的 Javascript VM，也是 Node.js 为什么使用的是 Javascript的关键，它为 Javascript提供了在非浏览器端运行的环境，它的高效是 Node.js 之所以高效的原因之一。 Libuv：它为 Node.js 提供了跨平台，线程池，事件池，异步 I/O 等能力，是 Node.js 如此强大的关键。 C-ares：提供了异步处理 DNS 相关的能力。 http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力。 一个基础的node http web server： 1234567const http = require('http');http.createServer((req, res) =&gt; &#123; res.writeHeader(200, &#123;\"Content-Type\" : \"text/plain\"&#125;); res.write(\"Hello world!\"); res.end();&#125;).listen(9000); Node.js的http模型： Node中的事件驱动：Event Loop is a programming construct that waits for and dispatches events or messages in a program 1、每个Node.js进程只有一个主线程在执行程序代码，形成一个执行栈（execution context stack)。 2、主线程之外，还维护了一个”事件队列”（Event queue）。当用户的网络请求或者其它的异步操作到来时，node都会把它放到Event Queue之中，此时并不会立即执行它，代码也不会被阻塞，继续往下走，直到主线程代码执行完毕。 3、主线程代码执行完毕完成后，然后通过Event Loop，也就是事件循环机制，开始到Event Queue的开头取出第一个事件，从线程池中分配一个线程去执行这个事件，接下来继续取出第二个事件，再从线程池中分配一个线程去执行，然后第三个，第四个。主线程不断的检查事件队列中是否有未执行的事件，直到事件队列中所有事件都执行完了，此后每当有新的事件加入到事件队列中，都会通知主线程按顺序取出交EventLoop处理。当有事件执行完毕后，会通知主线程，主线程执行回调，线程归还给线程池。 4、主线程不断重复上面的第三步。","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"},{"name":"并发编程","slug":"Go学习/并发编程","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"并发编程-多线程","slug":"并发简略-多线程","date":"2020-06-17T06:54:37.000Z","updated":"2020-06-17T07:17:07.294Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 线程概述1.1 进程与线程创建操作系统会为每个进程分配一定的内存地址空间，如图所示： 上图所示的是32位系统中虚拟内存的分配方式，不同系统分配的虚拟内存是不同的，但是其数据所占区域的比例是相同的： 32位：最大内存地址为232，这么多的字节数换算为G单位，即为4G。（换算为1G=1024MB=10241024KB=10241024*1024B） 64位：最大内存地址为264，这么多的字节数换算为G单位，数值过大，不便图示 在多进程编程的并发模型中，每次fork一个子进程，都代表新创建了一个完整的上述内存地址空间，如图所示： 线程就与进程不同了，一个进程内部可以创建多个线程，如图所示： 1.2 理解线程从创建线程的图示可以看出：线程可以视为某个进程内部的控制流。 线程：操作系统基于进程开启的轻量级进程，线程是操作系统最小的调度执行单位（即cpu分配时间轮片的对象） 线程不能独立于进程而存在，其生命周期不可能逾越其所属的进程生命周期，与进程不同，线程不存在父子级别关系，同一进程中的任意2个线程之间的关系是平等的。一个进程内部的线程包括： 主线程：必定拥有，因为进程必须有一个控制流持续运行，该线程随着进程的启动而创建 其他线程：不一定拥有，由主线程或者其他线程创建（C语言调用pthread_create函数） 综上我们可以得出： 线程与进程一样拥有独立的PCB，但是没有独立的地址空间，即线程之间共享了地址空间。这样也让线程之间无需IPC，直接就能通信！！ 进程的大多数资源会被其内部的线程所共享，如：代码段、数据段、堆、信号处理函数、当前进程持有的文件描述符等。所以，同一进程中的多个线程运行的一定是同一个程序，只不过具体的控制流和执行的函数可能不同。也正因如此，同一进程内的多线程共享数据变得很轻松，创建新线程也无需再复制资源了。 虽然线程带来了通信的便利，如果同一空间的中多个线程同时去使用同一个数据，就会造成资源竞争问题，这是计算机编程中最复杂的问题之一。 1.3 线程标识每个线程也有属于自己的ID，称为TID，只在其所属的进程范围内唯一。 注意：Linux中的线程ID在系统范围内也是唯一的，且线程不存在后，该ID可被其他线程复用。 1.4 线程调度线程之间不存在类似进程的树形关系，任何线程都可以对同一进程的其他线程进行有限的管理。 调度器会把事件划分为极小的时间片，并把这些时间片分配给不同的线程，以使众多线程都有机会在CPU上运行，也造成了我们多线程被并行运行的幻觉。 1.5 线程的应用对于多线程并发模型的web服务器，如果需要同时处理多个请求，当请求到达时，web 服务器会创建一个线程，或者从线程池中获取一个线程，然后将请求来委派给线程来实现并发。 二 线程同步2.0 同步的概念由于多进程、多线程、协程等都可以抢占共享资源，我们就必须保证他们访问时数据的一致性，这种保持数据内容一致的机制称为同步。 多个控制流操作一个共享资源的情况，都需要同步！！ 一般情况下，只要让共享区域的操作串行化，就可以实现同步，这种实现了串行化的共享区域称为临界区。 这里主要研究线程同步的方式，包括： 互斥量 条件变量 原子操作 2.1 互斥量 互斥（mutex）：在同一时刻，只允许一个线程处于临界区内。 线程将对象锁定后，才能进入临界区，否则线程就会阻塞，这个对象我们称之为互斥对象或者互斥量。 由此可知，互斥量有已锁定、未锁定两种状态，且一旦被锁，则不能再次锁定，只有解锁后才能再次锁定（即不允许别的线程二次加锁）。多个线程为了能够访问临界区，将会争夺锁的所有权。 线程在离开临界区的时候，必须对互斥量进行解锁，此时其他想进入该临界区的线程将会被唤醒再次争夺锁。 如果不同的临界区中包含了对同一个共享资源的同一种操作，此时会产生死锁。 解决死锁的办法有两种： 试锁定-回退：操作系统的线程库中提供了该功能。在执行一个代码块时，如果需要先后锁定多个互斥量，成功锁定其中一个互斥量后应该使用试锁定的方法来锁定后续互斥量，如果后续任一互斥量锁定失败，则解锁刚才被锁的互斥量，重新进行争夺锁尝试。 注意：多个互斥量被成功加锁后，解锁顺序和加锁顺序相反，这样可以减少回退次数。 固定顺序锁定：举例，线程A和线程B总是先锁定互斥量1，再锁定互斥量2，那么就不会产生死锁。 第一种方案更加有效，但是程序变得复杂了，后一种方法简单实用，但是因为存在固定顺序，降低了程序的灵活性。 2.2 条件变量互斥量有时候也不能完美解决问题，比如最常见的生产消费模型中： 123数据队列：具备一定大小的空间，用于存储生产的数据生产者线程：向数据队列不断的添加数据消费者线程：向数据队列不断的取出数据 由于生产者线程和消费者线程都会对数据队列进行并发访问，那么我们肯定会为数据队列进行加锁操作，以实现同步。 此时如果生产者线程获得互斥量，发现数据队列已满，无法添加新数据，生产者线程就可能在临界区一直等待，直到有空闲区间。这种做法明显是错误的，因为该线程一直阻塞在临界区，直接影响了其他消费者线程的使用！生产者线程应该在发现没有空闲区间时直接解锁退出。 同样的，消费者线程在获取锁后，如果发现数据队列为空，则也会一直等待，这都是不合理的，应该发现为空后直接解锁。 引入条件变量，与互斥量配合使用，可以解决上述问题。 条件变量：条件变量一般与互斥量组合使用，在对应的共享数据状态发生变化时，通知其他被阻塞线程。 条件变量有三种操作： 等待通知（wait）：如果当前数据状态不满足条件，则解锁与该条件变量绑定在一起的互斥量，然后阻塞当前线程，直到收到该条件变量发来的通知 单发通知（signal）：让条件变量向至少一个正在等待它通知的线程发送通知，以表示共享数据状态发生了改变 广播通知（broadcast）：给等待通知的所有线程发送通知 2.3 原子操作原子操作的执行过程不能被中断，因为此时CPU不会去执行其他对该值进行的操作，这也能有效的解决一部分竞争问题。","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"},{"name":"并发编程","slug":"Go学习/并发编程","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"并发编程-多进程","slug":"并发简略-多进程","date":"2020-06-17T06:42:57.000Z","updated":"2020-06-17T07:16:16.213Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 进程概念 进程：就是二进制可执行文件在计算机内存中的运行实例，可以简单理解为：一个.exe文件是个类，进程就是该类new出来的实例。进程是操作系统最小的资源分配单位（如虚拟内存资源），所有代码都是在进程中执行的。 为了方便管理进程，每个进程都有自己的描述符，是个复杂的数据结构，我们称之为进程控制块，即PCB(Process Control Block)。 PCB中保存了进程的管理、控制信息等数据，主要包含字段有： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364进程ID（PID）：进程的唯一标识符 ，是一个非负整数的顺序编号父进程ID（PPID）：当前进程的父进程ID文件描述符表：即很多指向file接否提的指针进程状态：就绪、运行、挂起、停止等状态虚拟地址范围访问权限 当前工作目录用户id和组id会话和进程组&#96;&#96;&#96; 贴士：进程ID是可以重用的，当进程ID达到最大限额值时，内核会从头开始查找闲置的进程ID并使用最先找到的那一个作为新进程的ID## 二 进程创建Unix系统在启动后，会首先运行一个名为 init 的进程，其PID 为 1。该进程是所有其他进程的父进程。 Unix操作系统通过 &#96;fork()&#96; 函数能够创建多个子进程，从而能够提升计算机资源的利用率。此时调用者称为父进程，被创造出来的进程称为子进程。 - 每个子进程都是源自它的父进程的一个副本，它会获得父进程的数据段、堆、栈的拷贝，并与父进程共享代码段。 - 子进程对自己副本的修改对其父进程和兄弟进程都是不可见的，反之亦然。 创建的子进程可以直接开始运行，但是也可以通过 &#96;exec()&#96; 函数来加载一个全新的程序，此时子进程会丢弃现存的程序文本段，为加载的新程序重新创建栈、数据段、堆，我们对这一个过程称为执行一个新程序。 贴士：exec并不是1个函数, 是一系列 exec 开头的函数，作用都是执行新程序。 C语言示例如下：&#96;&#96;&#96;c#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;#include &lt;unistd.h&gt; int main()&#123; pid_t pid; int r; &#x2F;&#x2F; 创建子进程 pid &#x3D; fork(); if (pid &#x3D;&#x3D; -1)&#123; &#x2F;&#x2F; 发生错误 perror(&quot;fork发生错误 &quot;); exit(1); &#125; &#x2F;&#x2F; 返回值大于0时是父进程 if(pid &gt; 0)&#123; printf(&quot;父进程: pid &#x3D; %d, ppid &#x3D; %d \\n&quot;, getpid(),getppid()); &#x2F;&#x2F; 父进程执行动作 sleep(3); &#x2F;&#x2F; 父进程睡眠，防止子进程还没运行完毕，父进程却直接退出了 &#125; &#x2F;&#x2F; 返回值为0的是子进程 if(pid &#x3D;&#x3D; 0)&#123; printf(&quot;子进程: pid &#x3D; %d , ppid &#x3D; %d \\n&quot;, getpid(),getppid()); &#x2F;&#x2F; 子进程执行动作 &#x2F;&#x2F; 子进程加载一个新程序：系统自带的 echo程序，输出 hello world! char * execv_str[] &#x3D; &#123;&quot;echo&quot;, &quot;hello world!&quot;,NULL&#125;; int r &#x3D; execv(&quot;&#x2F;bin&#x2F;echo&quot;, execv_str); &#x2F;&#x2F; 笔者的是mac，linux上为： &quot;&#x2F;usr&#x2F;bin&#x2F;echo&quot; if (r &lt;0 )&#123; perror(&quot;error on exec&quot;); exit(0); &#125; &#125; return 0; &#125; 在 Go 语言中，没有直接提供 fork 系统调用的封装，而是将 fork 和 execve 合二为一，具体信息可以参见Go的os包。 1234567891011121314151617181920212223242526package mainimport ( \"fmt\" \"os\" \"time\")func main() &#123; fmt.Println(\"当前进程ID：\", os.Getpid()) procAttr := &amp;os.ProcAttr&#123; Files: []*os.File&#123;os.Stdin, os.Stdout, os.Stderr&#125;, &#125; process, err := os.StartProcess(\"/bin/echo\", []string&#123;\"\", \"hello,world!\"&#125;, procAttr) if err != nil &#123; fmt.Println(\"进程启动失败:\", err) os.Exit(2) &#125; else &#123; fmt.Println(\"子进程ID：\", process.Pid) &#125; time.Sleep(time.Second)&#125; 根据该方式，就可以很容运行计算机上的其他任何程序，包括自身的命令行、Java程序等等。 四 进程分类进程分类： 用户进程：位于用户空间中，是程序执行的实例 内核进程：位于内核空间中，可以访问硬件 由于用户进程无法访问内核空间，所以无法直接操作硬件。内核会暴露一些接口提供给用户进程使用，让用户进程简介操作硬件，这便是系统调用。 内核为了保证系统的安全和稳定，为CPU特供了两个状态： 用户态：大部分时间CPU处于该状态，此时只能访问用户空间 内核态：当用户进程发起系统调用时，内核会将CPU切换到内核态，然后执行相应接口函数。 注意：这里的用户态和内核态是针对CPU的。 五 进程调度同一时刻只能运行一个进程，但是CPU可以在多个进程间进行来回切换，我们称之为上下文切换。 操作系统会按照调度算法为每个进程分配一定的CPU运行时间，称之为时间轮片，每个进程在运行时都会认为自己独占了CPU，如图所示： 切换进程是有代价的，因为必须保存进程的运行时状态。 六 进程状态转换进程在创建后，在执行过程中，其状态一直在变化。不同时代的操作系统有不同的进程模型： 三态模型：运行态、就绪态、等待态 五态模型：初始态、就绪态、运行态、挂起态（阻塞）、终止态 本笔记介绍五态模型。初始态是进程的准备节点，常与就绪状态结合来看，进程的状态转换图： 七 进程运行的问题7.1 写时复制父进程无法预测子进程什么时候结束，只有进程完成工作后，父进程才会调用子进程的终止态。 贴士：全盘复制父进程的数据相当低效，Linux使用写时复制（COW：Copy on Write）技术来提高进程的创建效率。 7.2 进程回收当一个进程退出之后，进程能够回收自己的用户区的资源，但是不能回收内核空间的PCB资源，必须由它的父进程调用wait或者waitpid函数完成对子进程的回收，避免造成系统资源的浪费。 孤儿进程：父进程先于子进程结束，则子进程成为孤儿进程，此时该进程会被系统的 init 进程领养 僵尸进程：子进程终止，但父进程未回收，子进程残留资源（PCB）于内核中，变成僵尸进程。 注意：由于僵尸进程是一个已经死亡的进程，所以不能使用kill命令将其杀死，通过杀死其父进程的方法可以消除僵尸进程，杀死其父进程后，这个僵尸进程会被init进程领养，由init进程完成对僵尸进程的回收。 八 进程间通信8.0 进程间通信方式概述Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。 在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有： 管道 (使用最简单) 共享映射区 (无血缘关系进程通信) 信号 (开销最小) 本地套接字 (最稳定) Go支持的IPC方法有：管道、信号、socket。 8.1 管道管道是一种最基本的IPC机制，也称匿名管道，应用于有血缘关系的进程之间，完成数据传递。调用C的pipe函数即可创建一个管道。 管道有如下特质： 管道的本质是一块内核缓冲区 由两个文件描述符引用，一个表示读端，一个表示写端。 规定数据从管道的写端流入管道，从读端流出。 当两个进程都终结的时候，管道也自动消失。 管道的读端和写端默认都是阻塞的。 管道的实质是内核缓冲区，内部使用唤醒队列实现。 管道的缺陷： 管道中的数据一旦被读走，便不在管道中存在，不可反复读取。 数据只能在一个方向上流动，若要实现双向流动，必须使用两个管道 只能在有血缘关系的进程间使用管道。 Go模拟管道的实现： 1234567891011121314cmd1 := exec.Command(\"ps\", \"aux\")cmd2 := exec.Command(\"grep\", \"apipe\")var outputBuf1 bytes.Buffercmd1.Stdout = &amp;outputBuf1cmd1.Start()cmd1.Wait() // 开始阻塞var outputBuf2 bytes.Buffercmd2.Stdout = &amp;outputBuf2cmd2.Start()cmd2.Wait() // 开始阻塞fmt.Println(outputBuf2.Bytes()) 当然也有一种管道称为命名管道（FIFO），它支持无血缘关系的进程之间通信。FIFO是Linux基础文件类型中的一种（文件类型为p，可通过ls -l查看文件类型）。但FIFO文件在磁盘上没有数据块，文件大小为0，仅仅用来标识内核中一条通道。进程可以打开这个文件进行read/write，实际上是在读写内核缓冲区，这样就实现了进程间通信，如图所示： 8.2 内存映射区存储映射I/O (Memory-mapped I/O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。从缓冲区中取数据，就相当于读文件中的相应字节；将数据写入缓冲区，则会将数据写入文件。这样，就可在不使用read和write函数的情况下，使用地址（指针）完成I/O操作。 使用存储映射这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现。 8.3 信号信号是IPC中唯一一种异步的通信方法，本质是用软件模拟硬件的中断机制，例如：在命令行终端按下某些快捷键，就会挂起或停止正在运行的程序。Go中的ginal包提供了相关操作。 123456sigRecv := make(chan os.Signal, 1) // 创建接收通道sigs := []os.Signal&#123;syscall.SIGINT, syscall.SIGQUIT&#125; // 创建信号类型signal.Notify(sigRecv, sigs...)for sig := range sigRecv &#123; // 循环接收通道中的信号，通道关闭后，for会立即停止 fmt.Println(sig)&#125; 8.4 socketsocket即套接字，也是一种IPC方法，与其他IPC方法不同之处在于：可以通过网络连接让多个进程建立通信并相互传递数据，这使得通信不再依赖于在同一台计算机上。 九 进程同步当多个子进程对同一资源进行访问时，就会产生竞态条件。比如：某一个数据，进程A对其进行执行一系列操作，但是在执行过程中，系统有可能会切换到另外一个进程B中，B也对该数据进行一系列操作，那么在两个进程中操作同一份数据时，这个数据的结果值到底按照谁的来运算呢？ 原子操作：如果执行过程中操作不能中断，那么就能解决上述问题，这样的操作称为原子操作（atomic operation）。这些只能被串行化访问或执行的资源或者某段代码被称为临界区（critical section）。Go中(sync/atomic包提供了原子操作函数)。 注意： 所有的系统调用都是原子操作，即不用担心它们的执行被中断！ 原子操作不能被中断，临界区是否可以被中断没有强制规定，只是保证了只能同时被一个访问者访问。 问题：如果一个原子操作无法结束，现在也无法中断，如何处理？ 答案：内核只提供了针对二进制位和整数的原子操作（即保证细粒度），不会有上述现象。 互斥锁：在实际开发中，原子操作并不通用，我们可以保证只有一个进程/线程在临界区，该做法称为互斥锁（exclusion principle），比如信号量是实现互斥方法的方式之一，Golang的sync包也有对互斥的支持。","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"},{"name":"并发编程","slug":"Go学习/并发编程","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"并发编程-概述","slug":"并发简略-概述","date":"2020-06-17T06:42:57.000Z","updated":"2020-06-17T07:18:30.646Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 并发编程历史在早期的操作系统中，各个任务的执行完全是串行的，只有在一个任务运行完成之后，另一个任务才会被执行，我们称之为单道程序。 而现代操作系统引入了多道程序的并发概念： 多道程序：当一个程序暂时不需要使用CPU的时候，系统会把该程序挂起或中断，此时其他程序可以使用CPU，多个任务在操作系统的控制中实现了宏观上的并发。多道程序提升了计算机资源的利用率，但是也引起了多个任务对系统资源的抢夺，在开发上极为不便。 二 计算机术语2.1 串行与并发串行与并发是同一个维度的概念，区别是： 串行：指令按照顺序执行 并发：指令并未按照顺序执行，而是在宏观上同时执行，即CPU不停的在各个任务之间来回切换，给人感觉所有任务同时执行了！比如电脑同时运行了QQ、浏览器，其实是CPU在这2个程序之间按照一定的调度算法在来回切换执行！ 并行与并发并不是同一个维度上的概念： 并行（parallel）：在同一时刻（微秒级），多条指令在多个处理器上同时执行，并行一般要借助多核CPU实现！ 并发（concurrency）：并未同时执行，只是由于CPU运行过快，给人产生同时运行的假象 并发与并行概念的区别是是否同时执行，比如吃饭时，电话来了，需要停止吃饭去接电话，接完电话继续吃饭，这是并发执行，但是吃饭时电话来了，边吃边接是并行。 2.2 进程 进程：就是二进制可执行文件在计算机内存中的运行实例，可以简单理解为：一个.exe文件是个类，进程就是该类new出来的实例。进程是操作系统资源分配的最小单位（如虚拟内存资源），所有代码都是在进程中执行的。 在Unix系统中，操作系统启动后将会运行进程号（PID）为1的一个进程 init 进程，该进程是所有其他进程的父进程。操作系统通过 fork() 函数能够创建多个子进程，从而能够提升计算机资源的利用率。 进程在创建后会拥有自己的独立地址空间，操作系统会提供一个数据结构PCB来描述该进程（Process Control Block，进程控制块），PCB中保存了进程的管理、控制信息等数据。 由于进程拥有互相独立的地址空间，所以进程之间无法直接通信，必须利用进程间通信(IPC,InterProcess Communication)方式来实现通信。 2.3 内核态与用户态操作系统的内存会被划分为两大区域： 内核区：提供了大量的系统调用函数，即最原生、最底层的操作函数，如 open()，write() 用户区：加载、运行应用程序的区域，比如使用C语言写的程序，同样的C语言也提供了本语言的对应操作函数 fopen()，fwrite()。这些由编程语言提供的函数称之为库函数。 我们不难发现，库函数其实是在系统调用函数基础上再次进行了封装，方便开发者使用。当然开发者既可以使用库函数来操作文件，也可以直接使用底层的系统调用函数（但是这样需要做很多错误处理）。 程序在运行时，CPU有两种状态： 用户态：当一个进程在执行用户自己的代码时处于用户运行态（用户态） 内核态：当进程需要执行一些系统调用时，比如利用C的库函数fopen()时，fopen()虽然是库函数，但是执行时底层调用了系统的open()函数，此时程序进入内核态，调用结束后，程序会重新回到用户态！ 操作系统之所以要这样设计是出于内存的安全考虑，内核地址只有内核自己的函数（系统调用函数）才能使用！ 2.4 线程 线程：操作系统基于进程开启的轻量级进程，是操作系统调度执行的最小单位（即cpu分配时间轮片的对象） 一个进程内部可以创建多个线程，他们与进程一样拥有独立的PCB，但是没有独立的地址空间，即线程之间共享了地址空间。这样也让线程之间无需IPC，直接就能通信！！（因为他们在同一个地址空间内）。 虽然线程带来了通信的便利，但是如果同一空间的中多个线程同时去修改同一个数据，就会造成资源竞争问题，这是计算机编程中最复杂的问题！ 2.5 协程进程和线程都是操作系统级别的，协程与他们并不是一个维度的概念，所以类似《现代操作系统》的书籍并未提出协程的概念。 贴士：千万不要将协程理解为轻量级线程！ 协程：程序在执行时，函数内部可以中断，适当时候返回接着执行，即协程运行在用户态 协程的优势在于其轻量级、执行效率高： 轻量级：没有线程开销，可以轻松创建上百万个协程而不会造成系统资源衰竭 执行效率高：函数之间的切换不再是线程切换，由程序自身控制 线程需要上下文不停切换，而协程不会主动交出使用权，除非代码中主动要求切换，或者发生I/O，此时会切换到别的协程，这样能更好的解决并发问题。 三 并发理论基础3.1 并发解决方案 多进程:由系统内核管理并发，操作简单、进程互不影响。但是开销最大，占用资源较多，能开启的进程数极少， 多线程:多线程在大部分系统上仍然属于系统层面的并发，开销较大，且会存在死锁管理问题。 非阻塞I/O:基于回调的异步非阻塞I/O，尽可能少的运用线程 协程:本质上仍然是用户态线程，但不需要系统进行抢占式调度，且真正的实现寄存于线程中，开销极小。 3.2 并发程序数据交互方式一：同步 线程同步：线程在发出某一个功能调用时，如果没有得到结果，则该调用不返回。此时其他线程不能调用该功能（因为要保证数据一致性）。 线程同步是为了避免引起数据混乱。实际上，多个控制流共同操作一个共享资源，都需要同步，比如：进程、线程、信号之间都需要同步机制，常见的线程同步技术就是互斥锁。 同步的作用是避免在并发访问共享资源时可能发生的冲突。 同步的理念： 程序如果想使用一个共享数据，就必须先获取对它的使用权，当程序不再使用该资源时，则应放弃对该资源的访问权(即：释放资源)。 资源的使用权被拿走后，其他访问该资源的程序不应该被中断，而是应该等到拥有使用权的程序释放资源之后再进行访问。即：在同一时刻，某个资源应该只被一个程序占用。 3.3 并发程序数据交互方式二：数据传递除了使用同步方式来实现并发程序数据的交互之外，还可以使用数据传递方式（也称为通信）。 该方式可以使数据不加延迟的发送给数据接收方。即使数据接收方还没有为接收数据做好准备，也不会造成数据发送方的等待。数据会被临时存储在一个称谓通信缓存的数据结构中。通信缓存是一种特殊的数据结构，可以同时被多个程序使用，数据接收方可以在准备就绪之后按照数据存入通信缓存的顺序接收它们。 四 各个语言的并发理念 Java：典型的多线程并发模式，利用同步机制（加锁）来实现并发访问控制 Node.js：典型的单线程非阻塞I/O实践者，不存在Java的资源竞争问题，I/O操作处理完毕后才会利用事件机制通知业务线程返回结果，没有资源竞争的难题。 Go：典型的协程并发理念实践者，在语言本身层面实现了协程，协程之间通过管道进行数据传递 目前流行的并发理念是：异步非阻塞I/O，协程。","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"},{"name":"并发编程","slug":"Go学习/并发编程","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Git使用规范","slug":"项目中的git使用规范","date":"2020-06-16T08:34:57.000Z","updated":"2020-06-17T07:25:38.650Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"祖师爷 Linus 在创造了伟大的 Linux 之后，又创造了应用最广泛的代码管理工具 —— Git，极大地提高了程序员的生产力。 现如今大部分项目都在使用 Git 作为代码管理工具，不论是在代码管理、版本控制以及团队协作上，Git 相比其他版本控制软件都有着无可比拟的优势。 虽然 Git 是个优秀的工具，但是在项目中是否能够正确合理地使用，是否能够发挥其最大的优势，就我自己这几年的工作经历来看，对于大部分团队这个问题的答案是否定的。 大部分程序员对 Git 的使用基本上都停留在 git add、git commit、git push、git pull 这几个指令上，而且大部分团队也没有 Git 规范，提交信息充斥着大量的 “fix”、“update”，分支管理也很混乱，代码提交哪个分支上也没具体的规定，导致在团队协作过程中经常出现代码合并后谁的代码不见了，修过的 bug 在新版本又出现了……0. 我们可能面临的问题 试想遇到以下这些问题，你会采取怎样的方式去解决： * 需要线上某个历史版本的源码，直接在 develop 分支根据提交记录和时间找对应的节点？ * 线上版本出现严重 bug 需要紧急修复发版本，而你的项目就一个分支，上个版本发布之后已经有大量改动了，怎么办？ * 某个提交改动了部分代码，涉及到 10 几个文件，现在这个改动不需要了，此时要一个个找出这些文件然后再改回去么？ * 出现了一个 bug，之前好像处理过，但是现在忘了当初怎么处理的了，在一堆写着 “fix bug”、“update” 的提交记录中，如何找到当初那笔的提交？ * 某个功能本来准备发布的，现在突然决定这个版本不上了，现在要一处处找到之前的代码，然后再改回去？ * ……以上这些问题在我们的项目中都是会或多或少出现的，部分问题可能涉及到的是对 Git 的功能是否熟悉的问题，大部分问题则是涉及到一个项目的 Git 使用规范问题，如果有一个很好的规范，在项目中合理地使用 Git，很多问题压根就不是问题。 Git 规范的必要性 既然认同需要一份 Git 规范，那么这个规范需要规范哪些内容，解决哪些问题，又带来哪些好处呢？个人认为有以下几点： 分支管理 代码提交在应该提交的分支 随时可以切换到线上稳定版本代码 多个版本的开发工作同时进行 提交记录的可读性 准确的提交描述，具备可检索性 合理的提交范围，避免一个功能就一笔提交 分支间的合并保有提交历史，且合并后结果清晰明了 避免出现过多的分叉 团队协作 明确每个分支的功用，做到对应的分支执行对应的操作 合理的提交，每次提交有明确的改动范围和规范的提交信息 使用 Git 管理版本迭代、紧急线上 bug fix、功能开发等任务 以上就是一份 Git 规范的作用和使命。 接下来结合 Git-Flow 和个人实际的项目经验，总结了一份项目中使用 Git 的规范，其中大部分内容都是对 Git-Flow 进行一个解读和扩展，告诉大家为什么这么做以及怎么做。 这里也推荐一下 Git-Flow 相关的内容： A successful Git branching model » nvie.com这是一份 2010 年提出来的分支管理规范，距今已过去 8 年了，但是其工作流程至今还是适用的，也衍生出很多优秀的开发流程。 以下就是 Git-Flow 的经典流程图：如果你熟悉 Git-Flow，那么你对上图中的各种分支和线应该都能够理解，如果你之前没了解过相关的知识，那你可能会有点懵，不过在读完本文之后再看这张图，应该就能够理解了。2. 分支管理规范2.1 分支说明和操作 master 分支 主分支，永远处于稳定状态，对应当前线上版本 以 tag 标记一个版本，因此在 master 分支上看到的每一个 tag 都应该对应一个线上版本 不允许在该分支直接提交代码 develop 分支 开发分支，包含了项目最新的功能和代码，所有开发都依赖 develop 分支进行 小的改动可以直接在 develop 分支进行，改动较多时切出新的 feature 分支进行 注： 更好的做法是 develop 分支作为开发的主分支，也不允许直接提交代码。小改动也应该以 feature 分支提 merge request 合并，目的是保证每个改动都经过了强制代码 review，降低代码风险 feature 分支 功能分支，开发新功能的分支 开发新的功能或者改动较大的调整，从 develop 分支切换出 feature 分支，分支名称为 feature/xxx 开发完成后合并回 develop 分支并且删除该 feature/xxx 分支 release 分支 发布分支，新功能合并到 develop 分支，准备发布新版本时使用的分支 当 develop 分支完成功能合并和部分 bug fix，准备发布新版本时，切出一个 release 分支，来做发布前的准备，分支名约定为release/xxx 发布之前发现的 bug 就直接在这个分支上修复，确定准备发版本就合并到 master 分支，完成发布，同时合并到 develop 分支 hotfix 分支 紧急修复线上 bug 分支 当线上版本出现 bug 时，从 master 分支切出一个 hotfix/xxx 分支，完成 bug 修复，然后将 hotfix/xxx 合并到 master 和 develop 分支(如果此时存在 release 分支，则应该合并到 release 分支)，合并完成后删除该 hotfix/xxx 分支以上就是在项目中应该出现的分支以及每个分支功能的说明。 其中稳定长期存在的分支只有 master 和 develop 分支，别的分支在完成对应的使命之后都会合并到这两个分支然后被删除。简单总结如下： master 分支: 线上稳定版本分支 develop 分支: 开发分支，衍生出 feature 分支和 release 分支 release 分支: 发布分支，准备待发布版本的分支，存在多个，版本发布之后删除 feature 分支: 功能分支，完成特定功能开发的分支，存在多个，功能合并之后删除 hotfix 分支: 紧急热修复分支，存在多个，紧急版本发布之后删除2.2 分支间操作注意事项 在团队开发过程中，避免不了和其他人一起协作，\b 同时也会遇到合并分支等一些操作，这里提交 2 个个人觉得比较好的分支操作规范。 同一分支 git pull 使用 rebase 首先看一张图： 看到这样的 \b 提交线图，想从中看出一条清晰的提交线几乎是不可能的，充满了 Merge remote-tracking branch ‘origin/xxx’ into xxx 这样的提交记录，同时也将提交线弄成了交错纵横的图，没有了可读性。 这里最大的原因就是因为默认的 git pull 使用的是 merge 行为，当你更新代码时，如果本地存在未推送到远程的提交，就会产生一个这样的 merge 提交记录。因此在同一个分支上更新代码时推荐使用 git pull --rebase。 下面这张图展示了默认的 git pull 和 git pull --rebase 的结果差异，使用 git pull --rebase 目的是修整提交线图，使其形成一条直线。 默认的 git pull 行为是 merge，可以进行如下设置修改默认的 git pull 行为： # 为某个分支单独设置，这里是设置 dev 分支 git config branch.dev.rebase true # 全局设置，所有的分支 git pull 均使用 --rebase git config --global pull.rebase true git config --global branch.autoSetupRebase always 这里需要说明一下，在我看来使用 git pull --rebase 操作是比较好的，能够得到一条很清晰的提交直线图，方便查看提交记录和 code review，但是由于 rebase 会改变提交历史，也存在一些不好的影响。这里就不做过多的讨论了，有兴趣的话可以移步知乎上的讨论：在开发过程中使用 git rebase 还是 git merge，优缺点分别是什么？ 分支合并使用 --no-ff # 例如当前在 develop 分支，需要合并 feature/xxx 分支 git merge --no-ff feature/xxx 在解释这个命令之前，先解释下 Git 中的 fast-forward： 举例来说，开发一直在 develop 分支进行，此时有个新功能需要开发，新建一个 feature/a 分支，并在其上进行一系列开发和提交。当完成功能开发时，此时回到 develop 分支，此时 develop 分支在创建 feature/a 分支之后没有产生任何的 commit，那么此时的合并就叫做 fast-forward。 fast-forward 合并的结果如下图所示，这种 merge 的结果就是一条直线了，无法明确看到切出一个新的 feature 分支，并完成了一个新的功能开发，因此此时比较推荐使用 git merge --no-ff，得到的结果就很明确知道，\b新的一系列提交是完成了一个新的功能，如果需要对这个功能进行 code review，那么只需要检视叉的那条线上的提交即可。 关于以上两个分支间的操作建议，如果需要了解更多，可以阅读洁癖者用 Git：pull –rebase 和 merge –no-ff 这篇文章。 2.3 项目分支操作流程示例 这部分内容结合日常项目的开发流程，涉及到开发新功能、分支合并、发布新版本以及发布紧急修复版本等操作，展示常用的命令和操作。 切到 develop 分支，更新 develop 最新代码 git checkout develop git pull --rebase 新建 feature 分支，开发新功能 git checkout -b feature/xxx ... git add &lt;files&gt; git commit -m &quot;feat(xxx): commit a&quot; git commit -m &quot;feat(xxx): commit b&quot; # 其他提交 ... 如果此时 develop 分支有一笔提交，影响到你的 feature 开发，可以 rebase develop 分支，前提是 该 feature 分支只有你自己一个在开发，如果多人都在该分支，需要进行协调： # 切换到 develop 分支并更新 develop 分支代码 git checkout develop git pull --rebase # 切回 feature 分支 git checkout feature/xxx git rebase develop # 如果需要提交到远端，且之前已经提交到远端，此时需要强推(强推需慎重！) git push --force 上述场景也可以通过 git cherry-pick 来实现，有兴趣的可以去了解一下这个指令。 完成 feature 分支，合并到 develop 分支 # 切到 develop 分支，更新下代码 git check develop git pull --rebase # 合并 feature 分支 git merge feature/xxx --no-ff # 删除 feature 分支 git branch -d feature/xxx # 推到远端 git push origin develop 当某个版本所有的 feature 分支均合并到 develop 分支，就可以切出 release 分支，准备发布新版本，提交测试并进行 bug fix # 当前在 develop 分支 git checkout -b release/xxx # 在 release/xxx 分支进行 bug fix git commit -m &quot;fix(xxx): xxxxx&quot; ... 所有 bug 修复完成，准备发布新版本 # master 分支合并 release 分支并添加 tag git checkout master git merge --no-ff release/xxx --no-ff # 添加版本标记，这里可以使用版本发布日期或者具体的版本号 git tag 1.0.0 # develop 分支合并 release 分支 git checkout develop git merge --no-ff release/xxx # 删除 release 分支 git branch -d release/xxx 至此，一个新版本发布完成。 线上出现 bug，需要紧急发布修复版本 # 当前在 master 分支 git checkout master # 切出 hotfix 分支 git checkout -b hotfix/xxx ... 进行 bug fix 提交 # master 分支合并 hotfix 分支并添加 tag(紧急版本) git checkout master git merge --no-ff hotfix/xxx --no-ff # 添加版本标记，这里可以使用版本发布日期或者具体的版本号 git tag 1.0.1 # develop 分支合并 hotfix 分支(如果此时存在 release 分支的话，应当合并到 release 分支) git checkout develop git merge --no-ff hotfix/xxx # 删除 hotfix 分支 git branch -d hotfix/xxx 至此，紧急版本发布完成。 提交信息规范 提交信息规范部分参考 Angular.js commit messgae。 git commit 格式 如下： 1&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; 各个部分的说明如下： type 类型，提交的类别 feat: 新功能 fix: 修复 bug docs: 文档变动 style: 格式调整，对代码实际运行没有改动，例如添加空行、格式化等 refactor: bug 修复和添加新功能之外的代码改动 perf: 提升性能的改动 test: 添加或修正测试代码 chore: 构建过程或辅助工具和库（如文档生成）的更改 scope 修改范围 主要是这次修改涉及到的部分，简单概括，例如 login、train-order subject 修改的描述 具体的修改描述信息 范例 feat(detail): 详情页修改样式 fix(login): 登录页面错误处理 test(list): 列表页添加测试代码这里对提交规范加几点说明： 1. type + scope 能够控制每笔提交改动的文件尽可能少且集中，避免一次很多文件改动或者多个改动合成一笔。 2. subject 对于大部分国内项目而已，如果团队整体英文不是较高水平，比较推荐使用中文，方便阅读和检索。 3. 避免重复的提交信息，如果发现上一笔提交没改完整，可以使用 git commit --amend 指令追加改动，尽量避免重复的提交信息。","categories":[{"name":"Git学习","slug":"Git学习","permalink":"http://www.dwlblog.网址/categories/Git%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.dwlblog.网址/tags/Git/"}]},{"title":"Go语言-面向对象三大特性","slug":"面向对象-2-三大特性","date":"2020-06-16T07:47:57.000Z","updated":"2020-06-17T07:23:27.784Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 面向对象三大特性1.1 封装封装：把抽象出的字段和对字段的操作封装在一起,数据被保护在内部,程序的其它包只有通过被授权的操作(方法),才能对字段进行修改，其作用有： 隐藏实现细节 可以对数据进行验证，保证安全合理 Golang对面向对象做了极大简化，并不强调封装特性，下列示例进行模拟实现： 在person包下新建person.go文件： 123456789101112131415161718192021222324252627package personimport \"fmt\"type person struct &#123; Name string age int //年龄是隐私，不允许其他包访问&#125;//工厂函数（类似构造函数）func NewPerson(name string) *person &#123; return &amp;person&#123; Name: name, &#125;&#125;func (p *person) SetAge(age int) &#123; if age &gt; 0 &amp;&amp; age &lt; 150 &#123; //校验 p.age = age &#125; else &#123; fmt.Println(\"年龄不合法\") &#125;&#125;func (p *person) GetAge() int &#123; return p.age&#125; main.go文件操作person： 123456789101112package mainimport ( \"demo/person\" // demo是go mod模式下，整体项目名 \"fmt\")func main() &#123; p := person.NewPerson(\"Tom\") p.SetAge(18) fmt.Println(p)&#125; 1.2 继承在 Golang 中，如果一个 struct 嵌套了另一个匿名结构体，那么这个结构体可以直接访 问匿名结构体的字段和方法，从而实现了继承特性。 1234567891011121314151617181920212223242526272829303132package mainimport ( \"fmt\")type Father struct &#123; Name string age int&#125;func (f *Father) run() &#123; fmt.Println(f.Name + \" like running...\")&#125;type Son struct &#123; Father //嵌套匿名结构体&#125;func main() &#123; var s Son //s.Father.Name = \"Tom\" //s.Father.age = 10 //可以访问未导出属性 //s.Father.run() //可以访问未导出方法 //上述可以简写为： s.Name = \"Tom\" s.age = 10 s.run()&#125; 注意： 当结构体和匿名结构体有相同的字段或者方法时，编译器采用就近访问原则访问，如果希望访问匿名结构体的字段和方法，可以通过匿名结构体名来区分。 结构体嵌入多个匿名结构体，如果两个匿名结构体有相同的字段和方法(同时结构体本身没有同名的字段和方法)，访问时必须明确指定匿名结构体名字，否则编译报错。 如果一个 struct 嵌套了一个有名结构体，这种模式就是组合，如果是组合关系，那么在访问组合的结构体的字段或方法时，必须带上结构体的名字。 关于多重继承：如果一个 struct 嵌套了多个匿名结构体，那么该结构体可以直接访问嵌套的匿名结构体的字段和方法，从而实现多重继承。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( \"fmt\")type Father1 struct &#123; Name string age int&#125;func (f *Father1) run() &#123; fmt.Println(f.Name + \" like running...\")&#125;type Father2 struct &#123; Like string&#125;type Son1 struct &#123; Father1 Father2&#125;type Son2 struct &#123; *Father1 *Father2&#125;func main() &#123; s1 := &amp;Son1 &#123; Father1&#123; Name: \"Tom\", age: 10, &#125;, Father2&#123; Like: \"伏特加\", &#125;, &#125; fmt.Println(s1) s2 := &amp;Son2&#123; &amp;Father1&#123; Name: \"Tom\", age: 10, &#125;, &amp;Father2&#123; Like: \"伏特加\", &#125;, &#125; fmt.Println(s2.Father1)&#125; 输出结果： 12&amp;&#123;&#123;Tom 10&#125; &#123;伏特加&#125;&#125;&amp;&#123;Tom 10&#125; 1.3 多态多态与接口（interface）有关联，参见接口章节","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-面向对象基础","slug":"面向对象-1-构造函数与方法","date":"2020-06-16T07:46:57.000Z","updated":"2020-06-17T07:22:55.744Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 面向对象初识1.1 模拟构造函数Go和传统的面向对象语言如Java有着很大区别。结构体没有构造函数初始化功能，可以通过以下方式模拟： 1234567891011121314151617181920212223242526272829package mainimport ( \"fmt\")type Person struct &#123; Name string Age int&#125;func NewPersonByName(name string) *Person &#123; return &amp;Person&#123; Name: name, &#125;&#125;func NewPersonByAge(age int) *Person &#123; return &amp;Person&#123; Age: age, &#125;&#125;func main() &#123; p := NewPersonByName(\"zs\") fmt.Println(p) // &#123;zs 0&#125;&#125; 贴士：因为Go没有函数重载，为了避免函数名字冲突，使用了NewPersonByName和NewPersonByAge两个不同的函数表示不同的Person构造过程。 1.2 父子关系结构体初始化Person可以看做父类，Student是子类，子类需要继承父类的成员： 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"fmt\")type Person struct &#123; Name string Age int&#125;type Student struct &#123; Person ClassName string&#125;//构造父类func NewPerson(name string, age int) *Person &#123; return &amp;Person&#123; Name: name, Age: age, &#125;&#125;//构造子类func NewStudent(classname string) *Student &#123; p := &amp;Student&#123;&#125; p.ClassName = classname return p&#125;func main() &#123; s := NewStudent(\"一班\") fmt.Println(s) // &amp;&#123;&#123; 0&#125; 一班&#125;&#125; 1.3 Go中的面向对象初识在Go中，可以给任意类型（除了指针）添加相应方法： 12345678910type Interger intfunc (i Interger) Less (j Interger) bool &#123; return i &lt; j&#125;func main() &#123; var i Interger = 1 fmt.Print(i.Less(5))&#125; 二 方法2.1 方法Golang 中的方法是作用在指定的数据类型上的(即:和指定的数据类型绑定)，因此自定义类型，都可以有方法，而不仅仅是 struct。 方法的声明和调用： 1234func (recevier type) methodName(参数列表) (返回值列表)&#123; //方法体 return 返回值&#125; 方法与函数的示例： 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"fmt\")type Person struct &#123; Name string Age int&#125;// 一个run函数func run(p *Person, name string) &#123; p.Name = name fmt.Println(\"函数 run...\", p.Name)&#125;// 一个run方法func (p *Person)run() &#123; fmt.Println(\"方法 run...\", p.Name)&#125;func main() &#123; // 实例化一个对象（结构体） p1 := &amp;Person&#123; \"ruyue\", 10, &#125; // 执行一个普通方法 run(p1, \"张三\") // 输出 函数 run... 张三 // 执行方法 p1.run() // 输出 方法 run... 张三&#125; 2.2 Go方法本质Go的方法是一种作用于特定类型变量的函数，这种特定类型的变量叫做接收器（Receiver）。如果特定类型理解为结构体或者“类”时，接收器就类似于其他语言的this或者self。 在Go中，接收器可以是任何类型，不仅仅是结构体，依此我们看出，Go中的方法和其他语言的方法类似，但是Go语言的接收器强调方法的作用对象是实例。 方法与函数的区别就是：函数没有作用对象。 上述Person案例中，接收器类型是*Person，属于指针类型，非常接近Java中的this，由于指针的特性，调用方法时，修改接收器指针的任意长远变量，在方法结束后，修改都是有效的。 当方法作用于非指针接收器时，Go语言会在代码运行时将接收器的值复制一份，在非指针接收器的方法中可以获取接收器的成员值，但修改后无效，如下所示： 12345678910111213141516171819202122232425262728package mainimport \"fmt\"//定义一个表示点的结构体type Point struct &#123; X int Y int&#125;//非指针接收器func (p Point) Add(otherP Point) Point &#123; return Point&#123; p.X + otherP.X, p.Y + otherP.Y, &#125;&#125;func main() &#123; p1 := Point&#123;1, 1&#125; p2 := Point&#123;2, 2&#125; result := p1.Add(p2) fmt.Println(result) // &#123;3 3&#125;&#125; 一般情况下，小对象由于复制时速度较快，适合使用非指针接收器，大对象因为复制性能较低，适合使用指针接收器，此时再接收器和参数之间传递时不进行复制，只传递指针。","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言介绍","slug":"Go简介","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-17T07:14:31.618Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 Go语言介绍Go语言是Google公司开发的一种静态、编译型语言，具备自动垃圾回收功能，原生支持并发开发。 Go的诞生是为了解决当下编程语言对并发支持不友好、编译速度慢、编程复杂这三个主要问题。 Go既拥有接近静态编译语言（如C）的安全和性能，又有接近脚本语言（如python）的开发效率，其主要特点有： 天然并发：语言层面支持并发，包括gorotuine、channel 语法优势：没有历史包袱，包含多返回值、匿名函数、defer 语言层面支持多核CPU利用 与Java相比的不同： 没有Java支持的一些面向对象思想：重载、构造函数、继承等 代码规范严格：花括号位置固定，变量名大小写代表公有私有等 支持函数式编程：匿名函数，闭包 接口非侵入式：不需要显式声明对接口的继承，实现了接口的方法即为实现了该接口类型 二 Go安装推荐使用官方的安装包直接安装，下载地址：https://golang.org/dl/ 贴士：本笔记都是基于go1.13 Win安装Go：打开Win安装包下一步下一步即可，默认安装在目录：c:\\Go Mac安装Go：打开Mac安装包下一步下一步即可，需要预装Xcode。安装完毕后需配置环境变量即可使用，但是如果要使用一些go mod功能推荐如下配置： 1234567891011vim ~&#x2F;.bash_profileexport GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go # golang本身的安装位置export GOPATH&#x3D;~&#x2F;go&#x2F; # golang包的本地安装位置export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.io # golang包的下载代理export GO111MODULE&#x3D;on # 开启go mod模式export PATH&#x3D;$PATH:$GOROOT&#x2F;bin # go本身二进制文件的环境变量export PATH&#x3D;$PATH:$GOPATH&#x2F;bin # go第三方二进制文件的环境便令# 重启环境source ~&#x2F;.bash_profile Linux安装Go： 123456789101112131415# 下载解压wget https:&#x2F;&#x2F;dl.google.com&#x2F;go&#x2F;go1.13.1.linux-amd64.tar.gztar zxvf go*.tar.gz -C &#x2F;usr&#x2F;local&#x2F;# 配置环境：注意该环境必须是go1.11版本及以上且项目要求使用go mod才可以开启vim &#x2F;etc&#x2F;profileexport GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go # golang本身的安装位置export GOPATH&#x3D;~&#x2F;go # golang包的本地安装位置export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.io,direct # golang包的下载代理,回源地址获取export GO111MODULE&#x3D;on # 开启go mod模式export PATH&#x3D;$PATH:$GOROOT&#x2F;bin # go本身二进制文件的环境变量export PATH&#x3D;$PATH:$GOPATH&#x2F;bin # go第三方二进制文件的环境便令# 重启环境source &#x2F;etc&#x2F;profile 测试安装： 12345# 查看go版本go version# 查看go环境配置go env 关于go modules的详细讲解位于本章12节。 三 HelloWorld新建文件hello.go，代码如下： 1234567package main //每个程序都有且仅有一个main包import \"fmt\" func main() &#123; //主函数main只有一个 fmt.Println(\"Hello World!\") //函数调用：包名.函数名&#125; 运行文件： 123456# 执行方式一：先编译，再运行go build hello.go # 编译。在同级目录下生成文件&#96;hello&#96;，添加参数&#96;-o 名称&#96; 则可指定生成的文件名 .&#x2F;hello # 运行。贴士：win下生成的是.exe文件，直接双击执行即可# 执行方式二：直接运行go run hello.go 两种执行流程的区别： 先编译方式：可执行文件可以在任意没有go环境的机器上运行，（因为go依赖被打包进了可执行文件） 直接执行方式：源码执行时，依赖于机器上的go环境，没有go环境无法直接运行 四 Go语法注意 Go源文件以 “go” 为扩展名 与Java、C语言类似，Go应用程序的执行入口也是main()函数 Go语言严格区分大小写 Go不需要分号结尾 Go编译是一行一行执行，所以不能将类似两个 Print 函数写在一行 Go语言定义的变量或者import的包如果没有使用到，代码不能编译通过 Go的注释使用 // 或者 /* */ 五 开发工具推荐笔者推荐的go开发工具： goland vscode vscode的相关go插件会出现无法下载情况，解决办法： 12345678910111213141516171819202122# 如果开启了go mod，则 go get -u -v github.com&#x2F;ramya-rao-a&#x2F;go-outline go get -u -v github.com&#x2F;acroca&#x2F;go-symbols go get -u -v golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;guru go get -u -v golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;gorename go get -u -v github.com&#x2F;rogpeppe&#x2F;godef go get -u -v github.com&#x2F;sqs&#x2F;goreturns go get -u -v github.com&#x2F;cweill&#x2F;gotests&#x2F;gotests go get -u -v golang.org&#x2F;x&#x2F;lint&#x2F;golint# 如果未开启go mod，则需要进入cd $GOPATH&#x2F;src ，使用 git clone 下载上述文件 # 安装cd $GOPATH go install github.com&#x2F;ramya-rao-a&#x2F;go-outline go install github.com&#x2F;acroca&#x2F;go-symbols go install golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;guru go install golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;gorename go install github.com&#x2F;rogpeppe&#x2F;godef go install github.com&#x2F;sqs&#x2F;goreturns go install github.com&#x2F;cweill&#x2F;gotests&#x2F;gotests go install golang.org&#x2F;x&#x2F;lint&#x2F;golint","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-数值类型","slug":"值类型-1-数值类型","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-17T07:27:36.000Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 数值类型数值类型指基本类型中的：整型、浮点型、复数。 二 整数整数类型有无符号(如int)和带符号(如uint)两种，这两种类型的长度相同，但具体长度取决于不同编译器的实现。 int8、int16、int32和int64四种有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，同样uint8、uint16、uint32和uint64对应四种无符号整数类型。 有符号类型： 123456int 32位系统占4字节（与int32范围一样），64位系统占8个节（与int64范围一样） int8 占据1字节 范围 -128 ~ 127int16 占据2字节 范围 -2(15次方) ~ 2（15次方）-1int32 占据4字节 范围 -2(31次方) ~ 2（31次方）-1int64 占据8字节 范围 -2(63次方) ~ 2（63次方）-1rune int32的别称 无符号类型： 123456uint 32位系统占4字节（与uint32范围一样），64位系统占8字节（与uint64范围一样） uint8 占据1字节 范围 0 ~ 255uint16 占据2字节 范围 0 ~ 2（16次方）-1uint32 占据4字节 范围 0 ~ 2（32次方）-1uint64 占据8字节 范围 0 ~ 2（64次方）-1byte uint8的别称 注意： 上述类型的变量由于是不同类型，不允许互相赋值或操作 Go默认的整型类型是int 查看数据所占据的字节数方法：unsafe.Sizeof() 三 浮点类型3.1 浮点类型的分类12float32 单精度 占据4字节 范围 -3.403E38 ~ 3.403E38 (math.MaxFloat32)float64 双精度 占据8字节 范围 -1.798E208 ~ 1.798E308 (math.MaxFloat64) 由上看出： 浮点数是有符号的，浮点数在机器中存放形式是：浮点数=符号位+指数位+尾数位 浮点型的范围是固定的，不受操作系统限制 .512 这样数可以识别为 0.512 科学计数法： 5.12E2 = 5.12 * 102 5.12E-2 = 5.12 / 102 3.2 精度损失float32可以提供大约6个十进制数的精度，float64大约可以提供15个十进制的精度（一般选择float64） 1234var num1 float32 = -123.0000901var num2 float64 = -123.0000901 fmt.Println(\"num1=\",num1) // -123.00009fmt.Println(\"num2=\",num2) // -123.0000901 3.3 浮点数判断相等使用 == 号判断浮点数，是不可行的，替代方案如下： 1234func isEqual(f1,f2,p float64) bool &#123; // p为用户自定义精度，如：0.00001 return math.Abs(f1-f2) &lt; p &#125; 四 复数Go中复数默认类型是complex128（64位实数+64位虚数）。如果需要小一些的，也有complex64(32位实数+32位虚数)。 复数的形式为RE + IMi，其中RE是实数部分，IM是虚数部分，而最后的i是虚数单位。 如下所示： 12345var t complex128t = 2.1 + 3.14it1 = complex(2.1,3.14) // 结果同上 fmt.Println(real(t)) // 实部：2.1fmt.Println(imag(t)) // 虚部：3.14 五 NaN非数go中的NaN非数： 123var z float64// 输出 \"0 -0 +Inf -Inf NaN\"fmt.Println(z, -z, 1/z, -1/z, z/z) 注意： 函数math.IsNaN用于测试一个数是否是非数NaN， 函数math.NaN则返回非数对应的值。 虽然可以用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等的。 123nan := math.NaN()// \"false false false\"fmt.Println(nan == nan, nan &lt; nan, nan &gt; nan)","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-切片","slug":"引用类型-1-切片","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-17T07:26:02.379Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 切片创建切片(slice)解决了数组长度不能扩展，以及基本类型数组传递时产生副本的问题。 常用创建方式： 1234var s1 []int // 和声明数组一样，只是没有长度，但是这样做没有意义，因为底层的数组指针为nils2 := []byte &#123;'a','b','c'&#125;fmt.Println(s1) //输出 []fmt.Print(s2) //输出 [97 98 99] 使用make函数创建： 123slice1 := make([]int,5) // 创建长度为5，容量为5，初始值为0的切片slice2 := make([]int,5,7) // 创建长度为5，容量为7，初始值为0的切片slice3 := []int&#123;1,2,3,4,5&#125; // 创建长度为5，容量为5，并已经初始化的切片 从数组创建：slice可以从一个数组再次声明。slice通过array[i:j]来获取，其中i是数组的开始位置，j是结束位置，但不包含array[j]，它的长度是j-i: 12345678910// 声明一个含有10个元素元素类型为byte的数组var arr = [10]byte &#123;'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'&#125;// 声明两个含有byte的slicear a, b []byte// a指向数组的第3个元素开始，并到第五个元素结束，现在a含有的元素: ar[2]、ar[3]和ar[4]a = arr[2:5] // b是数组arr的另一个slicre,b的元素是：ar[3]和ar[4]b = arr[3:5] 注意：声明数组时，方括号内写明了数组的长度或使用…自动计算长度，而声明slice时，方括号内没有任何字符。 从切片创建： 12oldSlice := []int&#123;1,2,3&#125;newSlice := oldSlice[:6] //基于切片前6个元素创建，没有的默认0 注意：如果选择的旧切片长度超出了旧切片的cap()值（切片存储长度），则不合法。 二 切片常见操作2.1 切片常见内置函数切片常用内置函数： 12345len() 返回切片长度cap() 返回切片底层数组容量append() 对切片追加元素func copy(dst, src []Type) int 将src中数据拷贝到dst中，返回拷贝的元素个数 切片空间与元素个数： 1234slice1 := make([]int, 5, 10)fmt.Println(len(slice1)) // 5fmt.Println(cap(slice1)) // 10fmt.Println(slice1) // [0 0 0 0 0] 切片操作 1234567891011121314151617181920212223242526272829//切片增加slice1 = append(slice1,1,2)fmt.Println(slice1) //输出[0 0 0 0 0 1 2]//切片增加一个新切片sliceTemp := make([]int,3)slice1 = append(slice1,sliceTemp...)fmt.Println(slice1) //输出[0 0 0 0 0 1 2 0 0 0]//切片拷贝s1 := []int&#123;1,3,6,9&#125;s2 := make([]int, 10) //必须给与充足的空间num := copy(s2, s1)fmt.Println(s1) //[1 3 6 9]fmt.Println(s2) //[1 3 6 9 0 0 0 0 0 0]fmt.Println(num) //4//切片中删除元素s1 := []int&#123;1,3,6,9&#125;index := 2 //删除该位置元素s1 = append(s1[:index], s1[index+1:]...)fmt.Println(s1) //[1 3 9]// 切片拷贝s1 := []int&#123;1,2,3,4,5&#125;s2 := []int&#123;6,7,8&#125;copy(s1,s2) //复制s2前三个元素到slice1前3位置copy(s2,s1) //复制s1前三个元素到slice2 注意：没有…会编译错误，默认第二个参数后是元素值，传入切片需要展开。如果追加的长度超过当前已分配的存储空间，切片会自动分配更大的内存。 2.2 切片的一些简便操作 slice的默认开始位置是0，ar[:n]等价于ar[0:n] slice的第二个序列默认是数组的长度，ar[n:]等价于ar[n:len(ar)] 如果从一个数组里面直接获取slice，可以这样ar[:]，因为默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)] 切片的遍历可以使用for循环，也可以使用range函数 123456789101112131415161718192021222324252627282930313233// 声明一个数组var array = [10]byte&#123;'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'&#125;// 声明两个slicevar aSlice, bSlice []byte// 演示一些简便操作aSlice = array[:3] // 等价于aSlice = array[0:3] aSlice包含元素: a,b,caSlice = array[5:] // 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,jaSlice = array[:] // 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素// 从slice中获取sliceaSlice = array[3:7] // aSlice包含元素: d,e,f,g，len=4，cap=7bSlice = aSlice[1:3] // bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,fbSlice = aSlice[:3] // bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,fbSlice = aSlice[0:5] // 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,hbSlice = aSlice[:] // bSlice包含所有aSlice的元素: d,e,f,g``` #### 2.3 切片的截取- `s[n]`：切片s中索引为位置为n的项- `s[:]`：从切片s的索引位置0到`len(s)-1`所获得的切片- `s[low:]`：从切片s的索引位置low到`len(s)-1`所获得的切片- `s[:high]`：从切片s的索引位置0到high所获得的切片- `s[low:high]`：从切片s的索引位置low到high所获得的切片- `s[low:high:max]`：从low到high的切片，且容量`cap=max-low`#### 1.7 字符串转切片 ```gostr := \"hello,世界\"a := []byte(str) //字符串转换为[]byte类型切片b := []rune(str) //字符串转换为[]rune类型切片 三 切片存储结构与数组相比，切片多了一个存储能力值的概念，即元素个数与分配空间可以是两个不同的值，其结构如下所示： 12345type slice struct &#123; arrary = unsafe.Pointer //指向底层数组的指针 len int //切片元素数量 cap int //底层数组的容量&#125; 所以切片通过内部的指针和相关属性引用数组片段，实现了变长方案，Slice并不是真正意义上的动态数组。 合理设置存储能力，可以大幅提升性能，比如知道最多元素个数为50，那么提前设置为50，而不是先设为30，可以明显减少重新分配内存的操作。 四 切片作为函数参数1234567891011121314func test(s []int) &#123; fmt.Printf(\"test---%p\\n\", s) // 打印与main函数相同的地址 s = append(s, 1, 2, 3, 4, 5) fmt.Printf(\"test---%p\\n\", s) // 一旦append的数据超过切片长度，则会打印新地址 fmt.Println(\"test---\", s) // [0 0 0 1 2 3 4 5]&#125;func main() &#123; s1 := make([]int, 3) test(s1) fmt.Printf(\"main---%p\\n\", s1) // 不会因为test函数内的append而改变 fmt.Println(\"main---\", s1) // [ 0 0 0]&#125;","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-集合map","slug":"引用类型-2-集合","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-17T07:26:22.355Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 集合map1.1 map的创建Go内置了map类型，map是一个无序键值对集合（也有一些书籍翻译为字典）。 普通创建： 123// 声明一个map类型，[]内的类型指任意可以进行比较的类型 int指值类型m := map[string]int&#123;\"a\":1,\"b\":2&#125;fmt.Print(m[\"a\"]) make方式创建map： 123456789101112131415type Person struct&#123; ID string Name string&#125;func main() &#123; var m map[string] Person m = make(map[string] Person) m[\"123\"] = Person&#123;\"123\",\"Tom\"&#125; p,isFind := m[\"123\"] fmt.Println(isFind) //true fmt.Println(p) //&#123;123 Tom&#125;&#125; 注意：golang中map的 key 通常 key 为 int 、string，但也可以是其他类型如：bool、数字、string、指针、channel，还可以是只包含前面几个类型的接口、结构体、数组。slice、map、function由于不能使用 == 来判断，不能作为map的key。 1.2 map的使用通过key操作元素： 12345678var numbers map[string]intnumbers = make(map[string]int)numbers[\"one\"] = 1 //赋值numbers[\"ten\"] = 10 //赋值numbers[\"three\"] = 3delete(numbers, \"ten\") // 删除key为 ten 的元素fmt.Println(\"第三个数字是: \", numbers[\"three\"]) // 读取数据 map的遍历：同数组一样，使用for-range 的结构遍历 注意： map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取； map的长度是不固定的，也就是和slice一样，也是一种引用类型 内置的len函数同样适用于map，返回map拥有的key的数量 go没有提供清空元素的方法，可以重新make一个新的map，不用担心垃圾回收的效率，因为go中并行垃圾回收效率比写一个清空函数高效很多 map和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制 1.3 并发安全的map演示并发读写map的问题： 1234567891011121314151617181920package mainfunc main() &#123; m := make(map[int]int) go func() &#123; for &#123; //无限写入 m[1] = 1 &#125; &#125;() go func() &#123; for &#123; //无限读取 _ = m[1] &#125; &#125;() for &#123;&#125; //无限循环，让并发程序在后台执行&#125; 编译会有错误提示：fatal error: concurrent map read and map write，即出现了并发读写，因为用两个并发程序不断的对map进行读和写，产生了竞态问题。map内部会对这种错误进行检查并提前发现。 Go内置的map只有读是线程安全的，读写是线程不安全的。 需要并发读写时，一般都是加锁，但是这样做性能不高，在go1.9版本中提供了更高效并发安全的sync.Map。 sync.Map的特点： 无须初始化，直接声明即可 sync.Map不能使用map的方式进行取值和设值操作，而是使用sync.Map的方法进行调用。Store表示存储，Load表示获取，Delete表示删除。 使用Range配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，需要继续迭代时，返回true，终止迭代返回false。 12345678910111213141516171819202122232425package mainimport ( \"fmt\" \"sync\")func main() &#123; var scene sync.Map //保存键值对 scene.Store(\"id\",1) scene.Store(\"name\",\"lisi\") //根据键取值 fmt.Println(scene.Load(\"name\")) //遍历 scene.Range(func(k, v interface&#123;&#125;) bool&#123; fmt.Println(k,v) return true &#125;)&#125; 注意：map没有提供获取map数量的方法，可以在遍历时手动计算。sync.Map为了并发安全。损失了一定的性能。","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-指针","slug":"引用类型-3-指针","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-17T07:26:46.129Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 指针1.1 指针的创建Go保留了指针，代表某个内存地址，默认值为 nil ，使用 &amp; 取变量地址，通过 * 访问目标对象。 简单示例： 12345var a int = 10fmt.Println(\"&amp;a=\", &amp;a) // 0xc000096008 一个十六进制数var p *int = &amp;afmt.Println(\"*p=\", *p) // 10 注意： Go同样支持多级指针，如 **T 空指针：声明但未初始化的指针 野指针：引用了无效地址的指针，如：var p *int = 0，var p *int = 0xff00(超出范围) Go中直接使用.访问目标成员 1.2 指针使用示例：实现变量值交换123func swap(p1,p2 *int) &#123;*p1,*p2 = *p2,*p1&#125; 1.3 结构体指针示例： 1234567891011121314type User struct&#123; name string age int&#125;func main() &#123; var u = User&#123; name:\"lisi\", age: 18, &#125; p := &amp;u fmt.Println(u.name) //输出李四 fmt.Println(p.name) //输出李四&#125; 1.4 Go不支持指针运算由于垃圾回收机制的存在，指针运算造成许多困扰，所以Go直接禁止了指针运算 123a := 1p := &amp;ap++ //报错：non-numeric type *int 1.5 new()函数使用new()函数可以在 heap堆 区申请一片内存地址空间： 123var p *boolp = new(bool)fmt.Println(*p) // false","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-数据类型","slug":"数据类型","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-17T07:24:13.537Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 数据类型分类值类型：基本数据类型是Go语言实际的原子，复合数据类型是由不同的方式组合基本类型构造出来的数据类型，如：数组，slice，map，结构体 1234567整型 int8,uint # 基础类型之数字类型浮点型 float32，float64 # 基础类型之数字类型复数 # 基础类型之数字类型布尔型 bool # 基础类型，只能存true&#x2F;false，占据1个字节，不能转换为整型，0和1也不能转换为布尔字符串 string # 基础类型数组 # 复合类型 结构体 struct # 复合类型 引用类型：即保存的是对程序中一个变量的或状态的间接引用，对其修改将影响所有该引用的拷贝 123456指针 *切片 slice字典 map函数 func管道 chan接口 interface 贴士：Go语言没有字符型，可以使用byte来保存单个字母 二 零值机制Go变量初始化会自带默认值，不像其他语言为空，下面列出各种数据类型对应的0值： 1234567891011int 0int8 0int32 0int64 0uint 0x0rune 0 //rune的实际类型是 int32byte 0x0 // byte的实际类型是 uint8float32 0 //长度为 4 bytefloat64 0 //长度为 8 bytebool falsestring \"\" 三 格式化输出常用格式化输出： 12345678910111213141516171819%% %字面量%b 二进制整数值，基数为2，或者是一个科学记数法表示的指数为2的浮点数%c 该值对应的unicode字符%d 十进制数值，基数为10%e 科学记数法e表示的浮点或者复数%E 科学记数法E表示的浮点或者附属%f 标准计数法表示的浮点或者附属%o 8进制度%p 十六进制表示的一个地址值%s 输出字符串或字节数组%T 输出值的类型，注意int32和int是两种不同的类型，编译器不会自动转换，需要类型转换。%v 值的默认格式表示%+v 类似%v，但输出结构体时会添加字段名%#v 值的Go语法表示%t 单词true或false%q 该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示%x 表示为十六进制，使用a-f%X 表示为十六进制，使用A-F%U 表示为Unicode格式：U+1234，等价于&quot;U+%04X&quot; 示例： 1234567891011121314151617181920212223242526272829type User struct &#123; Name string Age int&#125;user : = User&#123; \"overnote\", 1,&#125;fmt.Printf(\"%%\\n\") // %fmt.Printf(\"%b\\n\", 16) // 10000fmt.Printf(\"%c\\n\", 65) // Afmt.Printf(\"%c\\n\", 0x4f60) // 你fmt.Printf(\"%U\\n\", '你') // U+4f60fmt.Printf(\"%x\\n\", '你') // 4f60fmt.Printf(\"%X\\n\", '你') // 4F60fmt.Printf(\"%d\\n\", 'A') // 65fmt.Printf(\"%t\\n\", 1 &gt; 2) // falsefmt.Printf(\"%e\\n\", 4396.7777777) // 4.396778e+03 默认精度6位fmt.Printf(\"%20.3e\\n\", 4396.7777777) // 4.397e+03 设置宽度20,精度3,宽度一般用于对齐fmt.Printf(\"%E\\n\", 4396.7777777) // 4.396778E+03fmt.Printf(\"%f\\n\", 4396.7777777) // 4396.777778fmt.Printf(\"%o\\n\", 16) // 20fmt.Printf(\"%p\\n\", []int&#123;1&#125;) // 0xc000016110fmt.Printf(\"Hello %s\\n\", \"World\") // Hello Worldfmt.Printf(\"Hello %q\\n\", \"World\") // Hello \"World\"fmt.Printf(\"%T\\n\", 3.0) // float64fmt.Printf(\"%v\\n\", user) // &#123;overnote 1&#125;fmt.Printf(\"%+v\\n\", user) // &#123;Name:overnote Age:1&#125;fmt.Printf(\"%#v\\n\", user) // main.User&#123;Name:\"overnote\", Age:1&#125;","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-字符串","slug":"值类型-2-字符串","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-17T07:28:02.835Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 字符Golang 中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存，且使用单引号包裹。 12345678var c1 byte = 'a'var c2 byte = '0'fmt.Println(\"c1=\", c1) //输出 97 fmt.Println(\"c2=\", c2) //输出48fmt.Printf(\"c1=%c,c2=%c\\n\", c1, c2) //输出原值 a 0//var c3 byte = '北'//fmt.Printf(\"c3=%c\", c3) // 溢出错误:overflows byte 贴士： 字符类型也可以用d%打印为整型 如果我们保存的字符在 ASCII 表的,比如[0-1, a-z,A-Z..]直接可以保存到 byte 如果我们保存的字符对应码值大于 255,这时我们可以考虑使用 int 类型保存 如果我们需要安装字符的方式输出，这时我们需要格式化输出，即 fmt.Printf(“%c”, c1) 字符可以和整型进行运算 二 字符串传统的字符串是由字符组成的，而Go的字符串是由单个字节连接起来的，即Go字符串是一串固定长度的字符连接起来的字符序列。 字符串在Go语言中是基本类型，内容在初始化后不能修改。 Go中的字符串都是采用UTF-8字符集编码，使用一对双引号&quot;&quot;或反引号``定义。``可以额外解析换行，即其没有字符转义功能。 12345678910var str1 stringstr1 = \"Hello \"str2 := \" World!\"fmt.Println(str1[0]) // 输出字符串第一个字符 72fmt.Println(len(str1)) // 输出长度 6fmt.Println(str1 + str2) // 输出不带空格的// 字符串不可变，编译报错： cannot assign to 因为// str1[0] = 'c' 由于Go中的字符串不可直接改变，可以使用下列两种方式进行修改： 方式一：通过转换为字节数组[]byte类型，构造一个临时字符串 12345678str := \"hello\"strTemp := []byte(str)fmt.Println(\"strTemp=\", strTemp) // [104 101 108 108 111]strTemp[0] = 'c'strResult := string(strTemp)fmt.Println(\"strResult=\", strResult) // strResult= cello 方式二：使用切片 12str := \"hello\"str = \"c\"+ str[1:] // 1: 表示从第1位开始到最后 Go和Java等语言一样，字符串默认是不可变的，这样保证了线程安全，大家使用的都是只读对象，无须加锁，且能很方便的共享内存，不必使用写时复制。 三 字符串常用操作3.1 len()函数与字符串遍历len()函数是go语言的内建函数，可以用来获取字符串、切片、通道等的长度。 12345678910111213141516package mainimport ( \"fmt\" \"unicode/utf8\")func main() &#123; str1 := \"hello world\" str2 := \"你好，\" fmt.Println(len(str1)) // 11 fmt.Println(len(str2)) // 9 fmt.Println(utf8.RuneCountInString(str2)) // 3&#125; 第一个函数输出11很容易理解，第二个函数却输出了9，理论上我们会认为应该是3才对。这是因为Go的字符串都是以UTF-8格式保存，每个中文占据3个字节。Go中计算UTF-8字符串格式的长度应该使用utf8.RuneCountInString。 字符串遍历方式一：使用字节数组，注意每个中文在UTF-8中占据3个字节 1234str := \"hello\"for i := 0; i &lt; len(str); i++ &#123; fmt.Println(i,str[i])&#125; 字符串遍历方式二：range关键字只是第一种遍历方式的简写 1234str := \"你好\"for i,ch := range str &#123; fmt.Println(i,ch)&#125; 注意：由于上述len()函数本身原因，Unicode字符遍历需要使用range。 3.2 string()函数类型转换go的内建函数 string()可以将其他类型转变为字符串类型： 12num := 12fmt.Printf(\"%T \\n\", string(num)) // string 3.3 字符串连接使用+能够连接字符串。但是该操作并不高效（因为字符串在Go中是基本类型，每次拼接都是拷贝了内存！）。Go1.10提供了类似Java的StringBuilder机制来进行高效字符串连接： 1234567891011121314151617181920212223package mainimport ( \"bytes\" \"fmt\")func main() &#123; str1 := \"hello \" str2 := \" world\" //创建字节缓冲 var stringBuilder bytes.Buffer //把字符串写入缓冲 stringBuilder.WriteString(str1) stringBuilder.WriteString(str2) //将缓冲以字符串形式输出 fmt.Println(stringBuilder.String())&#125; 在1.10版本前，可以使用bytes.Buffer拼接字符串（因为字符串其实是字节数组）： 123var buf bytes.Bufferbuf.WriteString(\"hello\")fmt.Println(buf.String()) 四 strings包相关函数strings包提供了字符串的一些常见操作函数： 1234567891011121314151617181920//查找s在字符串str中的索引Index(str, s string) int //判断str是否包含sContains(str, s string) bool//通过字符串str连接切片 sJoin(s []string, str string) string//替换字符串str中old字符串为new字符串，n表示替换的次数，小于0全部替换Replace(str,old,new string,n int) string//字符串str按照s分割，返回切片Splite(str,s string)[]string// 去除头部、尾部指定的字符串Trim(s string, cutset string) string// 去除空格，返回切片Fields(s string) []string 五 strconv包的字符串转换函数在Java中遇到 &quot;你好&quot; + 123会将 +转变为连接符。而Go语言要求 + 号两边数据的数据类型必须一致，这使得类似的操作变得比较不便，Go提供了strconv包用于字符串与基本类型之间的转换，常用函数有Append、Format、Parse。 123456789101112131415161718192021222324252627282930313233package mainimport ( \"fmt\" \"strconv\")func main() &#123; // Append 系列函数将整数等转换为字符串后，添加到现有的字节数组中 str1 := make([]byte, 0, 100) str1 = strconv.AppendInt(str1, 4567, 10) str1 = strconv.AppendBool(str1, false) str1 = strconv.AppendQuote(str1, \"abcdefg\") str1 = strconv.AppendQuoteRune(str1, '单') fmt.Println(string(str1)) // 4567false\"abcdefg\"'单' // Format 系列函数把其他类型的转换为字符串 a := strconv.FormatBool(false) b := strconv.FormatFloat(123.23, 'g', 12, 64) c := strconv.FormatInt(1234, 10) d := strconv.FormatUint(12345, 10) e := strconv.Itoa(1023) fmt.Println(a, b, c, d, e) // false 123.23 1234 12345 1023 // Parse 系列函数把字符串转换为其他类型 f, _ := strconv.ParseBool(\"false\") g, _ := strconv.ParseFloat(\"123.23\", 64) h, _ := strconv.ParseInt(\"1234\", 10, 64) i, _ := strconv.ParseUint(\"12345\", 10, 64) j, _ := strconv.Atoi(\"1023\") fmt.Println(f, g, h, j, i, j) // false 123.23 1234 1023 12345 1023&#125;","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-函数1","slug":"函数-1-函数简介","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-17T07:20:31.284Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 函数1.1 函数声明函数声明格式： 1234func 函数名字 (参数列表) (返回值列表）&#123; // 函数体 return 返回值列表&#125; 注意： 函数名首字母小写为私有，大写为公有； 参数列表可以有0-多个，多参数使用逗号分隔，不支持默认参数； 返回值列表返回值类型可以不用写变量名 如果只有一个返回值且不声明类型，可以省略返回值列表与括号 如果有返回值，函数内必须有return Go中函数常见写法： 123456789101112131415161718192021222324//无返回值，默认返回0，所以也可以写为 func fn() int &#123;&#125;func fn()&#123;&#125; //Go推荐给函数返回值起一个变量名func fn1() (result int) &#123; return 1&#125;//第二种返回值写法func fn2() (result int) &#123; result = 1 return &#125;//多返回值情func fn3() (int, int, int) &#123; return 1,2,3&#125;//Go返回值推荐多返回值写法：func fn4() (a int, b int, c int) &#123; 多个参数类型如果相同，可以简写为： a,b int a , b, c = 1, 2, 3 return &#125; 1.2 值传递和引用传递不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝决定拷贝的 数据大小，数据越大，效率越低。 如果希望函数内的变量能修改函数外的变量，可以传入变量的地址&amp;，函数内以指针的方式操作变量。 1.3 可变参数可变参数变量是一个包含所有参数的切片。如果要在多个可变参数中传递参数 ，可以在传递时在可变参数变量中默认添 加“ …”，将切片中的元素进行传递，而不是传递可变参数变量本身。 示例：对可变参数列表进行遍历 1234567891011func joinStrings(slist ...string) string &#123; var buf bytes.Buffer for _, s := range slist &#123; buf.WriteString(s) &#125; return buf.String()&#125;func main() &#123; fmt.Println(joinStrings(\"pig\", \" and\", \" bird\"))&#125; 示例：参数传递 12345678910111213141516// 实际打印函数func rawPrint(rawList ...interface&#123;&#125;) &#123; for _, a := range rawList &#123; fmt.Println(a) &#125;&#125;// 封装打印函数func print(slist ...interface&#123;&#125;) &#123; // 将slist可变参数切片完整传递给下一个函数 rawPrint(slist...)&#125;func main() &#123; print(1,2,3)&#125; 1.4 匿名函数匿名函数可以看做函数字面量，所有直接使用函数类型变量的地方都可以由匿名函数代替。匿名函数可以直接赋值给函数变量，可以当做实参，也可以作为返回值使用，还可以直接被调用。 1234567891011121314151617181920212223242526func main() &#123; a := 3 f1 := func(num int) &#123; // f1 即为匿名函数 fmt.Println(num) // 匿名函数访问外部变量 &#125; f1(a) func() &#123; // 匿名函数自调 fmt.Println(a) &#125;()&#125;//匿名函数实战：取最大值,最小值x, y := func(i,j int) (max,min int) &#123; if i &gt; j &#123; max = i min = j &#125; else &#123; max = j min = i &#125; return&#125;(10,20)fmt.Println(x + ' ' + y) 1.5 函数类型函数去掉函数名、参数名和{}后的结果即是函数类型，可以使用%T打印该结果。 两个函数类型相同的前提是：拥有相同的形参列表和返回值列表，且列表元素的次序、类型都相同，形参名可以不同。 示例： 123456789101112131415func mathSum(a, b int) int &#123; return a + b&#125;func mathSub(a, b int) int &#123; return a - b&#125;//定义一个函数类型type MyMath func(int, int) int//定义的函数类型作为参数使用func Test(f MyMath, a , b int) int&#123; return f(a,b)&#125; 通常可以把函数类型当做一种引用类型，实际函数类型变量和函数名都可以当做指针变量，只想函数代码开始的位置，没有初始化的函数默认值是nil。 二 Go函数特性总结 支持有名称的返回值； 不支持默认值参数； 不支持重载； 不支持命名函数嵌套，匿名函数可以嵌套； Go函数从实参到形参的传递永远是值拷贝，有时函数调用后实参指向的值发生了变化，是因为参数传递的是指针的拷贝，实参是一个指针变量，传递给形参的是这个指针变量的副本，实质上仍然是值拷贝； Go函数支持不定参数； 三 两个特殊函数3.1 init函数Go语言中，除了可以在全局声明中初始化实体，也可以在init函数中初始化。init函数是一个特殊的函数，它会在包完成初始化后自动执行，执行优先级高于main函数，并且不能手动调用init函数，每一个文件有且仅有一个init函数，初始化过程会根据包的以来关系顺序单线程执行。 1234567891011package mainimport ( \"fmt\")func init() &#123; //在这里可以书写一些初始化操作 fmt.Println(\"init...\")&#125;func main() &#123; fmt.Println(\"main...\")&#125; 3.2 new函数new函数可以用来创建变量。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T： 1234p := new(int) // p 为 *int类型，只想匿名的int变量fmt.Println(*p) // \"0\"*p = 2 // 设置 int匿名变量值为2fmt.Println(*p) new函数还可以用来为结构体创建实例： 1234type file struct &#123;&#125;f := new(file) 贴士：new函数其实是语法糖，不是新概念，如下所示的两个函数其实拥有相同的行为。 12345678func newInt1() *int &#123; return new(int)&#125;func newInt2() *int &#123; var dummy int return &amp;dummy&#125; 注意：new只是一个预定义函数，并不是一个关键字，所以new也有可能会被项目定义为别的类型。 3.3 make函数make函数经常用来创建切片、Map、管道： 12m1 := map[string]int&#123;&#125;m2 := make(map[string]int, 10) 上面展示了两种map的创建方式，其不同点是第一种创建方式无法预估长度，当长度超过了当前长度时，会引起内存的拷贝！！第二种创建方式直接限定了长度，这样能有效提升性能！","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-数组","slug":"值类型-3-数组","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-17T07:28:25.962Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 数组1.1 数组的声明数组是一段固定长度的连续内存区域。数组的长度定义后不可更改，长度使用 len() 获取。 123456var arr1 [10]int //定义长度为10的整型数组，很少这样使用arr2 [5]int := [5]int&#123;1,2,3,4,5&#125; //定义并初始化arr3 := [5]int&#123;1,2,3,4,5&#125; //自动推导并初始化arr4 := [5]int&#123;1,2&#125; //指定总长度，前几位被初始化，没有的使用零值arr5 := [5]int&#123;2:10, 4:11&#125; //有选择的初始化，没被初始化的使用零值arr6 := [...]int&#123;2,3,4&#125; //自动计算长度 1.2 数组常用操作1234arr[:] 代表所有元素arr[:5] 代表前五个元素，即区间的左闭右开arr[5:] 代表从第5个开始（不包含第5个）len(arr) 数组的长度 贴士：上述操作会引发类型的变化，数组将会转化为Go中新的数据类型slice，见09节 1.3 数组的遍历方式一：for循环遍历 12345arr := [3]int&#123;1,2,3&#125;for i := 0; i &lt; len(arr); i++ &#123; fmt.Println(arr[i])&#125; 方式二：for-range遍历 123456arr := [3]int&#123;1,2,3&#125;for k, v := range arr &#123; fmt.Println(k) //元素位置 fmt.Println(v) //元素值&#125; 1.4 数组使用注意事项数组创建完长度就固定，不可以再追加元素； 长度是数组类型的一部分，因此[3]int与[4]int是不同的类型； 数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该函数的副本，而不是他的指针。","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-函数2-闭包","slug":"函数-2-闭包","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-17T07:28:53.464Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 闭包1.1 闭包概念闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使己经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量。 简单的说 : 函数+引用环境=闭包 贴士：闭包( Closure)在某些编程语言中也被称为 Lambda表达式（如Java） 在闭包中可以修改引用的变量： 123456str := \"hello\"foo := func()&#123; // 声明一个匿名函数 str = \"world\"&#125;foo() // 调用匿名函数，修改str值fmt.Print(str) // world 1.2 闭包案例一 简单示例12345678910111213141516171819func fn1(a int) func(i int) int &#123; return func(i int) int &#123; print(&amp;a, a) return a &#125;&#125;func main() &#123; f := fn1(1) //输出地址 g := fn1(2) //输出地址 fmt.Println(f(1)) //输出1 fmt.Println(f(1)) //输出1 fmt.Println(g(2)) //输出2 fmt.Println(g(2)) //输出2&#125; 1.3 闭包案例二 实现累加器12345678910111213func Accumulate(value int) func() int &#123; return func() int &#123; // 返回一个闭包 value++ return value &#125;&#125;func main() &#123; accAdd := Accumulate(1) fmt.Println(accAdd()) // 2 fmt.Println(accAdd()) // 3&#125;","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-标识符与变量","slug":"标识符与变量","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-17T07:14:53.699Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 标识符1.1 关键字Go现在拥有25个关键字： 1234if for func case struct import go type chan defer default packagemap const else break select interfacevar goto range return switch continue fallthrough 1.2 保留字123456789101112内建常量： true false iota nil内建类型： int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64bool： byte rune string error内建函数： make delete complex panic append copy close len cap real imag new recover 二 变量2.1 变量声明Go变量声明的三种方式： 123var a int // 声明一个变量，默认为0var b = 10 // 声明并初始化，且自动推导类型c := 20 // 初始化，且自动推导 注意： :=定义变量只能在函数内部使用，所以经常用var定义全局变量 Go对已经声明但未使用的变量会在编译阶段报错：** not used Go中的标识符以字母或者下划线开头，大小写敏感 Go推荐使用驼峰命名 2.2 多变量声明12345678var a,b stringvar a1,b1 string = \"哼\",\"哈\"var a2,b2 int = 1,2 //类型可以直接省略c,d := 1,2var( e int f bool) 2.3 变量值互换12m,n = n,m //变量值互换temp,_ = m,n //匿名变量：变量值互换，且丢弃变量n 2.4 _丢弃变量_是个特殊的变量名，任何赋予它的值都会被丢弃。该变量不占用命名空间，也不会分配内存。 1_, b := 34, 35 //将值`35`赋予`b`，并同时丢弃`34`： 2.5 := 声明的注意事项下面是正确的代码示例： 12in, err := os.Open(file)out, err := os.Create(file) // err已经在上方定义，此处的 err其实是赋值 但是如果在第二行赋值的变量名全部和第一行一致，则编译不通过： 12in, err := os.Open(file)in, err := os.Create(file) // 即 := 必须确保至少有一个变量是用于声明 :=只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么:=将会在当前词法域重新声明一个新的变量。 2.6 多数据分组书写Go可以使用该方式声明多个数据： 1234567891011const( i = 100 pi = 3.1415 prefix = \"Go_\") var( i int pi float32 prefix string) 三 关键字iota关键字iota声明初始值为0，每行递增1： 123456789101112131415161718const ( a = iota // 0 b = iota // 1 c = iota // 2)const ( d = iota // 0 e // 1 f // 2)//如果iota在同一行，则值都一样const ( g = iota //0 h,i,j = iota,iota,iota // 1,1,1 // k = 3 // 此处不能定义缺省常量，会编译错误 )","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-常量","slug":"常量","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-17T07:19:07.537Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 常量常量：在编译阶段就确定下来的值，程序运行时无法改变。 定义方式： 123const A = 3const PI float32 = 3.1415const mask = 1 &lt;&lt; 3 //常量与表达式 错误写法：常量赋值是一个编译期行为，右边的值不能出现在运行时才能得到结果的值。 1const HOME = os.GetEnv(\"HOME\") 二 无类型常量一个常量可以有任意一个确定的基础类型，例如int或float64，但是许多常量并没有一个明确的基础类型。 无类型常量的作用： 编译器会为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算，可以认为至少有256bit的运算精度 无类型的常量可以直接用于更多的表达式而不需要显式的类型转换 示例：math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方： 123var x float32 = math.Pivar y float64 = math.Pivar z complex128 = math.Pi 如果math.Pi被确定为特定类型，比如float64，那么结果精度可能会不一样，同时对于需要float32或complex128类型值的地方则会强制需要一个明确的类型转换： 12345const Pi64 float64 = math.Pivar x float32 = float32(Pi64)var y float64 = Pi64var z complex128 = complex128(Pi64) 对于常量面值，不同的写法可能会对应不同的类型。例如0、0.0、0i和\\u0000虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，true和false也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。 前面说过除法运算符/会根据操作数的类型生成对应类型的结果。因此，不同写法的常量除法表达式可能对应不同的结果： 1234var f float64 = 212fmt.Println((f - 32) * 5 / 9) // \"100\"; (f - 32) * 5 is a float64fmt.Println(5 / 9 * (f - 32)) // \"0\"; 5/9 is an untyped integer, 0fmt.Println(5.0 / 9.0 * (f - 32)) // \"100\"; 5.0/9.0 is an untyped float 只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语句，或者出现在有明确类型的变量声明的右边，如下面的其余三行语句，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话。 1234var f float64 = 3 + 0i // untyped complex -&gt; float64f = 2 // untyped integer -&gt; float64f = 1e123 // untyped floating-point -&gt; float64f = 'a' // untyped rune -&gt; float64 上面的语句相当于: 1234var f float64 = float64(3 + 0i)f = float64(2)f = float64(1e123)f = float64('a') 无论是隐式或显式转换，将一种类型转换为另一种类型都要求目标可以表示原始值。对于浮点数和复数，可能会有舍入处理： 123456789const ( deadbeef = 0xdeadbeef // untyped int with value 3735928559 a = uint32(deadbeef) // uint32 with value 3735928559 b = float32(deadbeef) // float32 with value 3735928576 (rounded up) c = float64(deadbeef) // float64 with value 3735928559 (exact) d = int32(deadbeef) // compile error: constant overflows int32 e = float64(1e309) // compile error: constant overflows float64 f = uint(-1) // compile error: constant underflows uint) 对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型，就像下面的例子： 1234i := 0 // untyped integer; implicit int(0)r := '\\000' // untyped rune; implicit rune('\\000')f := 0.0 // untyped floating-point; implicit float64(0.0)c := 0i // untyped complex; implicit complex128(0i) 注意有一点不同：无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。如果不知道浮点数类型的内存大小是很难写出正确的数值算法的，因此Go语言不存在整型类似的不确定内存大小的浮点数和复数类型。 如果要给变量一个不同的类型，我们必须显式地将无类型的常量转化为所需的类型，或给声明的变量指定明确的类型，像下面例子这样： 12var i = int8(0)var i int8 = 0 当尝试将这些无类型的常量转为一个接口值时（见第7章），这些默认类型将显得尤为重要，因为要靠它们明确接口对应的动态类型。 1234fmt.Printf(\"%T\\n\", 0) // \"int\"fmt.Printf(\"%T\\n\", 0.0) // \"float64\"fmt.Printf(\"%T\\n\", 0i) // \"complex128\"fmt.Printf(\"%T\\n\", '\\000') // \"int32\" (rune)","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-类型转换","slug":"类型转换与别名","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-17T07:22:11.328Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 数据类型转换1.1 显式转换Go在不同类型的变量之间赋值时需要显式转换。也就是说Golang中数据类型不能自动转换。 1.2 数值类型转换123var i int32 = 100var n1 float64 = float64(i)fmt.Printf(\"n1=%v\", n1) //输出100 注意：在转换中，比如将int64转成int8【-128---127】，编译时不会报错，只是转换的结果是按溢出处理，和我们希望的结果不一样。 因此在转换时，需要考虑范围。 1.3 基本数据类型与字符串转换基本数据类型转字符串：fmt.Sprintf();该函数会返回转换后的字符串 12345var b bool = truevar str stringstr = fmt.Sprintf(\"%t\", b)fmt.Printf(str) //true 字符串转基本数据类型：使用包strconv 1234var str string = \"true\"var b boolb, _ = strconv.ParseBool(str) fmt.Printf(\"%v\", b) 注意：在将String类型转成基本数据类型时，要确保String类型能够转成有效的数据，比如可以把”123”,转成一个整数，但不能转换”hello”，如果这样做，Golang 直接将其转成0，其它类型也是一样的道理，如：float =&gt; 0 bool =&gt; false。 二 类型别名2.1 类型别名的使用Go在1.9版本加入了类型别名。主要用于代码升级、迁移中类型的兼容问题（C/C++中使用宏来解决重构升级带来的问题）。 Go1.9之前的版本内部定义了新的类型byte和rune，用于指代uint8和int32： 12type byte uint8type rune int32 Go1.9之后uint8和int32使用了类型别名： 1234567891011121314type byte = uint8 // 使用 = 号定义后，都会按照等号右边的类型打印、计算type rune = int32``` 类型定义是定义了一个全新的类型的类型。类型别名只是某个类型的小名，并非创造了新的类型：```gotype MyInt int // 类型定义type AliasInt = int // 类型别名，支持使用括号，同时起多个别名var a1 MyIntfmt.Printf(\"a1 type: %T\\n\", a1) //main.MyIntvar a2 AliasIntfmt.Printf(\"a2 type: %T\\n\", a2) //int 2.2 不同包下的类型定义如下示例，在项目根目录新建文件夹mypack，在该目录建立person.go文件： 1234567891011package mypackimport \"fmt\"type Person struct &#123;&#125;func (p *Person)Run() &#123; fmt.Println(\"run...\")&#125; 在main.go中，如下使用： 12345678910111213141516171819package mainimport ( \"TestGo/mypack\" // // TestGo 是 go.mod文件中定义的项目名：module TestGo \"fmt\")type Student mypack.Personfunc (s *Student) Study() &#123; fmt.Println(\"study...\")&#125;func main() &#123; s := &amp;Student&#123;&#125; s.Study()&#125; 2.3 不同包下的类型别名2.2 中的案例如果将类型定义改为类型别名： 1type Student = mypack.Person // 这时Student的方法就会报错：无法为 Person 添加新的方法 使用方式：必须直接在person文件中直接使用类型别名 123456789101112131415161718package mypackimport \"fmt\"type Person struct &#123;&#125;func (p *Person)Run() &#123; fmt.Println(\"run...\")&#125;type Student = Personfunc (p *Student) Study() &#123; fmt.Println(\"study...\")&#125; main中调用别名方法： 123456789101112131415161718package mypackimport \"fmt\"type Person struct &#123;&#125;func (p *Person)Run() &#123; fmt.Println(\"run...\")&#125;type Student = Personfunc (p *Student) Study() &#123; fmt.Println(\"study...\")&#125; 三 Go的类型系统补充3.1 命名类型和未命名类型 命名类型：Named Type。类型通过标识符、自定义类型表示 未命名类型：Unamed Type。也称为类型字面量（Type Literal），由预声明类型、关键字、操作符等组合而成，如array、slice、channel、pointer、function、未使用type定义的struct、未使用type定义的interface。 示例： 12345678// 命名类型，其类型是 Persontype Person struct &#123; name string&#125;// 未命名类型，其类型是 struct &#123; name string &#125;p := struct &#123; name string&#125; 3.2 底层类型所有类型都有一个底层类型 underlying type，其规则如下： 预声明类型（Pre-declared types）和类型字面量（type literals）的底层类型是他们自身 自定义类型type newtype oldtype中newtype的底层类型是逐层递归向下查找的，直到找到oldtype的预声明类型或字面量类型 3.3 Go中的类型相同Go中类型相同的规范： 命名类型的数据类型相同：声明语句必须完全相同 未命名类型数据类型相同：类型声明字面量结构相同，且内部元素的类型相同 命名类型与未命名类型永远不同 通过类型别名语句声明的两个类型相同。类型别名语法：type T1 = T2","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-运算符","slug":"运算符","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-17T07:27:07.742Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 运算符1.1 运算符汇总123456算术运算符： + - * &#x2F; % ++ -- 关系运算符： &#x3D;&#x3D; !&#x3D; &lt;&#x3D; &gt;&#x3D; &lt; &gt; 逻辑运算符： ! &amp;&amp; ||位运算： &amp;（按位与） |（按位或） ^（按位取反） &lt;&lt;（左移） &gt;&gt;（右移）赋值运算符： &#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;其他运算符： &amp;（取地址） *（取指针值） &lt;-（Go Channel相关运算符） 1.2 自增、自减Go中只有后--和后++，且自增自减不能用于表达式中，只能独立使用： 123a = i++ // 错误用法if i++ &gt; 0 &#123;&#125; // 错误用法i++ // 正确用法 1.3 位运算12345&amp; 按位与，参与运算的两个数二进制位相与：同时为1，结果为1，否则为0| 按位或，参与运算的两个数二进制位相或：有一个为1，结果为1，否则为0^ 按位异或：二进位不同，结果为1，否则为0&lt;&lt; 按位左移：二进位左移若干位，高位丢弃，低位补0，左移n位其实就是乘以2的n次方&gt;&gt; 按位右移：二进位右移若干位，右移n位其实就是除以2的n次方 二 优先级 三 进制转换1.1 常见进制 二进制：只有0和1，Go中不能直接使用二进制表示整数 八进制：0-7，以数字0开头 十进制：0-9 十六进制：0-9以及A-F，以0X开头，A-F以及X不区分大小写 1.2 任意进制转换为十进制二进制转十进制： 从最低位开始，每个位上数乘以2（位数-1）次方然后求和1011 = 1*20 + 1*21 + 0*22 + 1*23 = 11 八进制转十进制： 从最低位开始，每个位上数乘以8（位数-1）次方然后求和0123 = 3*80 + 2*81 + 1*82 + 0*83 = 83 其他进制转十进制同理。 1.3 十进制转其他进制十进制转二进制： 不断除以2，直到0为止,余数倒过来即可，如图计算28转换为二进制11100 十进制转八进制：不断除以8，直到0为止，余数倒过来即可。 十进制转十六进制：不断除以16，直到0为止，余数倒过来即可。 1.4 其他进制互转 二进制转换八进制：将二进制数从低位开始，每三位一组，转换成八进制数即可 二进制转十六进制：将二进制数从低位开始，每四位一组，转换成十六进制数即可 八进制转换二进制：将八进制数每1位转换成一个3位的二进制数（首位0除外） 十六进制转二进制：将十六进制每1位转换成对应的一个4位的二进制数即可 四 计算机运算原理计算机常见的术语： bit：比特，代表1个二进制位，一个位只能是0或者1 Byte：字节，代表8个二进制位，计算机中存储的最小单元是字节 WORD：双字节，即2个字节，16位 DWORD：两个WORD，即4个字节，32位 一些常用单位： 1b：1bit，1位 1Kb：1024bit，即1024位 1Mb：1024*1024bit 1B：1Byte，1字节，8位 1KB：1024B 1MB：1024K 对于有符号数而言，二进制的最高为是符号位：0表示正数，1表示负数，比如 1在二进制中： 121 二进制位：0000 0001-1 二进制位：1000 0001 正数的原码、反码、补码都一样，负数的反码=原码符号位不变，其他位取反，补码是反码+1 1234 1 -1原码 0000 0001 1000 0001反码 0000 0001 1111 1110补码 0000 0001 1111 1111 常见理解： 0的反码补码都是0 计算机中是以补码形式运算的","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-结构体","slug":"值类型-4-结构体","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-17T07:28:47.870Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 结构体的基本使用结构体可以用来声明新的类型，作为其他类型的属性/字段的容器，如下定义一个学生结构体： 1234567891011121314151617181920type Person struct &#123; name string age int&#125;//按顺序初始化：每个成员都必须初始化var p1 Person = Person&#123;\"lisi\", 20&#125;//制定成员初始化：没有被初始化的，自动赋零值p2 := Person&#123;age:30&#125; // new 申请结构体p3 := new(Person) //被new生成的结构体实例其实是指针类型p3.name = \"zs\" //这里的.语法只是语法糖，将p3.name转换成了(*p3).namep3.age = 27 //直接声明var s4 Personp4.name = \"ww\"p4.age = 30 贴士： struct的结构中的类型可以是任意类型，且存储空间是连续的，其字段按照声明时的顺序存放 如果结构体的所有的成员都是可以比较的，那么结构体本身也是可以比较的，使用 == != ，不支持 &gt; 和 &lt; 如果结构体的成员要被包外调用，需要大写首字母。 二 结构体地址与实例化前面说过，对结构体的new其实是生成了一个指针类型。其实对结构体进行&amp;取地址操作时，也可以视为对该类型进行一次new的实例化操作。 1234ins := &amp;T&#123;&#125;# T是结构体类型# ins为结构体的实例，类型为*T，是指针类型 四 内嵌结构体当前结构体可以直接访问其内嵌结构体的内部字段： 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport \"fmt\"type Animal struct &#123; Age int&#125;type Person struct &#123; Animal Name string&#125;type Student struct &#123; Person ClassName string&#125;func main() &#123; // 初始化方式1 s1 := Student&#123; Person&#123; Animal: Animal &#123; Age: 15, &#125;, Name:\"lisi\", &#125;, \"一班\", &#125; fmt.Println(s1.Age) // 正确输出15 fmt.Println(s1.Person.Name) // 正确输出lisi // 初始化方式2 var s2 Student s2.Name = \"zs\" s2.Age = 30 s2.ClassName = \"二班\" fmt.Println(s2.Age) // 正确输出30 fmt.Println(s2.Person.Name) // 正确输出zs&#125; 四 匿名字段结构体的字段名与类型一一对应，如果不提供名字，则为匿名字段。 匿名字段如果是一个struct，这个struct拥有的全部字段都被隐式引入了当前的struct。 123456789type Person struct &#123; name string age int&#125; type Student struct &#123; Person // 匿名字段，那么默认Student就包含了Human的所有字段 classroom string&#125; 不仅仅是struct，其他所有内置类型和自定义类型都可以作为匿名字段： 1234567891011121314151617181920212223242526272829package mainimport \"fmt\"type Person struct &#123; name string age int&#125;type course []stringtype Student struct &#123; Person // 匿名字段，struct course // 内置一个切片类型 classroom string&#125;func main() &#123; // 创建一个学生 s := Student&#123;Person:Person&#123;\"LiLei\", 17&#125;, classroom:\"二班\"&#125; // 访问该学生字段 fmt.Println(\"name = \", s.name) fmt.Println(\"classroom = \", s.classroom) // 修改学生的课程 s.course = []string&#123;\"语文\", \"美术\"&#125; fmt.Println(\"course = \", s.course) // [语文 美术]&#125; 贴士：如果Person和Student中都有同一个字段，那么Go会优先访问当前层。例如二者都有tel字段，那么s.tel将会访问的是Student中的数据。","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-流程控制","slug":"流程控制","date":"2020-06-16T07:24:57.000Z","updated":"2020-06-17T07:22:35.811Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 流程控制之-条件语句1.1 判断语句 ifif判断示例： 123// 初始化与判断写在一起： if a := 10; a == 10if i == '3' &#123; &#125; if的特殊写法： 12if err := Connect(); err != nil &#123; // 这里的 err!=nil 才是真正的if判断表达式&#125; 1.2 分支语句 switch示例： 12345678switch num &#123; case 1: // case 中可以是表达式 fmt.Println(\"111\") case 2: fmt.Println(\"222\") default: fmt.Println(\"000\")&#125; 贴士： Go保留了break，用来跳出switch语句，上述案例的分支中默认就书写了该关键字 Go也提供fallthrough，代表不跳出switch，后面的语句无条件执行 二 流程控制之-循环语句2.1 for循环Go只支持for一种循环语句，但是可以对应很多场景： 12345678910111213141516171819202122// 传统的for循环for init;condition;post&#123;&#125;// for循环简化var i intfor ; ; i++ &#123; if(i &gt; 10)&#123; break; &#125;&#125;// 类似while循环for condition &#123;&#125;// 死循环for&#123;&#125;// for range:一般用于遍历数组、切片、字符串、map、管道for k, v := range []int&#123;1,2,3&#125; &#123;&#125; 2.2 跳出循环常用的跳出循环关键字： break用于函数内跳出当前for、switch、select语句的执行 continue用于跳出for循环的本次迭代。 goto可以退出多层循环 break跳出循环案例(continue同下)： 12345678910111213OuterLoop: for i := 0; i &lt; 2; i++ &#123; for j := 0; j &lt; 5; j++ &#123; switch j &#123; case 2: fmt.Println(i,j) break OuterLoop case 3: fmt.Println(i,j) break OuterLoop &#125; &#125; &#125; goto跳出多重循环案例： 123456789101112for x:=0; x&lt;10; x++ &#123; for y:=0; y&lt;10; x++ &#123; if y==2 &#123; goto breakHere &#125; &#125; &#125;breakHere: fmt.Println(\"break\") 贴士：goto也可以用来统一错误处理。 123456if err != nil &#123; goto onExit&#125;onExit: fmt.Pritln(err) exitProcess()","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-反射2","slug":"反射-2-应用","date":"2020-05-09T02:24:27.000Z","updated":"2020-06-17T07:20:07.212Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 反射的使用1.1 反射操作简单数据类型12345678910111213var num int64 = 100// 设置值：指针传递ptrValue := reflect.ValueOf(&amp;num)newValue := ptrValue.Elem() // Elem()用于获取原始值的反射对象fmt.Println(\"type：\", newValue.Type()) // int64fmt.Println(\" can set：\", newValue.CanSet()) // truenewValue.SetInt(200)// 获取值：值传递rValue := reflect.ValueOf(num)fmt.Println(rValue.Int()) // 方式一：200fmt.Println(rValue.Interface().(int64)) // 方式二：200 1.2 反射进行类型推断1234567891011121314type user struct &#123; Name string Age int&#125;u := &amp;user&#123; Name: \"Ruyue\", Age: 100,&#125;fmt.Println(reflect.TypeOf(u)) // *main.userfmt.Println(reflect.TypeOf(*u)) // main.userfmt.Println(reflect.TypeOf(*u).Name()) // userfmt.Println(reflect.TypeOf(*u).Kind()) // struct 1.3 反射操作指针12345678910111213type user struct &#123; Name string Age int&#125;u := &amp;user&#123; Name: \"Ruyue\", Age: 100,&#125;typeOfUser = reflect.TypeOf(u).Elem()fmt.Println(\"element name: \", typeOfUser.Name()) // userfmt.Println(\"element kind: \", typeOfUser.Kind()) // struct 1.4 反射操作结构体反射可以获取结构体的详细信息： 1234567891011121314151617181920212223242526type user struct &#123; Name string Age int `json:\"age\" id:\"100\"` // 结构体标签&#125;s := user&#123; Name: \"zs\", Age: 1,&#125;typeOfUser := reflect.TypeOf(s)// 字段用法for i := 0; i &lt; typeOfUser.NumField(); i++ &#123; // NumField 当前结构体有多少个字段 fieldType := typeOfUser.Field(i) // 获取每个字段 fmt.Println(fieldType.Name, fieldType.Tag)&#125;if userAge, ok := typeOfUser.FieldByName(\"Age\"); ok &#123; fmt.Println(userAge) // &#123;Age int json:\"age\" id:\"100\" 16 [1] false&#125;&#125;// 方法用法for i := 0; i &lt; typeOfUser.NumMethod(); i++ &#123; fieldType := typeOfUser.Method(i) // 获取每个字段 fmt.Println(fieldType.Name)&#125; 二 反射调用函数与方法2.1 使用反射调用函数如果反射值对象(reflect.Value)中值的类型为函数时，可以通过 reflect.Value调用该 函数。使用反射调用函数时，需要将参数使用反射值对象的切片 口reflect.Value 构造后传入 Call()方法中 ， 调用完成时，函数的返回值通过 []reflect.Value 返回 。 1234567891011func add(name string, age int) &#123; fmt.Printf(\"name is %s, age is %d \\n\", name, age)&#125;func main() &#123; funcValue := reflect.ValueOf(add) params := []reflect.Value&#123;reflect.ValueOf(\"lisi\"), reflect.ValueOf(20)&#125; reList := funcValue.Call(params) fmt.Println(reList) // 函数返回值&#125; 2.2 反射调用方法方法的调用是需要接收者的： 123456789101112131415161718192021222324252627282930313233package mainimport ( \"fmt\" \"reflect\")type user struct &#123; Name string Age int&#125;func (u *user) ShowName() &#123; fmt.Println(u.Name)&#125;func (u *user) AddAge(addNum int) &#123; fmt.Println(\"age add result:\", u.Age + addNum)&#125;func main() &#123; u := &amp;user&#123;\"lisi\", 20&#125; v := reflect.ValueOf(u) // 调用无参方法 methodV := v.MethodByName(\"ShowName\") methodV.Call(nil) // 或者传递一个空切片也可 // 调用有参方法 methodV2 := v.MethodByName(\"AddAge\") args := []reflect.Value&#123;reflect.ValueOf(30)&#125; // methodV2.Call(args)&#125;","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-反射-1","slug":"反射-1-概述","date":"2020-05-03T01:54:07.000Z","updated":"2020-06-17T07:19:29.833Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 反射简介反射是指在程序运行期对程序本身进行访问和修改的能力，即可以在运行时动态获取变量的各种信息，比如变量的类型（type），类别（kind），如果是结构体变量，还可以获取到结构体本身的信息（字段与方法），通过反射，还可以修改变量的值，可以调用关联的方法。 反射常用在框架的开发上，一些常见的案例，如JSON序列化时候tag标签的产生，适配器函数的制作等，都需要用到反射。反射的两个使用常见使用场景： 不知道函数的参数类型：没有约定好参数、传入类型很多，此时类型不能统一表示，需要反射 不知道调用哪个函数：比如根据用户的输入来决定调用特定函数，此时需要依据函数、函数参数进行反射，在运行期间动态执行函数 Go程序的反射系统无法获取到一个可执行文件空间中或者是一个包中的所有类型信息，需要配合使用标准库中对应的词法、语法解析器和抽象语法树( AST) 对源码进行扫描后获得这些信息。 贴士： C，C++没有支持反射功能，只能通过 typeid 提供非常弱化的程序运行时类型信息。 Java、 C#等语言都支持完整的反射功能。 Lua、JavaScript类动态语言，由于其本身的语法特性就可以让代码在运行期访问程序自身的值和类型信息，因此不需要反射系统。 注意： 在编译期间，无法对反射代码进行一些错误提示。 反射影响性能 二 反射是如何实现的反射是通过接口的类型信息实现的，即反射建立在类型的基础上：当向接口变量赋予一个实体类型的时候，接口会存储实体的类型信息。 Go中反射相关的包是reflect，在该包中，定义了各种类型，实现了反射的各种函数，通过它们可以在运行时检测类型的信息、改变类型的值。 变量包括type、value两个部分（所以 nil != nil ），type包括两部分： static type：在开发时使用的类型，如int、string concrete type：是runtime系统使用的类型 类型能够断言成功，取决于 concrete type ，如果一个reader变量，如果 concrete type 实现了 write 方法，那么它可以被类型断言为writer。 Go中，反射与interface类型相关，其type是 concrete type，只有interface才有反射！每个interface变量都有一个对应的pair，pair中记录了变量的实际值和类型（value, type）。即一个接口类型变量包含2个指针，一个指向对应的 concrete type ，另一个指向实际的值 value。 示例： 12345var r io.Reader // 定义了一个接口类型r, err := os.OpenFile() // 记录接口的实际类型、实际值var w io.Writer // 定义一个接口类型w = r.(io.Writer) // 赋值时，接口内部的pair不变，所以 w 和 r 是同一类型 三 Go中反射初识3.1 reflect包的两个函数reflect 提供了2个重要函数： ValueOf()：获取变量的值，即pair中的 value TypeOf()：获取变量的类型，即pair中的 concrete type 12345678910111213141516type Person struct &#123; Name string Age int&#125;p := Person&#123; \"lisi\", 13&#125;fmt.Println(reflect.ValueOf(p)) // &#123;lisi 13&#125; 变量的值fmt.Println(reflect.ValueOf(p).Type()) // main.Person 变量类型的对象名fmt.Println(reflect.TypeOf(p)) // main.Person 变量类型的对象名fmt.Println(reflect.TypeOf(p).Name()) // Person:变量类型对象的类型名fmt.Println(reflect.TypeOf(p).Kind()) // struct:变量类型对象的种类名fmt.Println(reflect.TypeOf(p).Name() == \"Person\") // truefmt.Println(reflect.TypeOf(p).Kind() == reflect.Struct) //true 类型与种类的区别： Type是原生数据类型： int、string、bool、float32 ，以及 type 定义的类型，对应的反射获取方法是 reflect.Type 中 的 Name() Kind是对象归属的品种：Int、Bool、Float32、Chan、String、Struct、Ptr（指针）、Map、Interface、Fune、Array、Slice、Unsafe Pointer等 3.2 静态类型与动态类型静态类型：变量声明时候赋予的类型 12type MyInt int // int 是静态类型var i *int // *int 是静态类型 动态类型：运行时给这个变量赋值时，这个值的类型即为动态类型（为nil时没有动态类型）。 123var A interface&#123;&#125; // 空接口 是静态类型，必须是接口类型才能实现类型动态变化A = 10 // 此时静态类型为 interface&#123;&#125; 动态为intA = \"hello\" // 此时静态类型为 interface&#123;&#125; 动态为string","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-时间操作","slug":"时间操作","date":"2020-04-26T02:34:57.000Z","updated":"2020-06-17T07:23:53.042Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 时间操作1.1 创建时间Golang中时间操作位于 time 包中，常见操作有： 12345678// 当前时间nowTime := time.Now()fmt.Printf(\"当前时间为：%T\\n\", nowTime) // 其类型是 time.Timefmt.Println(nowTime) // 2019-01-01 13:50:07.522712 +0800 CST m=+0.000138178// 自定义时间customTime := time.Date(2008, 7, 15, 13, 30,0,0, time.Local)fmt.Println(customTime) // 2008-07-15 13:30:00 +0800 CST 1.2 时间格式化与解析Go的时间格式化必须传入Go的生日：Mon Jan 2 15:04:05 -0700 MST 2006 123nowTime := time.Now()stringTime := nowTime.Format(\"2006年1月2日 15:04:05\")fmt.Println(stringTime) // 2019年01月01日 13:55:30 Go的时间解析： 123 stringTime := \"2019-01-01 15:03:01\"objTime,_ := time.Parse(\"2006-01-02 15:04:05\",stringTime)fmt.Println(objTime) // 2019-01-01 15:03:01 +0000 UTC 注意：这些方法的参数模板必须与时间一一对应，否则报错！ 1.3 获取 年 月 日12345678910111213 nowTime := time.Now()year, month, day := nowTime.Date()fmt.Println(year, month, day) // 2019 November 01hour, min, sec := nowTime.Clock()fmt.Println(hour, min, sec)fmt.Println(nowTime.Year())fmt.Println(nowTime.Month())fmt.Println(nowTime.Hour())fmt.Println(nowTime.YearDay()) // 指今年一共过了多少天 1.4 时间戳时间戳是指计算时间距离 1970年1月1日的秒数： 12nowTime := time.Now()fmt.Println(nowTime.Unix()) 1.5 时间间隔123nowTime := time.Now()fmt.Println(nowTime.Add(time.Second * 10)) // 10秒后 fmt.Println(nowTime.AddDate(1, 0, 0)) // 1年后 贴士： 传入负数则是往前计算 Sub()函数可以用来计算两个时间的差值 1.6 时间睡眠1time.Sleep(time.Second * 3) // 程序睡眠三秒钟 二 时间中的通道操作（定时器）标准库中的Timer可以让用户自定义一个定时器，在用对select处理多个channel的超时、单channel读写的超时等情形时很方便： 123timer := time.NewTimer(time.Second * 3) // 类型为 *time.Timerch := timer.C // timer内部包含一个通道fmt.Println(&lt;-ch) // 3秒后，通道内有了数据，可以取出 配合协程： 12345678910timer := time.NewTimer(time.Second * 3) // 类型为 *time.Timergo func() &#123; &lt;- timer.C fmt.Println(\"timer 结束\")&#125;()time.Sleep(time.Second * 5)flag := timer.Stop() // 取消定时器 fmt.Println(flag) // false time.After函数的使用： 123ch := time.After(time.Second * 3) // 底层其实是 new Timer(d).CnewTime := &lt;-ch // 阻塞3秒fmt.Println(newTime)","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-文件的读操作","slug":"文件操作-2-读操作","date":"2020-04-23T05:44:57.000Z","updated":"2020-06-17T07:25:04.173Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 文件读取文件读写的接口位于io包，file文件类是这些接口的实现类。 1.1 直接读取 read()read() 实现的是按字节数读取： 1234567891011121314readByte := make([]byte, 128) // 指定要读取的长度for &#123; n, err := f.Read(readByte) // 将数据读取如切片，返回值 n 是实际读取到的字节数 if err != nil &amp;&amp; err != io.EOF&#123; // 如果读到了文件末尾：EOF 即 end of file fmt.Println(\"read file : \", err) break &#125; fmt.Println(\"read: \", string(readByte[:n])) if n &lt; 128 &#123; fmt.Println(\"read end\") break &#125;&#125; 1.2 bufio的写操作bufio封装了io.Reader、io.Writer接口对象，并创建了另一个也实现了该接口的对象：bufio.Reader、bufio.Writer。通过该实现，bufio实现了文件的缓冲区设计，可以大大提高文件I/O的效率。 使用bufio读取文件时，先将数据读入内存的缓冲区（缓冲区一般比要比程序中设置的文件接收对象要大），这样就可以有效降低直接I/O的次数。 bufio.Read([]byte)相当于读取大小len(p)的内容： 当缓冲区有内容时，将缓冲区内容全部填入p并清空缓冲区 当缓冲区没有内容且len(p)&gt;len(buf)，即要读取的内容比缓冲区还要大，直接去文件读取即可 当缓冲区没有内容且len(p)&lt;len(buf)，即要读取的内容比缓冲区小，读取文件内容并填满缓冲区，并将p填满 以后再次读取时，缓冲区有内容，将缓冲区内容全部填入p并清空缓冲区（和第一步一致） 示例： 123456// 创建读对象reader := bufio.NewReader(f)// 读一行数据byt, _ := reader.ReadBytes('\\n') fmt.Println(string(byt)) ReadString() 函数也具有同样的功能，且能直接读取到字符串数据，无需转换，示例：读取大文件的全部数据 12345678910111213reader := bufio.NewReader(f)for &#123; // 按照缓冲区读取：读取到特定字符结束 str, err := reader.ReadString('\\n') // 按行读取 if err != nil &amp;&amp; err != io.EOF &#123; fmt.Println(\"read err: \", err) break &#125; fmt.Println(\"str = \", str) if err == io.EOF &#123; fmt.Print(\"read end\") break &#125;&#125; 在Unix设计思想中，一切皆文件，命令行输入也可以作为文件读入： 12reader := bufio.NewReader(os.Stdin)s, _ := reader.ReadString(\"-\") // 假设命令行以 - 开始 缓冲的思想：通过bufio，数据被写入用户缓冲，再进入系统缓冲，最后由操作系统将系统缓冲区的数据写入磁盘。 1.3 io/ioutil 包文件读取ioutil直接读取文件： 123456ret, err := ioutil.ReadFile(\"test.txt\")if err != nil &#123; fmt.Println(\"read err :\", err) return&#125;fmt.Println(string(ret)) 二 文件写入2.1 直接写123456789101112f, err := os.OpenFile(\"test.txt\", os.O_CREATE | os.O_WRONLY, os.ModePerm)if err != nil &#123; fmt.Println(\"open err:\", err) return&#125;defer f.Close()n, err := f.Write([]byte(\"hello world\"))if err != nil &#123; fmt.Println(\"write err:\", err)&#125;fmt.Println(n) // 每次都会从头开始重新写入 上述案例中，如果我们不想每次写入都会从头开始重新写入，那么需要将打开模式修改为：os.O_CREATE | os.O_WRONLY | os.O_APPEND 2.2 bufio的写操作1234567writer := bufio.NewWriter(f)_, err = writer.WriteString(\"hello world!\")if err != nil &#123; fmt.Println(\"write err:\", err) return&#125;writer.Flush() // 必须刷新缓冲区：将缓冲区的内容写入文件中。如果不刷新，则只会在内容超出缓冲区大小时写入 2.3 io/ioutil 包文件写入12s := \"你好世界\"err := ioutil.WriteFile(\"test.txt\", []byte(s), os.ModePerm) 三 文件读取偏移量文件读取时，是可以控制光标位置的： 12345678910111213141516171819202122232425262728f, err := os.OpenFile(\"test.txt\", os.O_RDWR, os.ModePerm)if err != nil &#123; fmt.Println(\"open err:\", err) return&#125;defer f.Close()// 读取前五个字节，假设读取的文件内容为： hello world!bs := []byte&#123;0&#125; // 创建1个字节的切片_, err = f.Read(bs)if err != nil &#123; fmt.Println(\"read err:\", err) return&#125;fmt.Println(\"读到的数据是：\", string(bs)) // h// 移动光标_, err = f.Seek(4, io.SeekStart) // 光标从开始位置(h之前)，移动4位，到达o之前if err != nil &#123; fmt.Println(\"seek err:\", err) return&#125;_, err = f.Read(bs)if err != nil &#123; fmt.Println(\"read err:\", err) return&#125;fmt.Println(\"读到的数据是：\", string(bs)) // o 通过记录光标的位置，可以实现断点续传：假设已经下载了1KB文件，即本地临时文件存储了1KB，此时断电，重启后通过本地文件大小、Seek()方法获取到上次读取文件的光标位置即可实现继续下载！","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-接口使用","slug":"接口类型-1-接口的使用","date":"2020-04-21T07:24:57.000Z","updated":"2020-06-17T07:21:16.971Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 接口 interface接口（interface）是调用方和实现方均需要遵守的一种约束，约束开发者按照统一的方法命名、参数类型、数量来处理具体业务。实际上，接口就是一组没有实现的方法声明，到某个自定义类型要使用该方法时，根据具体情况把这些方法实现出来。接口语法： 12345type 接口类型名 interface &#123; 方法名1(参数列表) 返回值列表 方法名2(参数列表) 返回值列表 ...&#125; 示例： 123456789101112131415161718192021222324252627282930313233343536package mainimport \"fmt\"// 运输方式type Transporter interface &#123; BicycleTran() CarTran()&#125;// 驾驶员type Driver struct &#123; Name string Age int&#125;// 实现运输方式接口func (d *Driver) BicycleTran() &#123; fmt.Println(\"使用自行车运输\")&#125;func (d *Driver) CarTran() &#123; fmt.Println(\"使用小汽车运输\")&#125;func main() &#123; d := &amp;Driver&#123; \"张三\", 27, &#125; trans(d)&#125;// 只要实现了 Transporter接口的类型都可以作为参数func trans(t Transporter) &#123; t.BicycleTran()&#125; 注意： Go语言的接口在命名时，一般会在单词后面添加er，如写操作的接口叫做Writer 当方法名首字母大写，且实现的接口首字母也是大写，则该方法可以被接口所在包之外的代码访问 方法与接口中的方法签名一致（方法名、参数列表、返回列表都必须一致） 参数列表和返回值列表中的变量名可以被忽略，如：type writer interfae{ Write([]byte) error} 接口中所有的方法都必须被实现 如果编译时发现实现接口的方法签名不一致，则会报错：does not implement。 二 Go接口的特点在上述示例中，Go无须像Java那样显式声明实现了哪个接口，即为非侵入式，接口编写者无需知道接口被哪些类型实现，接口实现者只需要知道实现的是什么样子的接口，但无需指明实现了哪个接口。编译器知道最终编译时使用哪个类型实现哪个接口，或者接口应该由谁来实现。 类型和接口之间有一对多和多对一的关系，即： 一个类型可以实现多个接口，接口间是彼此独立的，互相不知道对方的实现 多个类型也可以实现相同的接口。 123456789101112131415161718192021222324252627type Service interface &#123; Start() Log(string)&#125;// 日志器type Logger struct &#123;&#125;//日志输出方法func (g *Logger) Log(s string)&#123; fmt.Println(\"日志：\", s)&#125;// 游戏服务type GameService struct &#123; Logger&#125;// 实现游戏服务的Start方法func (g *GameService) Start() &#123; fmt.Println(\"游戏服务启动\")&#125;func main() &#123; s := new(GameService) s.Start() s.Log(\"hello\")&#125; 在上述案例中，即使没有接口也能运行，但是当存在接口时，会隐式实现接口，让接口给类提供约束。 使用接口调用了结构体中的方法，也可以理解为实现了面向对象中的多态。 三 接口嵌套Go中不仅结构体之间可以嵌套，接口之间也可以嵌套。接口与接口嵌套形成了新的接口，只要接口的所有方法被实现，则这个接口中所有嵌套接口的方法均可以被调用。 123456789101112131415// 定义一个 写 接口type Writer interface &#123; Write(p []byte) (n int, e error)&#125;// 定义一个 读 接口type Reader interface &#123; Read() error&#125;// 定义一个 嵌套接口type IO interface &#123; Writer Closer&#125; 四 空接口4.1 空接口定义空接口是接口的特殊形式，没有任何方法，因此任何具体的类型都可以认为实现了空接口。 1234567var any interface&#123;&#125;any = 1fmt.Println(any)any = \"hello\"fmt.Println(any) 空接口作为函数参数： 12345678func Test(i interface&#123;&#125;) &#123; fmt.Printf(\"%T\\n\", i)&#125;func main() &#123; Test(3) // int Test(\"hello\") // sting&#125; 利用空接口，可以实现任意类型的存储： 123m := make(map[string]interface&#123;&#125;)m[\"name\"] = \"李四\"m[\"age\"] = 30 4.2 从空接口获取值保存到空接口的值，如果直接取出指定类型的值时，会发生编译错误： 123var a int = 1var i interface&#123;&#125; = avar b int = i //这里编译报错（类型不一致），可以这样做：b := i 4.3 空接口值比较类型不同的空接口比较： 1234var a interface&#123;&#125; = 100var b interface&#123;&#125; = \"hi\"fmt.Println(a == b) //false 不能比较空接口中的动态值： 123var c interface&#123;&#125; = []int&#123;10&#125;var d interface&#123;&#125; = []int&#123;20&#125;fmt.Println(c == d) //运行报错 空接口的类型和可比较性： 类型 说明 map 不可比较，会发生宕机错误 切片 不可比较，会发生宕机错误 通道 可比较，必须由同一个make生成，即同一个通道才是true 数组 可比较，编译期即可知道是否一致 结构体 可比较，可诸葛比较结构体的值 函数 可比较","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-文件的写操作","slug":"文件操作-1-写操作","date":"2020-04-21T02:24:57.000Z","updated":"2020-06-17T07:24:43.558Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 文件的基本操作1.1 创建文件1234567f, err := os.Create(\"test.txt\")if err != nil &#123; fmt.Println(err) return&#125;fmt.Println(f) // 打印文件指针f.Close() // 打开的资源在不使用时必须关闭 使用Create()创建文件时： 如果文件不存在，则创建文件。 如果文件存在，则清空文件内内容。 Create创建的文件任何人都可以读写。 1.2 打开文件，写入内容打开文件有两种方式： Open()：以只读的方式打开文件，若文件不存在则会打开失败 OpenFile()：打开文件时，可以传入打开方式，该函数的三个参数： 参数1：要打开的文件路径 参数2：文件打开模式，如 O_RDONLY，O_WRONGLY，O_RDWR，还可以通过管道符来指定文件不存在时创建文件 参数3：文件创建时候的权限级别，在0-7之间，常用参数为6 123456f, err := os.OpenFile(\"test.txt\", os.O_APPEND | os.O_RDWR, os.ModeAppend)if err != nil &#123; fmt.Println(\"open file err: \", err) return&#125;f.Close() 常用的文件打开模式： 1234567891011121314151617181920 O_RDONLY int = syscall.O_RDONLY // 只读 O_WRONGLY int = syscall.O_WRONGLY // 只写 O_RDWR int = syscall.O_RDWR // 读写 O_APPEND int = syscall.O_APPEND // 写操作时将数据追加到文件末尾 O_CREATE int = syscall.O_CREATE // 如果不存在则创建一个新文件 O_EXCL int = syscall.O_EXCL // 打开文件用于同步I/O O_TRUNC int = syscall.O_TRUNC // 如果可能，打开时清空文件``` ### 1.3 写文件写入字节 `Write()`：```go // 写入文件内容 n, err := f.Write([]byte(\"hello\")) if err != nil &#123; fmt.Println(\"write err: \", err) return &#125; fmt.Println(\"write number = \", n) 按字符串写 WriteString()： 1234567// 写入文件内容n, err := f.WriteString([\"hello\") // 会将前5个字符替换为 helloif err != nil &#123; fmt.Println(\"write err: \", err) return&#125;fmt.Println(\"write number = \", n) 修改文件的读写指针位置 Seek()，包含两个参数： 参数1：偏移量，为正数时向文件尾偏移，为负数时向文件头偏移 参数2：偏移的开始位置，包括： io.SeekStart：从文件起始位置开始 io.SeekCurrent：从文件当前位置开始 io.SeekEnd：从文件末尾位置开始 Seek()函数返回 123456f, _ := os.OpenFile(\"test.txt\",os.O_RDWR, 6)off, _ := f.Seek(5, io.SeekStart)fmt.Println(off) // 5n, _ := f.WriteAt([]byte(\"111\"), off)fmt.Println(n)f.Close() 1.4 获取文件描述信息 os.Stat()Go的os包中定义了file类，封装了文件描述信息，同时也提供了Read、Write的实现。 123456fileInfo, err := os.Stat(\"./test.txt\")if err != nil &#123; fmt.Println(\"stat err: \", err) return&#125;fmt.Printf(\"%T\\n\", fileInfo) // *os.fileStat 获取到的fileInfo内部包含 文件名Name()、大小Size()、是否是目录IsDir() 等操作。 1.5 路径、目录操作12345678910111213141516171819202122232425262728 // 路径操作 fmt.Println(filepath.IsAbs(\"./test.txt\")) // false：判断是否是绝对路径 fmt.Println(filepath.Abs(\"./test.txt\")) // 转换为绝对路径 // 创建目录 err := os.Mkdir(\"./test\", os.ModePerm) if err != nil &#123; fmt.Println(\"mkdir err: \", err) return &#125; // 创建多级目录 err = os.MkdirAll(\"./dd/rr\", os.ModePerm) if err != nil &#123; fmt.Println(\"mkdirAll err: \", err) return &#125;``` 贴士：Openfile()可以用于打开目录。### 1.6 删除文件```go err := os.Remove(\"test.txt\") if err != nil &#123; fmt.Println(\"remove err:\", err) return &#125; 该函数也可用于删除目录（只能删除空目录）。如果要删除非空目录，需要使用 RemoveAll() 函数","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]},{"title":"Go语言-接口断言、多态","slug":"接口类型-2-断言与多态","date":"2020-04-15T08:14:57.000Z","updated":"2020-06-17T07:21:45.495Z","comments":true,"path":"undefined.html","link":"","permalink":"http://www.dwlblog.网址/undefined.html","excerpt":"","text":"一 断言接口是编程的规范，他也可以作为函数的参数，以让函数更具备适用性。在下列示例中，有三个接口动物接口、飞翔接口、游泳接口，两个实现类鸟类与鱼类： 鸟类：实现了动物接口，飞翔接口 鱼类：实现了动物接口，游泳接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport \"fmt\"// 定义一个通用接口：动物接口type Animal interface &#123; Breath() // 动物都具备 呼吸方法&#125;type Flyer interface &#123; Fly()&#125;type Swimer interface &#123; Swim()&#125;// 定义一个鸟类：其呼吸的方式是在陆地type Bird struct &#123; Name string Food string Kind string&#125;func (b *Bird) Breath() &#123; fmt.Println(\"鸟 在 陆地 呼吸\")&#125;func (b *Bird) Fly() &#123; fmt.Printf(\"%s 在 飞\\n\", b.Name)&#125;// 一定一个鱼类：其呼吸方式是在水下type Fish struct &#123; Name string Kind string&#125;func (f *Fish) Breath() &#123; fmt.Println(\"鱼 在 水下 呼吸\")&#125;func (f *Fish) Swim() &#123; fmt.Printf(\"%s 在游泳\\n\", f.Name)&#125;// 一个普通函数，参数是动物接口func Display(a Animal) &#123; // 直接调用接口中的方法 a.Breath() // 调用实现类的成员：此时会报错 fmt.Println(a.Name)&#125;func main() &#123; var b = &amp;Bird&#123; \"斑鸠\", \"蚂蚱\", \"鸟类\" &#125; Display(b)&#125; 接口类型无法直接访问其具体实现类的成员，需要使用断言（type assertions），对接口的类型进行判断，类型断言格式： 12t := i.(T) //不安全写法：如果i没有完全实现T接口的方法，这个语句将会触发宕机t, ok := i.(T) // 安全写法：如果接口未实现接口，将会把ok掷为false，t掷为T类型的0值 i代表接口变量 T代表转换的目标类型 t代表转换后的变量 上述案例的Dsiplay就可以书写为： 123456789101112func Display(a Animal) &#123; // 直接调用接口中的方法 a.Breath() // 调用实现类的成员：此时会报错 instance, ok := a.(*Bird) // 注意：这里必须是 *Bird类型，因为是*Bird实现了接口，不是Bird实现了接口 if ok &#123; // 得到了具体的实现类，才能访问实现类的成员 fmt.Println(\"该鸟类的名字是：\", instance.Name) &#125; else &#123; fmt.Println(\"该动物不是鸟类\") &#125;&#125; 二 接口类型转换在接口定义时，其类型已经确定，因为接口的本质是方法签名的集合，如果两个接口的方法签名结合相同（顺序可以不同），则这2个接口之间不需要强制类型转换就可以相互赋值，因为go编译器在校验接口是否能赋值时，比较的是二者的方法集。 在上一节中，函数Display接收的是Animal接口类型，在断言后转换为了别的类型：*Bird(实现类指针类型)： 123456789func Display(a Animal) &#123; instance, ok := a.(*Bird) // 动物接口转换为了 *Bird实现类 if ok &#123; // 得到了具体的实现类，才能访问实现类的成员 fmt.Println(\"该鸟类的名字是：\", instance.Name) &#125; else &#123; fmt.Println(\"该动物不是鸟类\") &#125;&#125; 其实，断言还可以将接口转换成另外一个接口： 123456789func Display(a Animal) &#123; instance, ok := a.(Flyer) // 动物接口转换为了飞翔接口 if ok &#123; instance.Fly() &#125; else &#123; fmt.Println(\"该动物不会飞\") &#125;&#125; 一个实现类往往实现了很多接口，为了精准类型查询，可以使用switch语句来判断对象类型： 123456var v1 interfaceP&#123;&#125; = ...switch v := v1.(type) &#123; case int: case string: ...&#125; 三 多态多态是面向对象的三大特性之一，即一个类型具备多种具体的表现形式。 上述示例中，鸟和鱼都实现了动物接口的 Breath方法，即动物的Breath方法在鸟和鱼中具备不同的体现。我们在new出动物的具体对象实例时，这个对象实例也就实现了对应自己的接口方法。 1234567891011121314151617181920212223// New出Animal的函数func NewAnimal(kind string) Animal&#123; switch kind &#123; case \"鸟类\": return &amp;Bird&#123;&#125; case \"鱼类\": return &amp;Fish&#123;&#125; default: return nil &#125;&#125;func main() &#123; // 获取的是动物接口类型，但是实现类是鸟类 a1 := NewAnimal(\"鸟类\") a1.Breath() // 鸟 在 陆地 呼吸 // 获取的是动物接口类型，但是实现类是鱼类 a2 := NewAnimal(\"鱼类\") a2.Breath() // 鱼 在 水下 呼吸&#125;","categories":[{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"}]}],"categories":[{"name":"C#","slug":"C","permalink":"http://www.dwlblog.网址/categories/C/"},{"name":"设计模式","slug":"C/设计模式","permalink":"http://www.dwlblog.网址/categories/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Go学习","slug":"Go学习","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/"},{"name":"并发编程","slug":"Go学习/并发编程","permalink":"http://www.dwlblog.网址/categories/Go%E5%AD%A6%E4%B9%A0/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"Git学习","slug":"Git学习","permalink":"http://www.dwlblog.网址/categories/Git%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.dwlblog.网址/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Go","slug":"Go","permalink":"http://www.dwlblog.网址/tags/Go/"},{"name":"Git","slug":"Git","permalink":"http://www.dwlblog.网址/tags/Git/"}]}